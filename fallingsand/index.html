<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Sand Platformer</title>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            user-select: none;
            overflow: hidden;
        }
        h1 { margin-bottom: 10px; }
        .controls {
            margin-bottom: 10px;
            background: #333;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        .btn-sand { background-color: #f6d7b0; color: #333; }
        .btn-water { background-color: #4fa4f4; color: white; }
        .btn-soil { background-color: #5d4037; color: white; }
        .btn-wall { background-color: #888; color: white; }
        .btn-gas { background-color: #e0e0e0; color: #333; }
        .btn-fire { background-color: #ff4500; color: white; }
        .btn-oil {
            background-color: #5a4622;
            color: #fff;
        }
        .btn-coal {
            background-color: #111111;
            color: #fff;
        }
        .btn-wood { background-color: #8b4513; color: white; }
        .btn-gunpowder { background-color: #444; color: #fff; border: 1px solid #777; }
        .btn-acid { background-color: #00ff00; color: white; }
        .btn-glass { background-color: #e0e0ff; color: #333; }
        .btn-glass-wall { background-color: #b4b4e0; color: #333; }
        .btn-adamantium { background-color: #4d5257; color: white; border: 1px solid #aeb5be; }
        .btn-copper { background-color: #b87333; color: white; }
        .btn-silver { background-color: #c0c0c0; color: #333; }
        .btn-gold { background-color: #ffd700; color: #333; }
        .btn-platinum { background-color: #e5e4e2; color: #333; }
        .btn-rune-wall { background-color: #2a2a3a; color: #d0c0ff; border: 1px solid #5a4a7a; }
        .btn-ground { background-color: #6b4d3c; color: white; }
        .btn-iron { background-color: #7a7a7a; color: white; }
        .btn-obsidian { background-color: #2a223a; color: white; }
        .btn-lava { background-color: #fc440f; color: white; }
        .btn-steam { background-color: #d0d0d0; color: #333; }
        .btn-smoke { background-color: #444444; color: white; }
        .btn-methane { background-color: #e0f0e0; color: #333; }
        .btn-eraser { background-color: #000; color: white; border: 1px solid #555; }
        button.active {
            outline: 2px solid white;
            box-shadow: 0 0 8px rgba(255,255,255,0.6);
        }
        .info-bar { font-size: 14px; color: #ccc; }
        .info-bar strong { color: white; }
        canvas {
            border: 2px solid #555;
            background-color: #000;
            cursor: crosshair;
            image-rendering: pixelated; 
        }
        #controls_ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 8px 10px;
            border-radius: 6px;
            pointer-events: none;
        }
    </style>
</head>
<body>
   <div id="loading-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a2a; color: #fff; z-index: 1000; display: flex; justify-content: center; align-items: center; flex-direction: column;">
        <h1 style="font-size: 2.5em; margin-bottom: 20px;">Falling Sand Platformer</h1>
        <p id="loading-status" style="font-size: 1.2em; font-family: monospace;">Initializing...</p>
    </div>

    <h1>Falling Sand Platformer</h1>
    <div class="info-bar">
        Use <strong>A/D</strong> to Move, <strong>W</strong> to Jump. Use the mouse to build and destroy.
    </div>

    <div class="controls">
        <button class="btn-sand active" onclick="setMaterial('sand')">Sand</button>
        <button class="btn-soil" onclick="setMaterial('soil')">Soil</button>
        <button class="btn-ground" onclick="setMaterial('ground')">Ground</button>
        <button class="btn-water" onclick="setMaterial('water')">Water</button>
        <button class="btn-lava" onclick="setMaterial('lava')">Lava</button>
        <button class="btn-steam" onclick="setMaterial('steam')">Steam</button>
        <button class="btn-smoke" onclick="setMaterial('smoke')">Smoke</button>
        <button class="btn-methane" onclick="setMaterial('methane')">Methane</button>
        <button class="btn-wall" onclick="setMaterial('wall')">Wall</button>
        <button class="btn-wood" onclick="setMaterial('wood')">Wood</button>
        <button class="btn-fire" onclick="setMaterial('fire')">Fire</button>
        <button class="btn-gunpowder" onclick="setMaterial('gunpowder')">Gunpowder</button>
        <button class="btn-oil" onclick="setMaterial('oil')">Oil</button>
        <button class="btn-coal" onclick="setMaterial('coal')">Coal</button>
        <button class="btn-acid" onclick="setMaterial('acid')">Acid</button>
        <button class="btn-glass" onclick="setMaterial('glass')">Glass</button>
        <button class="btn-glass-wall" onclick="setMaterial('glass-wall')">Glass Wall</button>
        <button class="btn-adamantium" onclick="setMaterial('adamantium')">Adamantium</button>
        <button class="btn-copper" onclick="setMaterial('copper')">Copper</button>
        <button class="btn-silver" onclick="setMaterial('silver')">Silver</button>
        <button class="btn-gold" onclick="setMaterial('gold')">Gold</button>
        <button class="btn-platinum" onclick="setMaterial('platinum')">Platinum</button>
        <button class="btn-rune-wall" onclick="setMaterial('rune-wall')">Rune Wall</button>
        <button class="btn-iron" onclick="setMaterial('iron')">Iron</button>
        <button class="btn-obsidian" onclick="setMaterial('obsidian')">Obsidian</button>
        <button class="btn-eraser" onclick="setMaterial('empty')">Eraser</button>
    </div>

    <div id="controls_ui">
        <b>Controls</b><br>
        A / D – Move<br>
        W – Jump<br>
        Q – Switch Container<br>
        Left Click – Pour<br>
        Right Click – Store<br>
        Middle Click – Paint Brush
    </div>

    <div id="generation-status" style="position: fixed; bottom: 10px; left: 10px; color: white; font-family: monospace; font-size: 14px; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; pointer-events: none; display: none; z-index: 1001;">
        Generating...
    </div>

    <canvas id="canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/earcut@2.2.4/dist/earcut.min.js"></script>
    <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>


    <script>
        // --- CONFIGURATION ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const pl = planck;
        let debugMode = false;
        const STATION_FLOOR_Y = 0;

        const generationWorker = new Worker('generation.worker.js'); // ADD THIS LINE
        let WORLD_SEED = 0; // Will be set in mainLoader
        let playerSpawnSX = 0;
        let playerSpawnSY = 0;

        const world = new pl.World({
            gravity: pl.Vec2(0, 10)
        });

        // --- Add this listener for SOLID splashes ---
        world.on('begin-contact', function(contact) {
            const now = performance.now();
            const SPLASH_COOLDOWN_MS = 200;
            const MIN_SPLASH_SPEED = 1.8;

            let dynamicBody;
            if (contact.getFixtureA().getBody().getType() === 'dynamic' && contact.getFixtureB().getBody().getType() === 'static') {
                dynamicBody = contact.getFixtureA().getBody();
            } else if (contact.getFixtureB().getBody().getType() === 'dynamic' && contact.getFixtureA().getBody().getType() === 'static') {
                dynamicBody = contact.getFixtureB().getBody();
            } else {
                return;
            }

            const bodyInstance = dynamicBody.getUserData();
            if (!bodyInstance) return;

            bodyInstance.lastSplashTime = bodyInstance.lastSplashTime ?? 0;
            if (now - bodyInstance.lastSplashTime < SPLASH_COOLDOWN_MS) return;

            const manifold = contact.getWorldManifold();
            if (!manifold.points[0]) return;
            const point = manifold.points[0];

            const impactSpeed = dynamicBody.getLinearVelocityFromWorldPoint(point).length();
            if (impactSpeed < MIN_SPLASH_SPEED) return;

            const worldX = Math.floor(point.x * B2_SCALE);
            const worldY = Math.floor(point.y * B2_SCALE);
            const materialType = getGrid(worldX, worldY);

            // THIS LISTENER ONLY CARES ABOUT SOLIDS
            if (SPLASHABLE_SOLIDS.has(materialType)) {
                createSplashEffect(worldX, worldY, materialType, impactSpeed);
                bodyInstance.lastSplashTime = now;
            }
        });

        world.on('pre-solve', function(contact) {
            const fixtureA = contact.getFixtureA();
            const fixtureB = contact.getFixtureB();
            const bodyA = fixtureA.getBody();
            const bodyB = fixtureB.getBody();
            const userDataA = bodyA.getUserData();
            const userDataB = bodyB.getUserData();

            // Check if one of the bodies is the player and the other is static terrain.
            const isPlayerA = (userDataA === player);
            const isPlayerB = (userDataB === player);
            const isStaticA = (bodyA.getType() === 'static');
            const isStaticB = (bodyB.getType() === 'static');

            if ((isPlayerA && isStaticB) || (isPlayerB && isStaticA)) {
                const manifold = contact.getWorldManifold();
                if (!manifold || !manifold.normal) return;

                // The 'normal' vector points from body A to body B. We need to ensure
                // it always points FROM the static world TO the player.
                let worldNormal = manifold.normal;
                if (isPlayerA) {
                    // If A is the player, the normal points away from the player. Flip it.
                    worldNormal = { x: -worldNormal.x, y: -worldNormal.y };
                }

                // A "walkable" surface has a normal that points mostly upwards (Y is negative).
                // We use a threshold of -0.5 to include gentle slopes as walkable.
                const isWalkableSurface = worldNormal.y < -0.5;

                if (isWalkableSurface) {
                    // If it's a floor or walkable slope, apply the default friction.
                    contact.resetFriction();
                } else {
                    // If it's a wall, ceiling, or steep slope, set friction to zero to prevent sticking.
                    contact.setFriction(0.0);
                }
            }
        });

        const B2_SCALE = 30; // 30 pixels = 1 meter in the physics world
        let rigidBodies = [];
        let staticWorldBodies = []; // To hold temporary terrain colliders
        let activeStaticChunks = new Set();
        let bodiesToDestroy = [];   // NEW: A "kill list" for entire b2Bodies
        let tempVec1 = null;
        let tempVec2 = null;

        const CHUNK_SIZE = 16; // Chunks will be 16x16 pixels
        const CHUNK_SIZE_SQ = CHUNK_SIZE * CHUNK_SIZE;
        let chunkWidth, chunkHeight; // No longer used for world bounds
        
        // --- NEW: CHUNK-BASED WORLD DATA ---
        const chunkMap = new Map();       // Main material grid
        const lightChunkMap = new Map();    // Lighting data
        const etcChunkMap = new Map();      // For ignition timers, rigid body stubs, etc.
        const activeChunks = new Set();     // A set of active chunk KEYs for the current frame
        const nextActiveChunks = new Set(); // A set of chunk KEYs to activate for the *next* frame

        let _lastChunk = null;
        let _lastChunkCX = -99999;
        let _lastChunkCY = -99999;

        // --- START OF NEW CODE ---
        const debugStats = {
            getCalls: 0,
            getHits: 0,
            setCalls: 0,
            setHits: 0,
        };
        // --- END OF NEW CODE ---

        // NEW: Increased view area and reduced scale
        const viewWidth = 480;
        const viewHeight = 270;
        const scale = 3; // Smaller pixels

        const SIMULATION_STEPS_PER_FRAME = 2;

        // --- SECTOR STREAMING CONFIGURATION ---
        const SECTOR_SIZE = 512;
        const WORLD_LAYER_HEIGHT = 2000;
        const MAX_READY_SECTORS = 12;
        let sectorGrid = new Map(); // Will store 'unloaded', 'queued', or 'ready' for each sector
        let lastPlayerSectorX = -1; // Used to track when the player crosses a sector boundary
        let lastPlayerSectorY = -1;
        let activeStubChunks = new Set();
        let npcs = [];
        let nextNpcId = 0;

        canvas.width = viewWidth;
        canvas.height = viewHeight;

        canvas.style.width = viewWidth * scale + "px";
        canvas.style.height = viewHeight * scale + "px";

        canvas.style.imageRendering = "pixelated";

        /*
        
        createMagicTablet(550, STATION_FLOOR_Y - 16, 'increase_tool_slots');
        createMagicTablet(570, STATION_FLOOR_Y - 16, 'increase_structure_slots');
        createMagicTablet(590, STATION_FLOOR_Y - 16, 'unlock_reaction', { reactionKey: 'heat_material' });
        createMagicTablet(610, STATION_FLOOR_Y - 16, 'unlock_reaction', { reactionKey: 'filter_material' });
        
        */

        function createMagicTablet(x, y, upgradeType, data = {}) {
            const width = 16;
            const height = 16;
            const pixels = new Uint8Array(width * height).fill(MAT.MAGIC_WALL);

            let messageTitle = "Upgrade Acquired!";
            let messageText = "Your abilities have been enhanced.";

            // --- Engrave the pattern AND define the message based on the upgrade type ---
            switch (upgradeType) {
                case 'unlock_reaction':
                    const key = data.reactionKey;
                    if (key === 'filter_material') {
                        messageTitle = "Reaction Unlocked: Filter";
                        messageText = "Separates impurities. Place a mixture in the LEFT cauldron, place the material to be filtered in the sampler and activate. The sampled material will move to the RIGHT cauldron.";
                    } else if (key === 'heat_material') {
                        messageTitle = "Reaction Unlocked: Heat";
                        messageText = "Applies intense heat to materials in the LEFT cauldron, causing transmutation.";
                    }
                    // Draw a simple rune pattern
                    const pattern = DWARVEN_RUNES.PATTERNS[Math.floor(Math.random() * DWARVEN_RUNES.PATTERNS.length)];
                    for (let py = 0; py < DWARVEN_RUNES.RUNE_HEIGHT; py++) {
                        for (let px = 0; px < DWARVEN_RUNES.RUNE_WIDTH; px++) {
                            if (pattern[py][px] === 1) {
                                pixels[(3 + py) * width + (4 + px)] = MAT.RUNE_WALL;
                            }
                        }
                    }
                    break;

                case 'increase_tool_slots':
                    messageTitle = "Tool Pouch Expanded!";
                    messageText = "You can now carry one additional tool.";
                    // Draw a simple pickaxe shape
                    const toolShape = ["01100110","00110100","00011000","00011000","00011000","00011000"];
                    for(let py=0; py<toolShape.length; py++) {
                        for(let px=0; px<toolShape[py].length; px++) {
                            if (toolShape[py][px] === '1') {
                                 pixels[(5 + py) * width + (4 + px)] = MAT.RUNE_WALL;
                            }
                        }
                    }
                    break;

                case 'increase_structure_slots':
                    messageTitle = "Structure Bag Expanded!";
                    messageText = "You can now carry one additional placeable structure.";
                     // Draw a simple square outline
                     for(let i = 0; i < 8; i++) {
                         pixels[(4 * width) + 4 + i] = MAT.RUNE_WALL; // Top
                         pixels[(11 * width) + 4 + i] = MAT.RUNE_WALL; // Bottom
                         pixels[((5+i) * width) + 4] = MAT.RUNE_WALL; // Left
                         pixels[((5+i) * width) + 11] = MAT.RUNE_WALL; // Right
                     }
                    break;
            }

            const body = new RigidBody(x, y, width, height, MAT.MAGIC_WALL);
            body.pixels = pixels;
            body.rebuildFixtures();

            const userData = body.body.getUserData();
            userData.isPickup = true;
            userData.messageTitle = messageTitle; // Store the message title
            userData.messageText = messageText;   // Store the message text
            userData.onPickup = (player) => {
                switch (upgradeType) {
                    case 'unlock_reaction':
                        if (data.reactionKey && !player.unlockedReactions.includes(data.reactionKey)) {
                            player.unlockedReactions.push(data.reactionKey);
                        }
                        break;
                    case 'increase_tool_slots':
                        player.maxToolSlots++;
                        break;
                    case 'increase_structure_slots':
                        player.maxStructureSlots++;
                        break;
                }
                displayMessage(userData.messageTitle, userData.messageText);
            };

            rigidBodies.push(body);
        }

        function createObjectInWorld(definitionId, x, y) {
            const def = OBJECT_DEFINITIONS[definitionId];
            if (!def) {
                console.error("Unknown object definition:", definitionId);
                return;
            }

            const body = new RigidBody(x, y, def.width, def.height, MAT.WOOD); // Material is placeholder
            body.pixels = new Uint8Array(def.pixels);
            body.rebuildFixtures();

            // Add custom properties to the body's user data for identification
            const userData = body.body.getUserData();
            userData.isPickup = true;
            userData.definitionId = definitionId;

            rigidBodies.push(body);
        }

        function pickupObject(body) {
            if (body.isDestroyed) return;

            const userData = body.body.getUserData();

            // Handle new dynamic upgrades which have an onPickup function attached directly
            if (userData.onPickup) {
                userData.onPickup(player);
                body.isDestroyed = true; // Mark for cleanup
                // Add a small visual effect for feedback
                spawnMagicParticles(25, body.body.getPosition().x * B2_SCALE, body.body.getPosition().y * B2_SCALE, [200, 180, 255]);

                switch (userData.upgradeType) {
                    case 'increase_tool_slots':
                        displayMessage("Tool Pouch Expanded!", "You can now carry one additional tool.");
                        break;
                    case 'increase_structure_slots':
                        displayMessage("Structure Bag Expanded!", "You can now carry one additional placeable structure.");
                        break;
                    case 'unlock_reaction':
                        const key = userData.data.reactionKey;
                        if (key === 'filter_material') {
                            displayMessage("Reaction Unlocked: Filter", "Separates impurities. Place a mixture in the LEFT cauldron and activate. The least common material will move to the RIGHT cauldron.");
                        } else if (key === 'heat_material') {
                            displayMessage("Reaction Unlocked: Heat", "Applies intense heat to materials in the LEFT cauldron, causing transmutation.");
                        }
                        break;
                }

                return;
            }

            // Handle old definition-based objects
            const def = OBJECT_DEFINITIONS[userData.definitionId];
            
            if (!def) return;

            let pickedUp = false;
            switch (def.type) {
                case 'tool':
                    if (player.toolPocket.length < player.maxToolSlots) {
                        player.toolPocket.push(def.name);
                        pickedUp = true;
                    }
                    break;
                case 'structure':
                    if (player.structurePocket.length < player.maxStructureSlots) {
                        player.structurePocket.push(body); 
                        pickedUp = true;
                    }
                    break;
                case 'upgrade':
                    if (def.onPickup) def.onPickup(player);
                    pickedUp = true; // Upgrades are always consumed
                    break;
            }

            if (pickedUp) {
                body.isDestroyed = true; // Mark for cleanup
            }
        }
        
        const DIALOGUE_TREES = {
            'ylialkemisti_main': {
                'start': {
                    text: "Greetings, Apprentice. You have arrived at a pivotal time. This cave system holds wondrous treasures and profound secrets, culminating in the legendary Philosopher's Stone, deep within the final layer.",
                    options: [
                        { text: "What must I do?", nextNode: 'explain_quest' },
                    ]
                },
                'explain_quest': {
                    text: "The path is fraught with challenges that only a keen mind and a mastery of alchemy can overcome. You must use your wits to transform the very elements around you.",
                    options: [
                        { text: "I am ready to learn.", execute: (npc) => {
                            createMagicTablet(npc.x + 64, npc.y - 12, 'unlock_reaction', { reactionKey: 'filter_material' });
                            
                            npc.dialogueState = 'waiting_for_filter';
                            const stationPieceDef = SetPieceManager.setPieces.find(p => p.name === 'AlchemistStation');
                            if(stationPieceDef) {
                                const pieceInfo = { name: "AlchemistStation", bounds: stationPieceDef.getBounds() };
                                const stationGeo = stationPieceDef.postGenerationHook.call(stationPieceDef, pieceInfo).stationGeometry;
                                
                                fillCauldronWithMixture(stationGeo.cauldrons.left, [MAT.SAND, MAT.COPPER]);

                                // --- MODIFICATION: Move the arrow to the slab ---
                                const slabX = pieceInfo.bounds.x + 130;
                                const slabY = pieceInfo.bounds.y + pieceInfo.bounds.height - 35; // Calculated Y of the slab's top surface
                                const slabW = 70;
                                spawnFloatingArrow(slabX + slabW / 2, slabY - 50); // Point it *above* the slab
                            }
                            DialogueManager.closeDialogue();
                            DialogueManager.startDialogue(npc, DIALOGUE_TREES.ylialkemisti_main);
                        }}
                    ]
                },
                'waiting_for_filter': {
                    text: "I have dropped a tablet of knowledge for you. Pick it up to learn the 'Filter' reaction. Use it at the runic slab to separate the copper from the sand. Return to me once you have the purified copper.",
                    options: [
                        { text: "I will get to it.", execute: () => DialogueManager.closeDialogue() },
                        { text: "I have the copper.", nextNode: 'quest_complete' }
                    ]
                },
                'quest_complete': {
                    text: "Excellent work, Apprentice. You show great promise. This is but the first step on a long journey. Continue your explorations, and may your transmutations be true. If you need any tools or materials, we can trade.",
                    options: [
                        { text: "Trade with me.", nextNode: 'trading_post'},
                        { text: "Thank you, Master.", execute: (npc) => {
                            npc.dialogueState = 'quest_complete'; 
                            despawnFloatingArrow();
                            DialogueManager.closeDialogue();
                        }}
                    ]
                },
                // --- START OF NEW CODE ---
                'trading_post': {
                    text: "Of course. Place your metals in the left cauldron as payment. What can I offer you?",
                    options: [
                        { text: "Show me your wares.", execute: (npc) => {
                             npc.dialogueState = 'quest_complete'; 
                             player.activeStationGeometry = npc.associatedData.stationGeometry;
                             TradeManager.isVisible = true;
                             DialogueManager.closeDialogue();
                        }},
                        { text: "Nevermind.", nextNode: 'quest_complete' }
                    ]
                }
            }
        };

        const UIMessageManager = {
            isVisible: false,
            title: '',
            text: '',
            timer: 0,
            maxTime: 0
        };

        /**
         * Displays a message at the top of the screen.
         * @param {string} title - The bolded title of the message.
         * @param {string} text - The body of the message.
         * @param {number} durationInFrames - How long the message should stay on screen. 60 = 1 second.
         */
        function displayMessage(title, text, durationInFrames = 720) {
            UIMessageManager.title = title;
            UIMessageManager.text = text;
            UIMessageManager.timer = durationInFrames;
            UIMessageManager.maxTime = durationInFrames;
            UIMessageManager.isVisible = true;
        }

        function updateMessageSystem() {
            if (UIMessageManager.timer > 0) {
                UIMessageManager.timer--;
            } else if (UIMessageManager.isVisible) {
                UIMessageManager.isVisible = false;
            }
        }

        function renderMessageUI() {
            if (!UIMessageManager.isVisible) return;

            // Fade out the message in its last second
            const fadeDuration = 60;
            const alpha = UIMessageManager.timer < fadeDuration 
                ? UIMessageManager.timer / fadeDuration 
                : 1;

            const boxW = renderWidth - 80;
            const boxH = 50;
            const boxX = (renderWidth - boxW) / 2;
            const boxY = 100;

            // Draw background box
            ctx.fillStyle = `rgba(20, 20, 30, ${0.8 * alpha})`;
            ctx.fillRect(boxX, boxY, boxW, boxH);
            ctx.strokeStyle = `rgba(160, 160, 192, ${0.9 * alpha})`;
            ctx.strokeRect(boxX, boxY, boxW, boxH);

            // Draw Title
            ctx.fillStyle = `rgba(255, 217, 102, ${alpha})`;
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(UIMessageManager.title, boxX + 10, boxY + 8);

            // Draw Body Text (with word wrapping)
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.font = '8px monospace';
            
            const text = UIMessageManager.text;
            const textX = boxX + 10;
            let textY = boxY + 24;
            const maxWidth = boxW - 20;
            const lineHeight = 10;
            const words = text.split(' ');
            let currentLine = '';

            for (let i = 0; i < words.length; i++) {
                const testLine = currentLine + words[i] + ' ';
                if (ctx.measureText(testLine).width > maxWidth && i > 0) {
                    ctx.fillText(currentLine, textX, textY);
                    currentLine = words[i] + ' ';
                    textY += lineHeight;
                } else {
                    currentLine = testLine;
                }
            }
            ctx.fillText(currentLine, textX, textY);
        }


        const DialogueManager = {
            isVisible: false,
            npcName: '',
            npc: null,
            currentNode: null,
            dialogueTree: null,

            startDialogue: function(npc, tree) {
                if (!tree) return;
                this.isVisible = true;
                this.npcName = npc.name;
                this.npc = npc;
                this.dialogueTree = tree;
                this.currentNode = tree[npc.dialogueState] || tree['start'];
            },

            selectOption: function(index) {
                if (!this.currentNode || !this.currentNode.options[index]) return;

                const option = this.currentNode.options[index];

                if (option.execute) {
                    option.execute(this.npc);
                } else if (option.nextNode && this.dialogueTree[option.nextNode]) {
                    this.currentNode = this.dialogueTree[option.nextNode];
                }
            },

            closeDialogue: function() {
                this.isVisible = false;
                this.npcName = '';
                this.npc = null;
                this.currentNode = null;
                this.dialogueTree = null;
            }
        };

        // (Place this function near other world generation helpers)
        function fillCauldronWithMixture(cauldron, materials) {
            const numParticles = 160;
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI;
                const radius = Math.random() * cauldron.r;
                const x = Math.floor(cauldron.cx + Math.cos(angle) * radius);
                const y = Math.floor(cauldron.cy + Math.sin(angle) * radius);
                
                if (getGrid(x, y) === MAT.EMPTY) {
                    const material = materials[i % materials.length];
                    setGrid(x, y, material);
                }
            }
        }

        // --- In index.html ---

        function createNpc(options) {
            const npc = {
                id: nextNpcId++,
                name: options.name,
                x: options.x,
                y: options.y,
                width: 8, // Using player dimensions for now
                height: 16,
                dialogueTreeId: options.dialogueTreeId,
                dialogueState: 'start',
                associatedData: {}
            };
            npcs.push(npc);

            // Create a trigger for interaction
            createTrigger({
                x: npc.x - 16, // Create a small area around the NPC
                y: npc.y - 8,
                width: npc.width + 32,
                height: npc.height + 16,
                onInteract: () => {
                    const tree = DIALOGUE_TREES[npc.dialogueTreeId];
                    DialogueManager.startDialogue(npc, tree);
                }
            });

            return npc.id;
        }

        const renderWidth = viewWidth;
        const renderHeight = viewHeight;

        const imageData = ctx.createImageData(renderWidth, renderHeight);
        const pixels = imageData.data; // Uint8ClampedArray

        // --- MATERIAL DEFINITIONS ---
        const MAT = {
            EMPTY: 0, ROCK_WALL: 1, SAND: 2, WATER: 3, SOIL: 4, 
            WOOD: 10, FIRE: 11, GUNPOWDER: 12, GUNPOWDER_IGNITED: 13,
            OIL: 14, OIL_BURNING: 15,
            COAL:16, COAL_BURNING:17,
            ACID:18, GLASS:19, GLASS_WALL: 20,
            ADAMANTIUM: 21, COPPER: 22, SILVER: 23, GOLD: 24, PLATINUM: 25, RUNE_WALL: 26,
            SANDSTONE_WALL: 27, VOLCANIC_WALL: 28, LABYRINTH_WALL: 29, MAGIC_WALL: 30,
            // --- START OF NEW MATERIALS (Remove GAS: 5) ---
            GROUND: 31, IRON: 32, RUSTED_IRON: 33, OBSIDIAN: 34,
            LAVA: 40, 
            STEAM: 50, SMOKE: 51, METHANE: 52, METHANE_BURNING: 53,
            // --- END OF NEW MATERIALS ---
            RIGID_BODY_STUB: 99
        };

        const COLORS = {
            [MAT.ROCK_WALL]: [100, 100, 100], [MAT.SAND]: [246, 215, 176],
            [MAT.WATER]: [79, 164, 244], [MAT.SOIL]: [93, 64, 55],
            [MAT.WOOD]: [139, 69, 19], [MAT.FIRE]: [255, 69, 0], 
            [MAT.GUNPOWDER]: [60, 60, 60], [MAT.GUNPOWDER_IGNITED]: [120, 80, 80], 
            [MAT.OIL]: [90, 70, 30], [MAT.OIL_BURNING]: [255, 69, 0],
            [MAT.COAL]: [30, 30, 30], [MAT.COAL_BURNING]: [255, 69, 0],
            [MAT.ACID]: [0, 255, 0], [MAT.GLASS]: [200, 200, 255], [MAT.GLASS_WALL]: [180, 180, 235],
            [MAT.ADAMANTIUM]: [77, 82, 87], [MAT.COPPER]: [184, 115, 51],
            [MAT.SILVER]: [192, 192, 192], [MAT.GOLD]: [255, 215, 100],
            [MAT.PLATINUM]: [229, 228, 226], [MAT.RUNE_WALL]: [200, 200, 100],
            [MAT.SANDSTONE_WALL]: [130, 100, 70], [MAT.VOLCANIC_WALL]: [45, 20, 20],
            [MAT.LABYRINTH_WALL]: [70, 75, 80], [MAT.MAGIC_WALL]: [40, 25, 60],
            // --- START OF NEW COLORS ---
            [MAT.GROUND]: [107, 77, 60], [MAT.IRON]: [122, 122, 122],
            [MAT.RUSTED_IRON]: [180, 90, 50], [MAT.OBSIDIAN]: [42, 34, 58],
            [MAT.LAVA]: [252, 68, 15], [MAT.STEAM]: [208, 208, 208],
            [MAT.SMOKE]: [68, 68, 68], [MAT.METHANE]: [180, 240, 180], [MAT.METHANE_BURNING]: [255, 150, 50],
            // --- END OF NEW COLORS ---
        };

        const MATERIAL_NAME = {
            [MAT.EMPTY]: 'Empty', [MAT.ROCK_WALL]: 'Wall', [MAT.SAND]: 'Sand',
            [MAT.WATER]: 'Water', [MAT.SOIL]: 'Soil', [MAT.WOOD]: 'Wood',
            [MAT.FIRE]: 'Fire', [MAT.GUNPOWDER]: 'Gunpowder',
            [MAT.GUNPOWDER_IGNITED]: 'Gunpowder (Ignited)', [MAT.OIL]: 'Oil',
            [MAT.OIL_BURNING]: 'Burning Oil', [MAT.COAL]: 'Coal',
            [MAT.COAL_BURNING]: 'Burning Coal', [MAT.ACID]: 'Acid',
            [MAT.GLASS]: 'Glass', [MAT.GLASS_WALL]: 'Glass Wall',
            [MAT.ADAMANTIUM]: 'Adamantium', [MAT.COPPER]: 'Copper',
            [MAT.SILVER]: 'Silver', [MAT.GOLD]: 'Gold', [MAT.PLATINUM]: 'Platinum',
            [MAT.RUNE_WALL]: 'Rune Wall', [MAT.SANDSTONE_WALL]: 'Sandstone Wall', 
            [MAT.VOLCANIC_WALL]: 'Volcanic Wall', [MAT.LABYRINTH_WALL]: 'Labyrinth Wall', 
            [MAT.MAGIC_WALL]: 'Magic Wall',
            // --- START OF NEW NAMES (Remove Gas) ---
            [MAT.GROUND]: 'Ground', [MAT.IRON]: 'Iron',
            [MAT.RUSTED_IRON]: 'Rusted Iron', [MAT.OBSIDIAN]: 'Obsidian',
            [MAT.LAVA]: 'Lava', [MAT.STEAM]: 'Steam',
            [MAT.SMOKE]: 'Smoke', [MAT.METHANE]: 'Methane', [MAT.METHANE_BURNING]: 'Burning Methane'
            // --- END OF NEW NAMES ---
        };

        const WALL_TYPES = new Set([
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, 
            MAT.LABYRINTH_WALL, MAT.MAGIC_WALL
        ]);

        let lastColliderUpdateTime = 0;
        const COLLIDER_UPDATE_INTERVAL = 100;

                const OBJECT_DEFINITIONS = {
            'stone_pick': {
                name: 'Stone Pick',
                type: 'tool', // 'tool', 'structure', or 'upgrade'
                width: 16,
                height: 16,
                pixels: [ /* Pixel art for the pickaxe - simplified for now */
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                    1,1,1,0,0,0,0,2,2,0,0,0,0,1,1,1,
                    1,1,0,0,0,0,0,2,2,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,2,2,0,0,0,0,0,1,1,
                    1,0,0,0,0,0,0,2,2,0,0,0,0,0,0,1,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,
                ].map(p => p === 2 ? MAT.WOOD : p), // Helper to use a temp value
                onUse: (player, mouse) => {
                    const useRadius = 6;
                    const softMaterials = new Set([MAT.SAND, MAT.SOIL, MAT.SANDSTONE_WALL, MAT.COAL]);
                    for (let dy = -useRadius; dy <= useRadius; dy++) {
                        for (let dx = -useRadius; dx <= useRadius; dx++) {
                             if (dx*dx + dy*dy > useRadius*useRadius) continue;
                             const wx = mouse.worldX + dx;
                             const wy = mouse.worldY + dy;
                             if (softMaterials.has(getGrid(wx, wy))) {
                                 setGrid(wx, wy, MAT.EMPTY);
                                 activateChunkAt(wx, wy);
                             }
                        }
                    }
                }
            },
            'wooden_barrel': {
                name: 'Wooden Barrel',
                type: 'structure',
                width: 16,
                height: 16,
                canContain: new Set([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM]),
                pixels: [ /* Pixel art for a barrel with an opening */
                    0,0,1,1,0,0,0,0,1,1,1,1,1,1,0,0,
                    0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
                    1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,
                    1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,
                    1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,
                    1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,
                ].map(p => p === 1 ? MAT.WOOD : MAT.EMPTY)
            }
        };

        const TradeManager = {
            isVisible: false,
            currentPage: 0,
            itemsPerPage: 5,
        };

        const TRADE_INVENTORY = [
            { name: "Heat Reaction Tablet", type: 'tablet', cost: { [MAT.COPPER]: 50 }, data: { upgradeType: 'unlock_reaction', reactionData: { reactionKey: 'heat_material' } } },
            { name: "Clear Cauldron Tablet", type: 'tablet', cost: { [MAT.SILVER]: 25 }, data: { upgradeType: 'unlock_reaction', reactionData: { reactionKey: 'clear_cauldrons' } } },
            { name: "Tool Pouch Expansion", type: 'tablet', cost: { [MAT.GOLD]: 10 }, data: { upgradeType: 'increase_tool_slots' } },
            { name: "Structure Bag Expansion", type: 'tablet', cost: { [MAT.GOLD]: 10 }, data: { upgradeType: 'increase_structure_slots' } },
            { name: "Wooden Barrel", type: 'structure', cost: { [MAT.COPPER]: 20 }, data: { definitionId: 'wooden_barrel' } },
            { name: "Stone Pick", type: 'tool', cost: { [MAT.COPPER]: 5 }, data: { definitionId: 'stone_pick' } },
            { name: "25 Gunpowder", type: 'material', cost: { [MAT.COPPER]: 5 }, data: { material: MAT.GUNPOWDER, amount: 25 } },
            { name: "25 Oil", type: 'material', cost: { [MAT.COPPER]: 10 }, data: { material: MAT.OIL, amount: 25 } },
            { name: "50 Sand", type: 'material', cost: { [MAT.COPPER]: 1 }, data: { material: MAT.SAND, amount: 50 } },
            { name: "10 Silver", type: 'material', cost: { [MAT.COPPER]: 100 }, data: { material: MAT.SILVER, amount: 10 } },
            { name: "10 Gold", type: 'material', cost: { [MAT.SILVER]: 100 }, data: { material: MAT.GOLD, amount: 10 } },
        ];

        // --- START OF NEW CODE: TRADE LOGIC FUNCTIONS ---
        function countMetalsInCauldron(cauldron) {
            const counts = { [MAT.COPPER]: 0, [MAT.SILVER]: 0, [MAT.GOLD]: 0 };
            forEachInDownwardSemicircle(cauldron, (x, y) => {
                const type = getGrid(x, y);
                if (counts[type] !== undefined) {
                    counts[type]++;
                }
            });
            return counts;
        }

        function subtractMetalsFromCauldron(cauldron, cost) {
            const costCopy = { ...cost };
            // Iterate backwards to remove from the top of the pile first
            const r = cauldron.r, cx = cauldron.cx, cy = cauldron.cy;
            const minX = Math.floor(cx - r), maxX = Math.ceil(cx + r);
            const minY = Math.floor(cy), maxY = Math.ceil(cy + r);

            for (let y = maxY; y >= minY; y--) {
                for (let x = minX; x <= maxX; x++) {
                    const dx = x - cx, dy = y - cy;
                    if (dx * dx + dy * dy > r * r) continue;
                    
                    const type = getGrid(x, y);
                    if (costCopy[type] && costCopy[type] > 0) {
                        setGrid(x, y, MAT.EMPTY);
                        costCopy[type]--;
                    }
                }
            }
        }

        function purchaseItem(item) {
            const station = player.activeStationGeometry;
            if (!station) return;

            const playerMetals = countMetalsInCauldron(station.cauldrons.left);

            // Check if player can afford it
            for (const mat in item.cost) {
                if ((playerMetals[mat] || 0) < item.cost[mat]) {
                    displayMessage("Transaction Failed", "You do not have enough metal in the left cauldron.", 240);
                    return;
                }
            }

            // If affordable, subtract cost and spawn item
            subtractMetalsFromCauldron(station.cauldrons.left, item.cost);
            const target = station.cauldrons.right;
            const spawnX = target.cx;
            const spawnY = target.cy - 10; // Spawn slightly above the bottom

            switch (item.type) {
                case 'tablet':
                    createMagicTablet(spawnX, spawnY, item.data.upgradeType, item.data.reactionData);
                    break;
                case 'structure':
                    createObjectInWorld(item.data.definitionId, spawnX, spawnY);
                    break;
                case 'tool':
                    createObjectInWorld(item.data.definitionId, spawnX, spawnY);
                    break;
                case 'material':
                    fillCauldronWithMixture(target, Array(item.data.amount).fill(item.data.material));
                    break;
            }
            displayMessage("Transaction Complete!", `You have purchased ${item.name}.`, 240);
        }
        // --- END OF NEW CODE ---

        // --- RUNE DEFINITIONS ---
        // A library of rune patterns. 1 represents the rune material, 0 is empty.
        const DWARVEN_RUNES = {
            // A simple 7x9 pixel font for the runes
            RUNE_WIDTH: 7,
            RUNE_HEIGHT: 9,
            PATTERNS: [
                // "Axe"
                [
                    [0,1,1,1,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,0,1,1,0]
                ],
                // "Hammer"
                [
                    [1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0]
                ],
                // "Shield"
                [
                    [1,1,1,1,1,1,1],
                    [1,0,0,1,0,0,1],
                    [1,0,0,1,0,0,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1]
                ],
                // "Spear"
                [
                    [0,0,0,1,0,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,1,1,1,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ],
                // "Pickaxe"
                [
                    [1,1,0,0,0,1,1],
                    [0,1,1,0,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ]
            ]
        };


        const LIQUID_DENSITY = {
            [MAT.ACID]: 4,
            [MAT.LAVA]: 3,
            [MAT.WATER]: 2,
            [MAT.OIL]: 1,
            [MAT.OIL_BURNING]: 1
        };

        const GAS_DENSITY = {
            [MAT.SMOKE]: 3,
            [MAT.METHANE]: 2,
            [MAT.METHANE_BURNING]: 2,
            [MAT.STEAM]: 1,
        };

        const ALWAYS_VISIBLE_MATERIALS = new Set([
            MAT.RUNE_WALL,
            MAT.ADAMANTIUM // Also used for the alchemy station and world borders
        ]);

        const SHIMMERING_METALS = new Set([
            MAT.ADAMANTIUM,
            MAT.COPPER,
            MAT.SILVER,
            MAT.GOLD,
            MAT.PLATINUM,
            MAT.RUNE_WALL
        ]);

        const SPLASHABLE_SOLIDS = new Set([
            MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS
        ]);

        const STATIC_MATERIALS = new Set([
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, MAT.LABYRINTH_WALL, MAT.MAGIC_WALL, // All walls added
            MAT.WOOD,
            MAT.GLASS_WALL,
            MAT.ADAMANTIUM,
            MAT.RUNE_WALL, 
            MAT.GROUND, 
            MAT.IRON, 
            MAT.RUSTED_IRON, 
            MAT.OBSIDIAN
        ]);


        const MAX_STEP_HEIGHT = 2;
        const GRAVITY = 0.1;
        const MAX_FALL_SPEED = 4;
        const MAX_HOVER_SPEED = 4;

        const PLAYER_DEFAULT_DAMPING = 0.5;
        const PLAYER_SUBMERGED_DAMPING = 5.0;
        const BUOYANCY_FORCE = 6.0;

        const MAX_CHUNKS_PER_FRAME = 150;
        const REGEN_COOLDOWN = 250;
        const REBUILD_COOLDOWN = 250;
        const MIN_ISLAND_PIXELS = 5;
        const LAVA_SOLIDIFICATION_DEPTH = 10;

        // --- Add these new variables ---
        const BLOOM_MATERIALS = {
            [MAT.FIRE]: { color: [255, 150, 50], intensity: 0.9, radius: 12 },
            [MAT.OIL_BURNING]: { color: [255, 165, 0], intensity: 0.8, radius: 10 },
            [MAT.COAL_BURNING]: { color: [255, 140, 20], intensity: 0.7, radius: 8 },
            [MAT.GUNPOWDER_IGNITED]: { color: [200, 100, 100], intensity: 0.5, radius: 4 },
            [MAT.RUNE_WALL]: { color: [200, 180, 255], intensity: 0.3, radius: 6 },
            [MAT.COPPER]: { color: [220, 200, 200], intensity: 0.01, radius: 3 },
            [MAT.SILVER]: { color: [200, 200, 220], intensity: 0.01, radius: 3 },
            [MAT.GOLD]: { color: [220, 220, 180], intensity: 0.01, radius: 3 },
            [MAT.LAVA]: { color: [250, 180, 100], intensity: 1.0, radius: 16 },
        };

        const PLAYER_INTERACTION_RADIUS = 30; // Max distance for right-click actions
        let toolUseCooldown = 0; // To prevent spamming tools

        // Off-screen canvas for the bloom effect
        let bloomCanvas;
        let bloomCtx;
        // --- End of new variables ---

        let pendingActiveChunks = []; // An array to hold active chunks that were deferred from the previous frame.
        
        // REMOVED old grid definitions
        let currentMaterial = MAT.SAND;
        let isDrawing = false;
        let isStoring = false;
        let frameCount = 0;
        let playerFacingRight = true;
		let projectiles = [];
        let alchemyJobs = [];

        let tSimMs = 0, tRenderMs = 0, tOtherMs = 0, tOtherMs2 = 0, tOtherMs3 = 0;
        const movedInFrame = new Set();

        const MAX_LIGHT_LEVEL = 30;
        const LIGHTING_UPDATE_INTERVAL = 30;
        const VISIBLE_LIQUID_SCAN_INTERVAL = 5; // Update lighting every 30 frames

        // --- Magic Particle System ---
        const MAX_MAGIC_PARTICLES = 5000;
        const magicParticlePool = [];
        for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
            magicParticlePool.push({ x: 0, y: 0, vx: 0, vy: 0, lifespan: 0, color: [0,0,0], gravity: 0, active: false });
        }

        let magicEmitters = [];
        let nextEmitterId = 0;
        let firePixelsCoords = [];
        let triggers = [];
        let nextTriggerId = 0;
        let isAlchemyUIVisible = false;

        let lastFpsTime = performance.now();
        let framesThisSecond = 0;
        let fps = 0;
        let leftToRight = true;

        let hudFPS = 0;
        let hudMaterial = '--';
        let hudTimer = 0;
        
        // --- NEW: TILEABLE BACKGROUND ---
        let backgroundPattern = null;
        const BACKGROUND_TILE_SIZE = 512;

        // --- INVENTORY AND CONTAINERS ---
        const pouchWidth = 32;
        const pouchHeight = 32;
        const flaskWidth = 24;
        const flaskHeight = 40;

        let pouchGrid = new Array(pouchWidth * pouchHeight).fill(MAT.EMPTY);
        let flaskGrid = new Array(flaskWidth * flaskHeight).fill(MAT.EMPTY);

        let activeContainer = 'pouch'; // 'pouch' or 'flask'
        let isPouring = false;
        let pourCooldown = 0;
        let pouredParticles = []; // For the pouring stream effect
        let activeStubs = [];

        const STORABLE_SOLIDS = new Set([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM]);
        const STORABLE_LIQUIDS = new Set([MAT.WATER, MAT.OIL, MAT.ACID]);

        let fluidsCanvas = null;
        let fluidsCtx = null;
        let fluidsImageData = null;
        let fluidsPixels = null;

        function fluidAlpha(type) {
            if (type === MAT.METHANE_BURNING) return 120; // Make it visible but transparent
            if (type === MAT.SMOKE) return 100;
            if (type === MAT.STEAM) return 80;
            if (type === MAT.METHANE) return 40;
            if (LIQUIDS.has(type)) return 140;
            return 255;
        }

        function isFluid(type) {
            return GASES.has(type) || LIQUIDS.has(type);
        }

        // --- START OF NEW FUNCTION ---
        /**
         * Efficiently finds the topmost dynamic rigid body at a given world coordinate.
         */
        function getRigidBodyAt(worldX, worldY) {
            const pMin = pl.Vec2((worldX) / B2_SCALE, (worldY) / B2_SCALE);
            const pMax = pl.Vec2((worldX + 1) / B2_SCALE, (worldY + 1) / B2_SCALE);
            const aabb = new pl.AABB(pMin, pMax);
            let hitBody = null;
            world.queryAABB(aabb, (fixture) => {
                const body = fixture.getBody();
                if (body.getType() === 'dynamic') {
                    const userData = body.getUserData();
                    // Ensure it's a body we created with pixel data (not the player)
                    if (userData && userData.pixels) {
                        hitBody = userData;
                        return false; // Stop searching, we found one
                    }
                }
                return true; // Continue searching
            });
            return hitBody;
        }
        // --- END OF NEW FUNCTION ---
        
        /**
         * Calculates the local 1D index from local 2D coordinates within a chunk.
         */
        const getLocalIndex = (lx, ly) => ly * CHUNK_SIZE + lx;

        function getChunk(map, key, fillValue = 0) {
            if (!map.has(key)) {
                // This part is rarely called, so we can calculate cx, cy here if needed for the object.
                // However, it's better to pass them in if we can.
                const newChunk = {
                    key: key,
                    // cx, cy will be added by the functions that call this
                    data: new Uint8Array(CHUNK_SIZE_SQ).fill(fillValue),
                    staticBody: null,
                    dirty: true,
                    lastRegenTime: 0
                };
                map.set(key, newChunk);
                return newChunk;
            }
            return map.get(key);
        }

        function getGrid(x, y) {
            debugStats.getCalls++;
            // THE FIX: Use Math.floor() to correctly handle negative coordinates.
            const cx = Math.floor(x / CHUNK_SIZE);
            const cy = Math.floor(y / CHUNK_SIZE);

            // The caching logic itself is correct and can remain.
            if (cx !== _lastChunkCX || cy !== _lastChunkCY) {
                _lastChunkCX = cx;
                _lastChunkCY = cy;
                _lastChunk = chunkMap.get(coordToKey(cx, cy));
            } else {
                debugStats.getHits++;
            }

            if (!_lastChunk) {
                return MAT.EMPTY;
            }

            // The bitwise & for local coordinates is correct for negative numbers.
            const lx = x & (CHUNK_SIZE - 1);
            const ly = y & (CHUNK_SIZE - 1);
            return _lastChunk.data[ly * CHUNK_SIZE + lx];
        }

        // --- START OF REPLACEMENT ---
        function setGrid(x, y, type, updateChunkComplex = false) {
            debugStats.setCalls++;
            const cx = Math.floor(x / CHUNK_SIZE);
            const cy = Math.floor(y / CHUNK_SIZE);
            let chunk;

            // THE FIX: Add a check to ensure _lastChunk is not undefined before using it.
            if (cx === _lastChunkCX && cy === _lastChunkCY && _lastChunk) {
                debugStats.setHits++;
                chunk = _lastChunk;
            } else {
                // This block is now correctly entered when the cached chunk was undefined.
                const key = coordToKey(cx, cy);
                chunk = getChunk(chunkMap, key, MAT.EMPTY);
                _lastChunk = chunk;
                _lastChunkCX = cx;
                _lastChunkCY = cy;
            }
            
            if (chunk.cx === undefined) {
                chunk.cx = cx;
                chunk.cy = cy;
            }

            const lx = x & (CHUNK_SIZE - 1);
            const ly = y & (CHUNK_SIZE - 1);
            const lIdx = ly * CHUNK_SIZE + lx;

            const oldType = chunk.data[lIdx];
            if (type === oldType) return;

            const wasSolid = isSolidForPlayer(oldType);
            const isSolid = isSolidForPlayer(type);

            if (wasSolid !== isSolid) {
                chunk.dirty = true;
            }
            
            chunk.data[lIdx] = type;

            if (updateChunkComplex)
            {
                activateChunkAt(x, y);
            } else {
                ensureChunkIsActive(x, y);
            }
        }

        function getAuxData(map, x, y, defaultValue = 0) {
            // THE FIX: Use Math.floor() here too.
            const cx = Math.floor(x / CHUNK_SIZE);
            const cy = Math.floor(y / CHUNK_SIZE);
            const key = coordToKey(cx, cy);

            const chunk = map.get(key);
            if (!chunk) return defaultValue;
            
            const lx = x & (CHUNK_SIZE - 1);
            const ly = y & (CHUNK_SIZE - 1);
            return chunk.data[ly * CHUNK_SIZE + lx];
        }
        
        function setAuxData(map, x, y, value) {
            // THE FIX: And finally, use Math.floor() here.
            const cx = Math.floor(x / CHUNK_SIZE);
            const cy = Math.floor(y / CHUNK_SIZE);
            const key = coordToKey(cx, cy);
            const chunk = getChunk(map, key, 0);

            if (chunk.cx === undefined) {
                chunk.cx = cx;
                chunk.cy = cy;
            }
            
            const lx = x & (CHUNK_SIZE - 1);
            const ly = y & (CHUNK_SIZE - 1);
            chunk.data[getLocalIndex(lx, ly)] = value;
        }


        /**
         * Combines two 32-bit integers (x, y coordinates) into a single unique 64-bit-safe number.
         * This is extremely fast and avoids creating new strings for keys.
         */
        function coordToKey(x, y) {
            // Using multiplication with a large prime is a simple and effective way to create a unique hash.
            // This works reliably for both positive and negative coordinates in JavaScript.
            return x * 374761393 + y * 668265263;
        }

        // --- END: NEW CHUNK-BASED DATA HELPERS ---


        function validatePolygon(points) {
            // This function can be kept for debugging physics shapes, no changes needed.
            return;
        }

        /**
         * An empty, "bare-bones" version of the settling function for testing.
         */
        async function preSettleSector(sectorX, sectorY) {
            return Promise.resolve();
        }

        // --- ASYNCHRONOUS GENERATION WORKER & QUEUE ---
        let generationQueue = [];

        generationWorker.onmessage = (event) => {
            const { type, sx, sy, chunks, lightChunks } = event.data; // Now receives lightChunks

            if (type === 'result') {
                // Integrate terrain chunks
                for (const [key, payload] of chunks) {
                    const chunk = getChunk(chunkMap, key);
                    chunk.data = payload.data;
                    chunk.cx = payload.cx;
                    chunk.cy = payload.cy;
                }

                for (const [key, payload] of lightChunks) {
                    const chunk = getChunk(lightChunkMap, key);
                    chunk.data = payload.data;
                    chunk.cx = payload.cx;
                    chunk.cy = payload.cy;
                }
                
                const key = coordToKey(sx, sy);
                sectorGrid.set(key, { state: 'ready', sx: sx, sy: sy });

                isGenerating = false;
                isRenderCacheInvalid = true; // Invalidate cache now that all data is ready
            }
        };

        // In index.html

        function gatherBorderContext(sectorX, sectorY) {
            const context = {}; // Use a plain object, not a Map
            const startX = sectorX * SECTOR_SIZE;
            const startY = sectorY * SECTOR_SIZE;
            const endX = startX + SECTOR_SIZE;
            const endY = startY + SECTOR_SIZE;

            for (let y = startY - 1; y <= endY; y++) {
                for (let x = startX - 1; x <= endX; x++) {
                    if (x >= startX && x < endX && y >= startY && y < endY) continue;

                    const neighborSectorX = Math.floor(x / SECTOR_SIZE);
                    const neighborSectorY = Math.floor(y / SECTOR_SIZE);
                    if (sectorGrid.get(coordToKey(neighborSectorX, neighborSectorY)) === 'ready') {
                        const key = coordToKey(x, y);
                        // Assign to object property
                        context[key] = {
                            terrain: getGrid(x, y),
                            light: getAuxData(lightChunkMap, x, y)
                        };
                    }
                }
            }
            return context;
        }

        // This function will be called from our game loop to feed tasks to the worker.
        let isGenerating = false; // This now acts as a simple lock
        
        function checkGenerationQueue() {
            if (isGenerating || generationQueue.length === 0) {
                return;
            }

            isGenerating = true;
            const statusElement = document.getElementById('generation-status');
            statusElement.innerText = `Generating... (${generationQueue.length} sectors left)`;
            statusElement.style.display = 'block';

            const sector = generationQueue.shift();
            
            // --- START OF MODIFICATION ---
            
            // Determine the biome and set pieces for the sector being generated.
            const biomeInfo = BiomeManager.getBiomeForSector(sector.sx, sector.sy);
            const setPieces = SetPieceManager.getSetPiecesForSector(sector.sx, sector.sy);

            // The default biome if none is found.
            const finalBiomeInfo = biomeInfo || { name: "OceanOfRock", params: {} };

            generationWorker.postMessage({ 
                type: 'generate-and-bake', 
                sx: sector.sx, 
                sy: sector.sy,
                borderContext: gatherBorderContext(sector.sx, sector.sy),
                // Pass the new biome and set piece data to the worker.
                biomeInfo: finalBiomeInfo,
                setPieces: setPieces 
            });
            // --- END OF MODIFICATION ---
        }

        async function updateSectors() {
            const playerSectorX = Math.floor(player.x / SECTOR_SIZE);
            const playerSectorY = Math.floor(player.y / SECTOR_SIZE);

            if (playerSectorX === lastPlayerSectorX && playerSectorY === lastPlayerSectorY) return;
            
            lastPlayerSectorX = playerSectorX;
            lastPlayerSectorY = playerSectorY;

            for (let sy = playerSectorY - 1; sy <= playerSectorY + 1; sy++) {
                for (let sx = playerSectorX - 1; sx <= playerSectorX + 1; sx++) {
                    const key = coordToKey(sx, sy);
                    const sector = sectorGrid.get(key);
                    const state = sector ? sector.state : 'unloaded';

                    if (state === 'unloaded') {
                        if (loadSectorFromStorage(sx, sy)) {
                            sectorGrid.set(key, { state: 'ready', sx, sy });
                            isRenderCacheInvalid = true; 
                        } else {
                            sectorGrid.set(key, { state: 'queued', sx, sy });
                            generationQueue.push({ sx, sy });
                        }
                    } else if (state === 'ready') {
                        sectorGrid.delete(key);
                        sectorGrid.set(key, sector);
                    }
                }
            }
        }

        class RigidBody {
            constructor(x, y, width, height, material) {
                this.width = width;
                this.height = height;
                this.pixels = new Uint8Array(width * height);
                this.moved = new Uint8Array(width * height);
                this.materialType = material;
                this.fixtureCount = 0;
                
                this.isDestroyed = false;
                this.needsShapeUpdate = false;
                this.lastRebuildTime = 0;
                this.isSplit = false;

                this.pixels.fill(this.materialType);

                this.body = world.createBody({
                    type: 'dynamic',
                    position: pl.Vec2(x / B2_SCALE, y / B2_SCALE)
                });
                this.body.setUserData(this);
                
                this._createFixturesFromPixels(); 
            }

            reintroduceToWorld(x, y) {
                // If it somehow already has a body, do nothing.
                if (this.body) return;

                this.isDestroyed = false;
                this.body = world.createBody({
                    type: 'dynamic',
                    position: pl.Vec2(x / B2_SCALE, y / B2_SCALE)
                });
                this.body.setUserData(this);
                
                // Use the existing method to build fixtures from its stored pixel data.
                this.rebuildFixtures();
            }

            addPixel(type) {
                // Find an empty spot at the top-center of the body's internal grid
                const startX = Math.floor(this.width / 2) - 1;
                for (let y = 0; y < this.height; y++) {
                    for (let dx = 0; dx < 3; dx++) { // Check a 3-pixel wide area
                        const x = startX + dx;
                        const lIdx = y * this.width + x;
                        if (this.pixels[lIdx] === MAT.EMPTY) {
                            this.pixels[lIdx] = type;
                            return true; // Pixel placed successfully
                        }
                    }
                }
                return false; // Could not find a spot
            }

            rebuildFixtures() {
                let f = this.body.getFixtureList();
                while (f) {
                    const next = f.getNext();
                    this.body.destroyFixture(f);
                    f = next;
                }
                this._createFixturesFromPixels();
                this.needsShapeUpdate = false;
            }

            getBinaryMask() {
                const mask = new Uint8Array(this.width * this.height);
                for (let i = 0; i < mask.length; i++) {
                    const t = this.pixels[i];
                    mask[i] = (t !== MAT.EMPTY && !GASES.has(t)) ? 1 : 0;
                }
                return mask;
            }

            _createFixturesFromPixels() {
                this.fixtureCount = 0;
                const w = this.width;
                const h = this.height;
                const mask = new Uint8Array(w * h);

                for (let i = 0; i < mask.length; i++) {
                    const t = this.pixels[i];
                    mask[i] = (t !== MAT.EMPTY && !GASES.has(t)) ? 1 : 0;
                }

                if (!mask.some(v => v === 1)) {
                    this.isDestroyed = true;
                    return;
                }

                const islands = extractIslands(mask, w, h);

                for (const island of islands) {
                    const outline = marchingSquares(island, w, h);
                    if (outline.length < 3) continue;
                    const preSimplified = simplifyDouglasPeucker(outline, 1.0);
                    if (preSimplified.length < 3) continue;
                    const simplified = removeCollinear(preSimplified, 0.01);
                    if (simplified.length < 3) continue;

                    validatePolygon(simplified);

                    const flat = [];
                    for (const p of simplified) flat.push(p.x, p.y);
                    const indices = earcut(flat);

                    for (let i = 0; i < indices.length; i += 3) {
                        const p0 = simplified[indices[i]];
                        const p1 = simplified[indices[i + 1]];
                        const p2 = simplified[indices[i + 2]];

                        const ax = (p0.x - w / 2) / B2_SCALE, ay = (p0.y - h / 2) / B2_SCALE;
                        const bx = (p1.x - w / 2) / B2_SCALE, by = (p1.y - h / 2) / B2_SCALE;
                        const cx = (p2.x - w / 2) / B2_SCALE, cy = (p2.y - h / 2) / B2_SCALE;

                        const area = Math.abs(ax*(by-cy) + bx*(cy-ay) + cx*(ay-by)) * 0.5;
                        if (area < 0.00001) continue;

                        const cross = (bx-ax)*(cy-ay) - (by-ay)*(cx-ax);
                        let verts = (cross < 0)
                            ? [pl.Vec2(ax,ay), pl.Vec2(cx,cy), pl.Vec2(bx,by)]
                            : [pl.Vec2(ax,ay), pl.Vec2(bx,by), pl.Vec2(cx,cy)];

                        try {
                            this.body.createFixture(pl.Polygon(verts), { density: 1.0, friction: 0.6, restitution: 0.1 });
                            this.fixtureCount++;
                        } catch (e) { continue; }
                    }
                }
                this.body.resetMassData();
            }
        }

        function extractIslands(mask, w, h) {
            const visited = new Uint8Array(mask.length);
            const islands = [];
            const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y*w+x;
                    if (!mask[idx] || visited[idx]) continue;
                    const stack = [[x,y]];
                    const island = new Set();
                    visited[idx] = 1;
                    while (stack.length) {
                        const [cx, cy] = stack.pop();
                        island.add(cy*w+cx);
                        for (const [dx,dy] of dirs) {
                            const nx = cx+dx, ny = cy+dy;
                            if (nx<0||ny<0||nx>=w||ny>=h) continue;
                            const nIdx = ny*w+nx;
                            if (mask[nIdx] && !visited[nIdx]) {
                                visited[nIdx]=1;
                                stack.push([nx,ny]);
                            }
                        }
                    }
                    islands.push(island);
                }
            }
            return islands;
        }

        function marchingSquares(island, w, h) {
            const isSolid = (x, y) => (x >= 0 && y >= 0 && x < w && y < h) ? island.has(y * w + x) : false;
            let start = null;
            for (const idx of island) {
                const x = idx % w, y = Math.floor(idx / w);
                if (!isSolid(x - 1, y)) { start = { x, y }; break; }
            }
            if (!start) return [];
            const outline = [];
            let x = start.x, y = start.y, dir = 0;
            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            do {
                outline.push({ x: x + 0.5, y: y + 0.5 });
                for (let i = 0; i < 4; i++) {
                    const ndir = (dir + 3 + i) % 4;
                    const nx = x + dirs[ndir][0], ny = y + dirs[ndir][1];
                    if (isSolid(nx, ny)) {
                        x = nx; y = ny; dir = ndir;
                        break;
                    }
                }
            } while (!(x === start.x && y === start.y));
            return outline;
        }

        function simplifyDouglasPeucker(points, epsilon) {
            if (points.length < 3) return points;
            const sqDist = (p, a, b) => {
                const dx = b.x - a.x, dy = b.y - a.y;
                const t = ((p.x-a.x)*dx + (p.y-a.y)*dy)/(dx*dx+dy*dy);
                const proj = {x:a.x+t*dx,y:a.y+t*dy};
                return (p.x-proj.x)**2 + (p.y-proj.y)**2;
            };
            const simplify = (pts) => {
                let maxDist = 0, index = 0;
                for (let i=1;i<pts.length-1;i++){
                    const d = sqDist(pts[i], pts[0], pts[pts.length-1]);
                    if (d>maxDist){maxDist=d;index=i;}
                }
                if (Math.sqrt(maxDist) > epsilon){
                    const left = simplify(pts.slice(0,index+1));
                    const right = simplify(pts.slice(index));
                    return left.slice(0,-1).concat(right);
                }
                return [pts[0], pts[pts.length-1]];
            };
            return simplify(points);
        }

        function removeCollinear(points, epsilon = 0.001) {
            const result = [];
            for (let i = 0; i < points.length; i++) {
                const prev = points[(i-1+points.length)%points.length], curr = points[i], next = points[(i+1)%points.length];
                const ax = curr.x-prev.x, ay = curr.y-prev.y, bx = next.x-curr.x, by = next.y-curr.y;
                if (Math.abs(ax*by-ay*bx) > epsilon) result.push(curr);
            }
            return result;
        }

        function isPixelSolidForConnectivity(type) {
            return type !== MAT.EMPTY && !GASES.has(type);
        }

        function findPixelIslands(pixels, width, height) {
            const islands = [], visited = new Uint8Array(width * height);
            const getIdx = (x, y) => y*width+x;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = getIdx(x, y);
                    if (isPixelSolidForConnectivity(pixels[idx]) && !visited[idx]) {
                        const newIsland = [], queue = [{x, y}];
                        visited[idx] = 1;
                        while (queue.length > 0) {
                            const current = queue.shift();
                            newIsland.push(current);
                            const neighbors = [{dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:0},{dx:-1,dy:0},{dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}];
                            for (const n of neighbors) {
                                const nx = current.x+n.dx, ny = current.y+n.dy;
                                if (nx>=0 && nx<width && ny>=0 && ny<height) {
                                    const nIdx = getIdx(nx, ny);
                                    if (isPixelSolidForConnectivity(pixels[nIdx]) && !visited[nIdx]) {
                                        visited[nIdx] = 1;
                                        queue.push({x:nx, y:ny});
                                    }
                                }
                            }
                        }
                        islands.push(newIsland);
                    }
                }
            }
            return islands;
        }

        function checkForSplits(body) {
            const islands = findPixelIslands(body.pixels, body.width, body.height);
            if (islands.length <= 1) return null;

            const MIN_ISLAND_PIXELS = 6;
            const validIslands = [], smallIslands = [];
            for (const island of islands) {
                if (island.length >= MIN_ISLAND_PIXELS) validIslands.push(island);
                else smallIslands.push(island);
            }
            if (validIslands.length <= 1) return null;

            for (const island of smallIslands) {
                for (const p of island) body.pixels[p.y*body.width+p.x] = MAT.EMPTY;
            }

            const oldBody = body.body, oldAngle = oldBody.getAngle(), oldLinVel = oldBody.getLinearVelocity(), oldAngVel = oldBody.getAngularVelocity();
            const newBodies = [];

            for (const island of validIslands) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of island) {
                    if (p.x<minX) minX=p.x; if (p.y<minY) minY=p.y;
                    if (p.x>maxX) maxX=p.x; if (p.y>maxY) maxY=p.y;
                }
                const newWidth = maxX - minX + 1, newHeight = maxY - minY + 1;
                const localOriginX = (minX+newWidth/2)-(body.width/2), localOriginY = (minY+newHeight/2)-(body.height/2);
                const worldOrigin = oldBody.getWorldPoint(pl.Vec2(localOriginX/B2_SCALE, localOriginY/B2_SCALE));
                const worldX = worldOrigin.x*B2_SCALE, worldY = worldOrigin.y*B2_SCALE;
                const newPixels = new Uint8Array(newWidth*newHeight).fill(MAT.EMPTY);
                for (const p of island) {
                    const nx = p.x-minX, ny = p.y-minY;
                    newPixels[ny*newWidth+nx] = body.pixels[p.y*body.width+p.x];
                }
                const nb = new RigidBody(worldX, worldY, newWidth, newHeight, body.materialType);
                nb.pixels = newPixels;
                nb.rebuildFixtures();
                nb.body.setAngle(oldAngle);
                nb.body.setLinearVelocity(pl.Vec2(oldLinVel.x, oldLinVel.y));
                nb.body.setAngularVelocity(oldAngVel);
                nb.body.setAwake(false);
                newBodies.push(nb);
            }

            world.destroyBody(oldBody);
            body.body = null;
            body.isDestroyed = true;
            return newBodies;
        }

        /**
         * Scans the initial spawn area and activates any chunks containing dynamic materials.
         */
        function activateInitialChunks() {
            const startX = Math.floor(player.x - viewWidth);
            const endX = Math.floor(player.x + viewWidth);
            const startY = Math.floor(player.y - viewHeight);
            const endY = Math.floor(player.y + viewHeight);

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const type = getGrid(x, y);
                    if (type !== MAT.EMPTY && !STATIC_MATERIALS.has(type)) {
                        activateChunkAt(x, y);
                    }
                }
            }
        }

        // --- START OF MODIFICATION (Renamed function) ---
        function findAndActivateLiquidSurfaces() {
        // --- END OF MODIFICATION ---
            const surfaceChunks = new Set();
            const startX = Math.floor(camera.x);
            const startY = Math.floor(camera.y);
            const endX = startX + viewWidth;
            const endY = startY + viewHeight;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const type = getGrid(x, y);
                    if (isLiquid(type)) {
                        const aboveType = getGrid(x, y - 1);
                        if (aboveType === MAT.EMPTY) {
                            const chunkX = Math.floor(x / CHUNK_SIZE);
                            const chunkY = Math.floor(y / CHUNK_SIZE);
                            surfaceChunks.add(coordToKey(chunkX, chunkY));
                        }
                    }
                }
            }
            for (const key of surfaceChunks) {
                nextActiveChunks.add(key);
            }
        }

        // --- START OF NEW FUNCTION ---
        /**
         * Scans the visible screen area for gas clouds and activates their chunks.
         * A gas cloud is considered "active" if it has empty space above it to rise into.
         */
        function findAndActivateGasClouds() {
            const gasChunks = new Set();
            const startX = Math.floor(camera.x);
            const startY = Math.floor(camera.y);
            const endX = startX + viewWidth;
            const endY = startY + viewHeight;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    // Check for a gas pixel that is directly above an empty pixel.
                    // This is the "leading edge" of a gas cloud that needs to be simulated.
                    if ( GASES.has(getGrid(x, y)) && getGrid(x, y + 1) === MAT.EMPTY) {
                        const chunkX = Math.floor(x / CHUNK_SIZE);
                        const chunkY = Math.floor(y / CHUNK_SIZE);
                        gasChunks.add(coordToKey(chunkX, chunkY));
                    }
                }
            }
            for (const key of gasChunks) {
                nextActiveChunks.add(key);
            }
        }
        // --- END OF NEW FUNCTION ---

        function ensureChunkIsActive(worldX, worldY) {
            const chunkX = Math.floor(worldX / CHUNK_SIZE);
            const chunkY = Math.floor(worldY / CHUNK_SIZE);
            nextActiveChunks.add(coordToKey(chunkX, chunkY));
        }

        function activateChunkAt(worldX, worldY) {
            const chunkX = Math.floor(worldX / CHUNK_SIZE);
            const chunkY = Math.floor(worldY / CHUNK_SIZE);
            for (let cy = chunkY - 1; cy <= chunkY + 1; cy++) {
                for (let cx = chunkX - 1; cx <= chunkX + 1; cx++) {
                    nextActiveChunks.add(coordToKey(cx, cy)); // USE NUMERIC KEY
                }
            }
        }

        /**
         * A self-contained Perlin Noise generator object.
         */
        const PerlinNoise = {
            p: [],
            seed: function(s) {
                let random = (() => { let sd=s; return () => (sd=(sd*9301+49297)%233280)/233280; })();
                this.p = new Uint8Array(512); let perm = [];
                for (let i=0;i<256;i++) perm.push(i);
                for (let i=perm.length-1;i>0;i--) { const j=Math.floor(random()*(i+1)); [perm[i],perm[j]]=[perm[j],perm[i]]; }
                for (let i=0;i<256;i++) this.p[i] = this.p[i+256] = perm[i];
            },
            fade: t => t*t*t*(t*(t*6-15)+10), lerp: (t,a,b) => a+t*(b-a),
            grad: function(h,x,y,z) { let u=h<8?x:y, v=h<4?y:h===12||h===14?x:z; return ((h&1)===0?u:-u)+((h&2)===0?v:-v); },
            noise: function(x,y,z=0) {
                let X=Math.floor(x)&255, Y=Math.floor(y)&255, Z=Math.floor(z)&255;
                x-=Math.floor(x); y-=Math.floor(y); z-=Math.floor(z);
                let u=this.fade(x),v=this.fade(y),w=this.fade(z);
                let A=this.p[X]+Y,AA=this.p[A]+Z,AB=this.p[A+1]+Z,B=this.p[X+1]+Y,BA=this.p[B]+Z,BB=this.p[B+1]+Z;
                return this.lerp(w,this.lerp(v,this.lerp(u,this.grad(this.p[AA],x,y,z),this.grad(this.p[BA],x-1,y,z)),this.lerp(u,this.grad(this.p[AB],x,y-1,z),this.grad(this.p[BB],x-1,y-1,z))),this.lerp(v,this.lerp(u,this.grad(this.p[AA+1],x,y,z-1),this.grad(this.p[BA+1],x-1,y,z-1)),this.lerp(u,this.grad(this.p[AB+1],x,y-1,z-1),this.grad(this.p[BB+1],x-1,y-1,z-1))));
            }
        };

        // --- BIOME AND SET PIECE MANAGEMENT ---

        const BiomeManager = {
            biomes: [
                {
                    name: "Caves",
                    // Defines the biome's boundaries based on the player's spawn point.
                    getBounds: (spawnSX, spawnSY) => ({
                        x1: spawnSX - 4,
                        y1: spawnSY,
                        x2: spawnSX + 4,
                        y2: spawnSY + 24,
                    }),
                    // Determines generation parameters for a specific sector within this biome.
                    getGenerationParams: function(sx, sy, bounds) {
                        const sectorsPerLayer = 5;
                        const layerIndex = Math.floor((sy - bounds.y1) / sectorsPerLayer);
                        
                        // Return a simple object describing how the worker should generate this sector.
                        return {
                            layer: Math.min(4, layerIndex) // Clamp to max layer index
                        };
                    }
                }
            ],

            // Finds the appropriate biome for a given sector coordinate.
            getBiomeForSector: function(sx, sy) {
                for (const biome of this.biomes) {
                    const bounds = biome.getBounds(playerSpawnSX, playerSpawnSY);
                    if (sx >= bounds.x1 && sx <= bounds.x2 && sy >= bounds.y1 && sy <= bounds.y2) {
                        return {
                            name: biome.name,
                            params: biome.getGenerationParams(sx, sy, bounds)
                        };
                    }
                }
                return null; // No biome found for this sector
            }
        };

        // --- In index.html ---

        const SetPieceManager = {
            setPieces: [
                {
                    name: "AlchemistStation",
                    
                    getBounds: () => {
                        const stationHeight = 200;
                        const stationWidth = SECTOR_SIZE * 2;
                        const stationTopY = STATION_FLOOR_Y - 188;
                        const stationTopX = 0;
                        return { x: stationTopX, y: stationTopY, width: stationWidth, height: stationHeight };
                    },

                    stationGeometry: {
                        cauldrons: {
                            left:  { cx: 260, cy: 160, r: 32 - 4 },
                            right: { cx: 390, cy: 160, r: 32 - 4 }
                        },
                        sampler: { cx: 325, cy: 177, r: 16 - 4 }
                    },
                    
                    postGenerationHook: function(piece) {
                        const slabBounds = {
                            x: piece.bounds.x + 130,
                            y: piece.bounds.y + (piece.bounds.height - 20) - 8,
                            width: 70,
                            height: 15
                        };

                        // --- START OF MODIFICATION ---
                        const hookData = {
                            stationGeometry: {
                                cauldrons: {
                                    left:  { cx: piece.bounds.x + this.stationGeometry.cauldrons.left.cx,  cy: piece.bounds.y + this.stationGeometry.cauldrons.left.cy,  r: this.stationGeometry.cauldrons.left.r },
                                    right: { cx: piece.bounds.x + this.stationGeometry.cauldrons.right.cx, cy: piece.bounds.y + this.stationGeometry.cauldrons.right.cy, r: this.stationGeometry.cauldrons.right.r }
                                },
                                sampler: { cx: piece.bounds.x + this.stationGeometry.sampler.cx, cy: piece.bounds.y + this.stationGeometry.sampler.cy, r: this.stationGeometry.sampler.r }
                            }
                        };
                        
                        // Pass this calculated, world-space data to the trigger
                        createTrigger({
                            name: 'alchemy_slab',
                            x: slabBounds.x,
                            y: slabBounds.y,
                            width: slabBounds.width,
                            height: slabBounds.height,
                            onEnter: function(t) {
                                const eId = createMagicEmitter({ spawnType: 'line', x1: t.x, y1: t.y, x2: t.x + t.width, y2: t.y, mainColor: [255, 230, 100], spawnRate: 0.5 });
                                t.associatedData.emitterId = eId;
                            },
                            onLeave: function(t) {
                                if (t.associatedData.emitterId != null) {
                                    removeMagicEmitter(t.associatedData.emitterId);
                                    t.associatedData.emitterId = null;
                                }
                            },
                            
                            onInteract: function(trigger) { 
                                isAlchemyUIVisible = true;
                                player.activeStationGeometry = trigger.associatedData.stationGeometry;
                            },
                            
                            associatedData: hookData // Use the calculated data here
                        });

                        return hookData; // Return the data so other systems can use it
                    }
                }
            ],
            
            getSetPiecesForSector: function(sx, sy) {
                const overlapping = [];
                const sectorBounds = {
                    x1: sx * SECTOR_SIZE, y1: sy * SECTOR_SIZE,
                    x2: (sx + 1) * SECTOR_SIZE, y2: (sy + 1) * SECTOR_SIZE
                };

                for (const piece of this.setPieces) {
                    const pieceBounds = piece.getBounds();
                    const pieceBoundsRect = { x1: pieceBounds.x, y1: pieceBounds.y, x2: pieceBounds.x + pieceBounds.width, y2: pieceBounds.y + pieceBounds.height };

                    if (sectorBounds.x1 < pieceBoundsRect.x2 && sectorBounds.x2 > pieceBoundsRect.x1 &&
                        sectorBounds.y1 < pieceBoundsRect.y2 && sectorBounds.y2 > pieceBoundsRect.y1) {
                        
                        // This part is correct: send only cloneable data to the worker.
                        overlapping.push({
                            name: piece.name,
                            bounds: pieceBounds
                        });
                    }
                }
                return overlapping;
            }
        };

        /**
         * Compresses a Uint8Array using Run-Length Encoding.
         * Example: [1, 1, 1, 2, 2, 3] becomes [3, 1, 2, 2, 1, 3]
         * @param {Uint8Array} data The raw chunk data.
         * @returns {number[]} The compressed data as a simple array.
         */
        function compressRLE(data) {
            if (!data || data.length === 0) return [];
            const compressed = [];
            let count = 1;
            for (let i = 1; i <= data.length; i++) {
                if (i < data.length && data[i] === data[i - 1]) {
                    count++;
                } else {
                    compressed.push(count, data[i - 1]);
                    count = 1;
                }
            }
            return compressed;
        }

        /**
         * Decompresses an RLE array back into a Uint8Array.
         * @param {number[]} rleData The compressed data.
         * @returns {Uint8Array} The decompressed chunk data.
         */
        function decompressRLE(rleData) {
            const decompressed = new Uint8Array(CHUNK_SIZE_SQ);
            let index = 0;
            for (let i = 0; i < rleData.length; i += 2) {
                const count = rleData[i];
                const value = rleData[i + 1];
                for (let j = 0; j < count; j++) {
                    decompressed[index++] = value;
                }
            }
            return decompressed;
        }

        /**
         * Saves all chunks within a given sector to Local Storage after compressing them.
         * @param {number} sx The sector's X coordinate.
         * @param {number} sy The sector's Y coordinate.
         */
        function saveSectorToStorage(sx, sy) {
            const storageKey = `fsp-sector-${sx},${sy}`;
            const sectorData = {
                terrain: [],
                light: []
            };

            const startCX = sx * (SECTOR_SIZE / CHUNK_SIZE);
            const startCY = sy * (SECTOR_SIZE / CHUNK_SIZE);
            const endCX = startCX + (SECTOR_SIZE / CHUNK_SIZE);
            const endCY = startCY + (SECTOR_SIZE / CHUNK_SIZE);

            for (let cy = startCY; cy < endCY; cy++) {
                for (let cx = startCX; cx < endCX; cx++) {
                    const key = coordToKey(cx, cy);
                    
                    const terrainChunk = chunkMap.get(key);
                    if (terrainChunk) {
                        sectorData.terrain.push({ cx, cy, data: compressRLE(terrainChunk.data) });
                        chunkMap.delete(key); // Free up memory
                    }

                    const lightChunk = lightChunkMap.get(key);
                    if (lightChunk) {
                        sectorData.light.push({ cx, cy, data: compressRLE(lightChunk.data) });
                        lightChunkMap.delete(key); // Free up memory
                    }
                }
            }

            try {
                localStorage.setItem(storageKey, JSON.stringify(sectorData));
                console.log(`Sector [${sx}, ${sy}] saved to storage.`);
            } catch (e) {
                console.error(`Failed to save sector [${sx}, ${sy}]. Local Storage may be full.`, e);
            }
        }

        /**
         * Attempts to load a sector from Local Storage into memory.
         * @param {number} sx The sector's X coordinate.
         * @param {number} sy The sector's Y coordinate.
         * @returns {boolean} True if the sector was loaded successfully, false otherwise.
         */
        function loadSectorFromStorage(sx, sy) {
            const storageKey = `fsp-sector-${sx},${sy}`;
            const savedData = localStorage.getItem(storageKey);

            if (!savedData) {
                return false; // Not in storage, needs generation.
            }

            try {
                const sectorData = JSON.parse(savedData);

                // Load terrain
                for (const chunkData of sectorData.terrain) {
                    const key = coordToKey(chunkData.cx, chunkData.cy);
                    const chunk = getChunk(chunkMap, key);
                    chunk.data = decompressRLE(chunkData.data);
                    chunk.cx = chunkData.cx;
                    chunk.cy = chunkData.cy;
                }

                // Load lighting
                for (const chunkData of sectorData.light) {
                    const key = coordToKey(chunkData.cx, chunkData.cy);
                    const chunk = getChunk(lightChunkMap, key);
                    chunk.data = decompressRLE(chunkData.data);
                    chunk.cx = chunkData.cx;
                    chunk.cy = chunkData.cy;
                }
                
                // Important: Remove it from storage after loading to prevent stale data if it's saved again later
                localStorage.removeItem(storageKey); 
                console.log(`Sector [${sx}, ${sy}] loaded from storage.`);
                return true;
            } catch (e) {
                console.error(`Failed to load or parse sector [${sx}, ${sy}] from storage.`, e);
                return false;
            }
        }

        /**
         * Checks if the number of ready sectors exceeds the limit and unloads the oldest one.
         * This now uses the sectorGrid Map as the single source of truth.
         */
        function manageSectorMemory() {
            // Use sectorGrid.size, which counts only 'ready' and 'queued' sectors.
            if (sectorGrid.size <= MAX_READY_SECTORS) {
                return;
            }

            const protectedKeys = new Set();
            for (let sy = lastPlayerSectorY - 1; sy <= lastPlayerSectorY + 1; sy++) {
                for (let sx = lastPlayerSectorX - 1; sx <= lastPlayerSectorX + 1; sx++) {
                    protectedKeys.add(coordToKey(sx, sy));
                }
            }

            // Iterate directly over the map. The first entries are the oldest.
            for (const [key, sector] of sectorGrid.entries()) {
                // Find the first sector that is 'ready' and NOT protected.
                if (sector.state === 'ready' && !protectedKeys.has(key)) {
                    saveSectorToStorage(sector.sx, sector.sy);
                    sectorGrid.delete(key); // Unload it by removing it from the map.
                    
                    // We only unload one sector per frame to avoid hitches.
                    break; 
                }
            }
        }

        /**
         * Generates a single, tileable cave background image.
         */
        function generateCaveBackgroundTile(width, height) {
            const img = ctx.createImageData(width, height);
            const d = img.data;
            const layerHeight = WORLD_LAYER_HEIGHT;
            const transitionSize = 40;

            PerlinNoise.seed(WORLD_SEED);

            const hash = (x,y,s=0) => { let h=x*374761393+y*668265263+s*1442695041; h=(h^(h>>13))*1274126177; return (h^(h>>16))&255; };
            const lerp = (a,b,t) => a+(b-a)*t;
            const lerpColor = (c1,c2,t) => [lerp(c1[0],c2[0],t),lerp(c1[1],c2[1],t),lerp(c1[2],c2[2],t)];

            const getSandCaveColor = (x,y)=>{ const px=x>>1,py=y>>1,n=(PerlinNoise.noise(px*0.04,py*0.1)+1)/2; if(n>0.6)return[60,45,30];if(n>0.4)return[50,38,25];return[40,30,20]; };
            const getCoalMineColor = (x,y)=>{ const px=x>>1,py=y>>1,r=(PerlinNoise.noise(px*0.1,py*0.1)+1)/2,s=PerlinNoise.noise(px*0.02,py*0.15); if(s*s>0.3)return[5,3,3];if(r>0.6)return[28,25,25];if(r>0.45)return[20,18,18];return[12,10,10]; };
            const getVolcanicColor = (x,y)=>{ const px=x>>1,py=y>>1,c=Math.abs(PerlinNoise.noise(px*0.06,py*0.06)*2.5); if(c>0.98)return[255,170,0];if(c>0.95)return[255,90,0];const r=hash(px>>1,py>>1)/255;if(r>0.5)return[25,10,10];return[15,5,5]; };
            const getLabyrinthColor = (x,y)=>{ const px=x>>2,py=y>>2;if(x%4<1||y%4<1)return[20,22,25];return hash(px,py)>128?[55,60,65]:[45,50,55]; };
            const getMagicDungeonColor = (x,y)=>{ const px=x>>1,py=y>>1,e=(PerlinNoise.noise(px*0.03,py*0.03)+1)/2,c=Math.abs(PerlinNoise.noise(px*0.16,py*0.16)); if(c*c*c>0.2)return[180,150,255];if(c*c>0.25)return[100,80,140];if(hash(x,y)>254)return[200,200,255];if(e>0.55)return[40,15,60];return[20,5,40]; };
            
            const layerFunctions = [getSandCaveColor, getCoalMineColor, getVolcanicColor, getLabyrinthColor, getMagicDungeonColor];

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const layerIndex = Math.min(layerFunctions.length - 1, Math.floor(Math.max(0, y) / layerHeight));
                    const yInLayer = y % layerHeight;
                    let color;
                    if (layerIndex > 0 && yInLayer < transitionSize) {
                        const t = yInLayer / transitionSize;
                        const color1 = layerFunctions[layerIndex - 1](x, y);
                        const color2 = layerFunctions[layerIndex](x, y);
                        color = lerpColor(color1, color2, t * t);
                    } else {
                        color = layerFunctions[layerIndex](x, y);
                    }
                    const i = (y * width + x) * 4;
                    d[i]=color[0]; d[i+1]=color[1]; d[i+2]=color[2]; d[i+3]=255;
                }
            }
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width; tempCanvas.height = height;
            tempCanvas.getContext('2d').putImageData(img, 0, 0);
            return tempCanvas;
        }

        // --- PLAYER AND CAMERA ---
        const player = {
            x: 391, y: STATION_FLOOR_Y - 12, vx: 0, vy: 0,
            width: 8, height: 16, speed: 1, onGround: false,
            body: null,
            isSpawning: true, // ADD: Start in spawning state
            spawnAnimationTimer: 0, // ADD: Timer for animation speed
            spawnAnimationProgress: 0, // ADD: Tracks how many rows of the sprite have appeared
            canInteract: false,
            currentInteractable: null,
            activeStationGeometry: null,
            maxHoverEnergy: 100,
            hoverEnergy: 100,
            hoverForce: 0.25,
            hoverDrainRate: 0.5,
            hoverRechargeRate: 1,
            maxHp: 100,
            hp: 100,
            toolPocket: [],
            structurePocket: [],
            unlockedReactions: ['clear_cauldrons'],
            maxToolSlots: 1,
            maxStructureSlots: 1
        };
        const camera = { x: player.x - viewWidth / 2, y: player.y - viewHeight / 2 };
        const floatingArrow = {
            x: 0,
            y: 0,
            isVisible: false
        };
		const mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };
        
        // --- INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', (e) => {
            if (UIMessageManager.isVisible) {
                UIMessageManager.isVisible = false;
                UIMessageManager.timer = 0;
                return; // Consume the key press and do nothing else.
            }

            if (DialogueManager.isVisible) {
                if (e.code.startsWith('Digit')) {
                    const index = parseInt(e.code.replace('Digit', ''), 10) - 1;
                    DialogueManager.selectOption(index);
                }
                if (e.code === 'Escape') {
                    DialogueManager.closeDialogue();
                }
                return; // Prevent any other input when dialogue is open
            }

            if (isAlchemyUIVisible) {
                
                if (e.code === 'Escape') {
                    isAlchemyUIVisible = false;
                    player.activeStationGeometry = null;  
                } 

                if (e.code.startsWith('Digit')) {
                    const index = parseInt(e.code.replace('Digit', ''), 10) - 1;
                    const reactionKeys = player.unlockedReactions;
                    if (index >= 0 && index < reactionKeys.length) {
                        const reactionKey = reactionKeys[index];
                        
                        if (player.activeStationGeometry) {
                            ALCHEMY_REACTIONS[reactionKey].execute(player.activeStationGeometry);
                        }

                        isAlchemyUIVisible = false;
                        player.activeStationGeometry = null; 
                    }
                }
                return;
            }

            if (TradeManager.isVisible) {
                if (e.code === 'Escape') {
                    TradeManager.isVisible = false;
                    TradeManager.currentPage = 0;
                    return;
                }
                if (e.code === 'Digit0') {
                    const totalPages = Math.ceil(TRADE_INVENTORY.length / TradeManager.itemsPerPage);
                    TradeManager.currentPage = (TradeManager.currentPage + 1) % totalPages;
                    return;
                }
                if (e.code.startsWith('Digit')) {
                    const index = parseInt(e.code.replace('Digit', ''), 10) - 1;
                    if (index >= 0 && index < TradeManager.itemsPerPage) {
                        const itemIndex = (TradeManager.currentPage * TradeManager.itemsPerPage) + index;
                        if (itemIndex < TRADE_INVENTORY.length) {
                            purchaseItem(TRADE_INVENTORY[itemIndex]);
                        }
                    }
                }
                return;
            }

            if (e.code === 'KeyL') {
                debugMode = !debugMode;
                return;
            }

            if (e.code === 'KeyP') {
                saveMapToImage(); // This function needs to be re-thought for an infinite world
                return;
            }

            keys[e.code] = true;
            
            if (e.code === 'KeyQ') {
                const cycle = ['pouch', 'flask', 'tool', 'structure'];
                const currentIndex = cycle.indexOf(activeContainer);
                const nextIndex = (currentIndex + 1) % cycle.length;
                activeContainer = cycle[nextIndex];
            }

            if (e.code === 'KeyE' && player.canInteract && player.currentInteractable) {
                const interactable = player.currentInteractable;
                
                if (interactable.type === 'trigger') {
                    const trigger = interactable.target;
                    trigger.onInteract(trigger); // Call the trigger's function
                } else if (interactable.type === 'object') {
                    pickupObject(interactable.target); // Call the pickup function
                }
            }
        });

        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // --- START OF NEW CODE: ARROW FUNCTIONS ---
        function spawnFloatingArrow(worldX, worldY) {
            floatingArrow.x = worldX;
            floatingArrow.y = worldY;
            floatingArrow.isVisible = true;
        }

        function despawnFloatingArrow() {
            floatingArrow.isVisible = false;
        }

        function renderFloatingArrow() {
            if (!floatingArrow.isVisible) return;

            const screenX = Math.round(floatingArrow.x - camera.x);
            const screenY = Math.round(floatingArrow.y - camera.y);

            // Animate the vertical "bobbing" motion
            const animatedY = screenY + Math.sin(frameCount * 0.12) * 4;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.moveTo(screenX - 5, animatedY);
            ctx.lineTo(screenX + 5, animatedY);
            ctx.lineTo(screenX, animatedY + 8);
            ctx.closePath();
            ctx.fill();
        }
        // --- END OF NEW CODE ---

        const PLAYER_SPAWN_ANIM_SPEED = 8; // Ticks per row. Higher is slower.

        function updateSpawnAnimation() {
            if (!player.isSpawning) return;

            player.spawnAnimationTimer++;
            if (player.spawnAnimationTimer >= PLAYER_SPAWN_ANIM_SPEED) {
                player.spawnAnimationTimer = 0;
                player.spawnAnimationProgress++;
            }

            // Check if the animation is finished (sprite is 16px high)
            if (player.spawnAnimationProgress > 16) {
                player.isSpawning = false;
                createPlayerBody(); // Create the physics body now
                // Optional: create a small particle burst on completion
                spawnMagicParticles(30, player.x + player.width / 2, player.y + player.height / 2, [200, 180, 255]);

                const alchemist = npcs.find(npc => npc.name === 'Ylialkemisti');
                if (alchemist) {
                    spawnFloatingArrow(alchemist.x + alchemist.width / 2 - 2, alchemist.y - 24);
                }
            }
        }

        function renderSpawnAnimation() {
            if (!player.isSpawning) return;

            const baseScreenX = Math.round(player.x - camera.x);
            const baseScreenY = Math.round(player.y - camera.y);
            const cloak = [0x4a, 0x2d, 0x5e];
            const face = [0x21, 0x1e, 0x20];
            const sprite = PLAYER_SPRITE[0]; // Use a static sprite frame for spawning

            const materializedRows = player.spawnAnimationProgress;

            // Iterate from the bottom of the sprite upwards
            for (let y = 15; y >= 0; y--) {
                const rowProgress = 16 - y;
                if (rowProgress > materializedRows) continue; // Don't draw rows that haven't appeared yet

                const row = sprite[y];
                for (let x = 0; x < 8; x++) {
                    const ch = row[x];
                    if (ch === '.') continue;

                    const sx = baseScreenX + x - 4;
                    const sy = baseScreenY + y - 8;
                    let r, g, b;

                    // If this is the active row being drawn, make it glow
                    if (rowProgress === materializedRows) {
                        const flicker = Math.random() * 55;
                        r = 200 + flicker;
                        g = 180 + flicker;
                        b = 255;
                    } else { // Otherwise, draw the final sprite color
                        [r, g, b] = (ch === 'F') ? face : cloak;
                    }
                    
                    ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
                    ctx.fillRect(sx, sy, 1, 1);
                }
            }
        }

        /**
         * getPlayerSubmersionRatio - unchanged.
         */
        function getPlayerSubmersionRatio() {
            if (!player.body) return 0;
            const samplePoints = [0.1, 0.3, 0.5, 0.7, 0.9];
            let submergedPointCount = 0;
            const totalPoints = samplePoints.length;
            for (const heightPercent of samplePoints) {
                const localX = player.width / 2, localY = player.height * heightPercent;
                const worldPos = player.body.getWorldPoint(pl.Vec2((localX - player.width / 2)/B2_SCALE, (localY - player.height / 2)/B2_SCALE));
                const gridMaterial = getGrid(Math.floor(worldPos.x * B2_SCALE), Math.floor(worldPos.y * B2_SCALE));
                if (isLiquid(gridMaterial)) submergedPointCount++;
            }
            return submergedPointCount / totalPoints;
        }

        /**
         * Scans all generated sectors, renders the entire known world to a new canvas,
         * and triggers a download of the result as a PNG image. Includes size validation.
         */
        async function saveMapToImage() {
            const loadingOverlay = document.getElementById('loading-overlay');
            const statusElement = document.getElementById('loading-status');
            const MAX_SAVE_DIMENSION = 16384; // A safe upper limit for most browsers (16k pixels)

            statusElement.innerText = 'Analyzing world bounds...';
            loadingOverlay.style.transition = 'opacity 0.2s';
            loadingOverlay.style.opacity = '1';
            loadingOverlay.style.display = 'flex';
            await new Promise(resolve => setTimeout(resolve, 50));

            // --- Step 1: Determine the bounds of the generated world ---
            let minCX = Infinity, minCY = Infinity, maxCX = -Infinity, maxCY = -Infinity;
            let hasSectors = false;
            for (const chunk of chunkMap.values()) {
                if(chunk.cx === undefined) continue; // Skip incomplete chunks
                minCX = Math.min(minCX, chunk.cx);
                minCY = Math.min(minCY, chunk.cy);
                maxCX = Math.max(maxCX, chunk.cx);
                maxCY = Math.max(maxCY, chunk.cy);
                hasSectors = true;
            }

            if (!hasSectors) {
                statusElement.innerText = 'No world generated to save!';
                await new Promise(resolve => setTimeout(resolve, 1500));
                loadingOverlay.style.opacity = '0';
                await new Promise(resolve => setTimeout(() => { loadingOverlay.style.display = 'none'; resolve(); }, 200));
                return;
            }

            const startX = minCX * CHUNK_SIZE;
            const startY = minCY * CHUNK_SIZE;
            const endX = (maxCX + 1) * CHUNK_SIZE;
            const endY = (maxCY + 1) * CHUNK_SIZE;

            const totalWidth = endX - startX;
            const totalHeight = endY - startY;

            // --- START OF THE FIX: VALIDATION ---
            if (totalWidth > MAX_SAVE_DIMENSION || totalHeight > MAX_SAVE_DIMENSION || totalWidth <= 0 || totalHeight <= 0) {
                statusElement.innerText = `Error: Map is too large to save (${totalWidth}x${totalHeight}). Max is ~${MAX_SAVE_DIMENSION}px.`;
                console.error(`Save failed: Requested map size ${totalWidth}x${totalHeight} exceeds the limit of ${MAX_SAVE_DIMENSION}.`);
                await new Promise(resolve => setTimeout(resolve, 4000)); // Show error for 4 seconds
                loadingOverlay.style.opacity = '0';
                await new Promise(resolve => setTimeout(() => { loadingOverlay.style.display = 'none'; resolve(); }, 200));
                return; // Abort the save operation
            }
            // --- END OF THE FIX ---
            
            statusElement.innerText = `Creating ${totalWidth}x${totalHeight} map...`;
            await new Promise(resolve => setTimeout(resolve, 50));

            // --- Step 2: Create the large canvas ---
            const saveCanvas = document.createElement('canvas');
            saveCanvas.width = totalWidth;
            saveCanvas.height = totalHeight;
            const saveCtx = saveCanvas.getContext('2d');

            // ... (The rest of the drawing logic is correct and remains the same) ...
            
            // --- Step 3: Draw world data ---
            const bgData = backgroundTileData.data;
            const bgWidth = backgroundTileData.width;
            const bgHeight = backgroundTileData.height;
            for (let y = 0; y < totalHeight; y++) {
                if (y % 256 === 0) {
                     statusElement.innerText = `Rendering row ${y} / ${totalHeight}...`;
                     await new Promise(resolve => setTimeout(resolve, 0));
                }
                for (let x = 0; x < totalWidth; x++) {
                    const worldX = startX + x;
                    const worldY = startY + y;
                    const bgX = (worldX % bgWidth + bgWidth) % bgWidth;
                    const bgY = (worldY % bgHeight + bgHeight) % bgHeight;
                    const bgI = (bgY * bgWidth + bgX) * 4;
                    saveCtx.fillStyle = `rgb(${bgData[bgI]}, ${bgData[bgI+1]}, ${bgData[bgI+2]})`;
                    saveCtx.fillRect(x, y, 1, 1);
                    const type = getGrid(worldX, worldY);
                    if (type !== MAT.EMPTY) {
                        const color = COLORS[type];
                        if (color) {
                            saveCtx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                            saveCtx.fillRect(x, y, 1, 1);
                        }
                    }
                }
            }

            statusElement.innerText = 'Rendering dynamic objects...';
            await new Promise(resolve => setTimeout(resolve, 50));

            // --- Step 4: Draw all rigid bodies ---
            for (const body of rigidBodies) {
                if (!body.body || body.isDestroyed) continue;
                const pos = body.body.getPosition();
                const angle = body.body.getAngle();
                const canvasX = pos.x * B2_SCALE - startX;
                const canvasY = pos.y * B2_SCALE - startY;
                saveCtx.save();
                saveCtx.translate(canvasX, canvasY);
                saveCtx.rotate(angle);
                const offsetX = -body.width / 2;
                const offsetY = -body.height / 2;
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const type = body.pixels[y * body.width + x];
                        if (type !== MAT.EMPTY) {
                            const color = COLORS[type];
                            if (color) {
                                saveCtx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                                saveCtx.fillRect(offsetX + x, offsetY + y, 1, 1);
                            }
                        }
                    }
                }
                saveCtx.restore();
            }

            // --- Step 5: Trigger download ---
            statusElement.innerText = 'Compressing image... (this may take a moment)';
            await new Promise(resolve => setTimeout(resolve, 50)); // Allow UI to update before blocking call

            try {
                const link = document.createElement('a');
                link.download = `falling-sand-map-${Date.now()}.png`;
                link.href = saveCanvas.toDataURL('image/png'); // This is the slow operation
                link.click();
            } catch (e) {
                statusElement.innerText = `Error: Could not generate image data. The map may be too large.`;
                console.error("Error during toDataURL:", e);
                await new Promise(resolve => setTimeout(resolve, 4000));
                loadingOverlay.style.opacity = '0';
                await new Promise(resolve => setTimeout(() => { loadingOverlay.style.display = 'none'; resolve(); }, 200));
                return;
            }

            // --- Step 6: Hide overlay ---
            statusElement.innerText = 'Done!';
            await new Promise(resolve => setTimeout(resolve, 500));
            loadingOverlay.style.opacity = '0';
            await new Promise(resolve => setTimeout(() => {
                loadingOverlay.style.display = 'none';
                resolve();
            }, 200));
        }
        
        /**
         * Creates the player's physics body. Unchanged.
         */
        function createPlayerBody() {
            player.body = world.createBody({type:'dynamic', position:pl.Vec2(player.x/B2_SCALE,player.y/B2_SCALE), fixedRotation:true, linearDamping:PLAYER_DEFAULT_DAMPING});
            player.body.setUserData(player);
            const halfWidth=(player.width/2-1)/B2_SCALE, halfHeight=(player.height/2-2)/B2_SCALE;
            player.body.createFixture(pl.Box(halfWidth,halfHeight,pl.Vec2(0,-2/B2_SCALE),0),{density:1.0,friction:0.05});
            const footRadius=(player.width/2-1)/B2_SCALE;
            player.body.createFixture(pl.Circle(pl.Vec2(0,(player.height/2-2)/B2_SCALE),footRadius),{friction:0.05});
        }


        function setMaterial(name) {
            const map = {
                sand: MAT.SAND, water: MAT.WATER, oil: MAT.OIL, coal: MAT.COAL,
                soil: MAT.SOIL, wall: MAT.ROCK_WALL, wood: MAT.WOOD,
                fire: MAT.FIRE, gunpowder: MAT.GUNPOWDER, acid: MAT.ACID,
                glass: MAT.GLASS, 'glass-wall': MAT.GLASS_WALL, empty: MAT.EMPTY,
                adamantium: MAT.ADAMANTIUM, copper: MAT.COPPER, silver: MAT.SILVER,
                gold: MAT.GOLD, platinum: MAT.PLATINUM,
                'rune-wall': MAT.RUNE_WALL,
                // --- START OF NEW MATERIALS (and removed gas) ---
                ground: MAT.GROUND, iron: MAT.IRON, obsidian: MAT.OBSIDIAN,
                lava: MAT.LAVA, steam: MAT.STEAM, smoke: MAT.SMOKE, methane: MAT.METHANE
                // --- END OF NEW MATERIALS ---
            };
            if (map[name] === undefined) { console.warn('Unknown material:', name); return; }
            currentMaterial = map[name];
            document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
            // --- FIX for new button class names ---
            const btnClass = name.replace('_', '-');
            const btn = document.querySelector(`.btn-${btnClass}`);
            if (btn) btn.classList.add('active');
        }

        function isFlammable(type) {
            return (type === MAT.WOOD || type === MAT.GUNPOWDER || type === MAT.OIL || type === MAT.COAL || type === MAT.METHANE);
        }

        const LIQUIDS = new Set([MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.ACID, MAT.LAVA]);
        const GASES = new Set([MAT.STEAM, MAT.SMOKE, MAT.METHANE, MAT.METHANE_BURNING]);
        const FIRE_PASSABLE = new Set([
            MAT.EMPTY, 
            MAT.STEAM, 
            MAT.METHANE, // Methane is fuel, so fire should spread into it
            MAT.METHANE_BURNING // It's already fire
        ]);

        function tryIgniteAt(x, y, probability = 1.0) {
            const type = getGrid(x, y);
            if (!isFlammable(type) || Math.random() > probability) return;

            switch (type) {
                case MAT.GUNPOWDER:
                    setGrid(x, y, MAT.GUNPOWDER_IGNITED);
                    setAuxData(etcChunkMap, x, y, 3 + Math.floor(Math.random() * 5));
                    break;
                case MAT.OIL: setGrid(x, y, MAT.OIL_BURNING); break;
                case MAT.COAL: setGrid(x, y, MAT.COAL_BURNING); break;
                case MAT.WOOD: setGrid(x, y, MAT.FIRE); break;
                // --- ADD METHANE ---
                case MAT.METHANE:
                    setGrid(x, y, MAT.METHANE_BURNING); // Change to burning state instead of exploding
                    setAuxData(etcChunkMap, x, y, 10 + Math.floor(Math.random() * 5));
                    break;
            }
        }


        const getMousePos = (evt) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = evt.clientX - rect.left;
            mouse.y = evt.clientY - rect.top;
        };

        function draw(x, y) {
            const brushSize = 10;
            const r = Math.floor(brushSize / 2);
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (dx*dx + dy*dy <= r*r) {
                        const px = x + dx, py = y + dy;
                        setGrid(px, py, currentMaterial);
                        activateChunkAt(px, py);
                    }
                }
            }
        }
        canvas.addEventListener('mousemove', getMousePos);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) isPouring = true;
            else if (e.button === 1) { isDrawing = true; draw(mouse.worldX, mouse.worldY); e.preventDefault(); }
            else if (e.button === 2) {
                // --- START: New Right-Click Logic ---
                const distSq = (player.x - mouse.worldX)**2 + (player.y - mouse.worldY)**2;
                if (distSq > PLAYER_INTERACTION_RADIUS * PLAYER_INTERACTION_RADIUS) {
                    return; // Too far away, do nothing
                }

                switch(activeContainer) {
                    case 'pouch':
                    case 'flask':
                        isStoring = true;
                        storeMaterial(mouse.worldX, mouse.worldY);
                        break;
                    case 'tool':
                        if (player.toolPocket.length > 0 && toolUseCooldown <= 0) {
                             const toolName = player.toolPocket[0]; // Assuming one tool for now
                             const toolDef = Object.values(OBJECT_DEFINITIONS).find(d => d.name === toolName);
                             if (toolDef && toolDef.onUse) {
                                 toolDef.onUse(player, mouse);
                                 toolUseCooldown = 30; // 0.5 second cooldown
                             }
                        }
                        break;
                    case 'structure':
                         if (player.structurePocket.length > 0) {
                             const bodyToPlace = player.structurePocket.shift(); // Get the stored RigidBody
                             
                             // Re-create its physics body at the mouse cursor location
                             bodyToPlace.reintroduceToWorld(mouse.worldX, mouse.worldY);

                             // Add it back to the main simulation array
                             rigidBodies.push(bodyToPlace);
                         }
                        break;
                }
                // --- END: New Right-Click Logic ---
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) isPouring = false;
            if (e.button === 1) isDrawing = false;
            if (e.button === 2) isStoring = false;
        });

        canvas.addEventListener('mousemove', (e) => { if (isDrawing) draw(mouse.worldX, mouse.worldY); });
        
        // This helper is only used for the small inventory grids now.
        const getIdx = (x, y, w, h) => {
            x = Math.floor(x); y = Math.floor(y);
            if (x < 0 || x >= w || y < 0 || y >= h) return -1;
            return y * w + x;
        };

        const isSolidForPlayer = (type) => [
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, MAT.LABYRINTH_WALL, MAT.MAGIC_WALL,
            MAT.SOIL, MAT.WOOD, MAT.SAND, 
            MAT.GUNPOWDER, MAT.COAL, MAT.COAL_BURNING, MAT.GLASS, 
            MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.COPPER, MAT.SILVER, 
            MAT.GOLD, MAT.PLATINUM, MAT.RUNE_WALL,
            MAT.GROUND, MAT.IRON, MAT.RUSTED_IRON, MAT.OBSIDIAN
        ].includes(type);
        
        function updateRigidBodyGrid() {
            // 1. Clear all chunks that had stubs in the PREVIOUS frame.
            for (const key of activeStubChunks) {
                const chunk = etcChunkMap.get(key);
                if (chunk) {
                    chunk.data.fill(0); // Clear the old stub data
                }
            }
            activeStubChunks.clear(); // Reset the set for the CURRENT frame.

            // 2. Populate the grid with new stub locations and track the chunks used.
            const buffer = 1;
            for (const body of rigidBodies) {
                if (body.isDestroyed || !body.body) continue;

                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        if (body.pixels[y * body.width + x] === MAT.EMPTY) continue;

                        // Get the world position of the rigid body's pixel
                        const localPos = pl.Vec2((x - body.width / 2 + 0.5) / B2_SCALE, (y - body.height / 2 + 0.5) / B2_SCALE);
                        const worldPos = body.body.getWorldPoint(localPos);
                        const worldX = Math.floor(worldPos.x * B2_SCALE);
                        const worldY = Math.floor(worldPos.y * B2_SCALE);

                        // Mark a small buffered area in the etcChunkMap
                        for (let dy = -buffer; dy <= buffer; dy++) {
                            for (let dx = -buffer; dx <= buffer; dx++) {
                                const wx = worldX + dx;
                                const wy = worldY + dy;
                                setAuxData(etcChunkMap, wx, wy, 1); // Mark as a rigid body stub

                                // 3. Add the key of the affected chunk to our tracker for the NEXT frame's clear operation.
                                const cx = Math.floor(wx / CHUNK_SIZE);
                                const cy = Math.floor(wy / CHUNK_SIZE);
                                activeStubChunks.add(coordToKey(cx, cy));
                            }
                        }
                    }
                }
            }
        }
        
        function updatePlayer() {
            if (player.isSpawning) return;
            if (DialogueManager.isVisible) {
                player.body.setLinearVelocity(pl.Vec2(0, 0));
                return;
            }

            if (isAlchemyUIVisible) {
                player.body.setLinearVelocity(pl.Vec2(0, 0));
                return;
            }

            if (TradeManager.isVisible) { 
                player.body.setLinearVelocity(pl.Vec2(0, 0)); 
                return; 
            }

            const submersionRatio = getPlayerSubmersionRatio();
            const isInLiquid = submersionRatio > 0;

            if (isInLiquid) {
                const upwardForce = BUOYANCY_FORCE * submersionRatio * player.body.getMass();
                player.body.applyForceToCenter(pl.Vec2(0, -upwardForce), true);
                player.body.setLinearDamping(PLAYER_SUBMERGED_DAMPING);
            } else {
                player.body.setLinearDamping(PLAYER_DEFAULT_DAMPING);
            }

            const currentVel = player.body.getLinearVelocity();
            let targetVelX = 0;

            if (keys['KeyA']) { targetVelX = -player.speed * 2.5; playerFacingRight = false; }
            else if (keys['KeyD']) { targetVelX = player.speed * 2.5; playerFacingRight = true; }

            player.onGround = Math.abs(currentVel.y) < 0.1;
            let newVelY = currentVel.y;

            if (keys['KeyW'] && player.hoverEnergy > 0) {
                const jumpForce = isInLiquid ? MAX_HOVER_SPEED * 1.5 : MAX_HOVER_SPEED;
                newVelY = -jumpForce;
                player.hoverEnergy = Math.max(0, player.hoverEnergy - player.hoverDrainRate);
                if (!isInLiquid) spawnLevitationParticles(2);
            }

            if ((player.onGround || isInLiquid) && !keys['KeyW']) {
                player.hoverEnergy = Math.min(player.maxHoverEnergy, player.hoverEnergy + player.hoverRechargeRate);
            }

            player.body.setLinearVelocity(pl.Vec2(targetVelX, newVelY));
        }
        
        function syncPlayerWithBody() {
            if (!player.body) return;
            const pos = player.body.getPosition();
            player.x = (pos.x * B2_SCALE) - (player.width / 2);
            player.y = (pos.y * B2_SCALE) - (player.height / 2);
        }

        function storeMaterial(worldX, worldY) {
            const storeRadius = 1;
            for (let dy = -storeRadius; dy <= storeRadius; dy++) {
                for (let dx = -storeRadius; dx <= storeRadius; dx++) {
                    const wx = worldX + dx;
                    const wy = worldY + dy;
                    const type = getGrid(wx, wy);

                    let targetGrid, targetW, targetH;
                    if (STORABLE_SOLIDS.has(type)) {
                        targetGrid = pouchGrid; targetW = pouchWidth; targetH = pouchHeight;
                    } else if (STORABLE_LIQUIDS.has(type)) {
                        targetGrid = flaskGrid; targetW = flaskWidth; targetH = flaskHeight;
                    } else continue;

                    let spotFound = false;
                    for (let y=0;y<targetH;y++) {
                        const xOffset = Math.floor(Math.random() * targetW);
                        for (let i=0;i<targetW;i++) {
                            const x = (i+xOffset)%targetW;
                            const containerIdx = getIdx(x,y,targetW,targetH);
                            if (containerIdx !== -1 && targetGrid[containerIdx] === MAT.EMPTY) {
                                targetGrid[containerIdx] = type;
                                setGrid(wx, wy, MAT.EMPTY);
                                spotFound = true; break;
                            }
                        }
                        if (spotFound) break;
                    }
                }
            }
        }
        
        function pourFromContainer() {
            const [containerGrid, cW, cH] = activeContainer === 'pouch' ? [pouchGrid, pouchWidth, pouchHeight] : [flaskGrid, flaskWidth, flaskHeight];
            const maxPourPerFrame = 3;
            let pouredCount = 0;

            for (let y = cH - 1; y >= 0; y--) {
                for (let i = 0; i < cW; i++) {
                    const x = Math.floor(cW/2)+(i%2===0?1:-1)*Math.floor(i/2);
                    const idx = getIdx(x,y,cW,cH);
                    const type = containerGrid[idx];

                    if (type !== MAT.EMPTY && !GASES.has(type)) {
                        containerGrid[idx] = MAT.EMPTY;
                        const baseSpawnX = player.x + (playerFacingRight?player.width:0), baseSpawnY = player.y+9;
                        const spawnOffsetX = (Math.random()-0.5)*2, spawnOffsetY = (Math.random()-0.5)*2;
                        const finalSpawnX = baseSpawnX+spawnOffsetX, finalSpawnY = baseSpawnY+spawnOffsetY;
                        const baseAngle = Math.atan2(mouse.worldY-finalSpawnY, mouse.worldX-finalSpawnX);
                        const finalAngle = baseAngle+(Math.random()-0.5)*0.05;
                        const finalVelocity = 4.0+(Math.random()-0.5)*0.5;

                        pouredParticles.push({
                            x:finalSpawnX, y:finalSpawnY,
                            vx:Math.cos(finalAngle)*finalVelocity, vy:Math.sin(finalAngle)*finalVelocity,
                            type:type
                        });
                        
                        pouredCount++;
                        if (pouredCount >= maxPourPerFrame) return;
                    }
                }
            }
        }

        function isRigidBodyAtPixel(worldX, worldY) {
            const pMin = pl.Vec2((worldX-0.5)/B2_SCALE, (worldY-0.5)/B2_SCALE);
            const pMax = pl.Vec2((worldX+0.5)/B2_SCALE, (worldY+0.5)/B2_SCALE);
            const aabb = new pl.AABB(pMin, pMax);
            let hit = false;
            world.queryAABB(aabb, (fixture) => {
                const ud = fixture.getBody().getUserData();
                if (ud && ud.pixels && ud.width && ud.height) { hit=true; return false; }
                return true;
            });
            return hit;
        }
        
        function updatePouredParticles() {
            pouredParticles = pouredParticles.filter(p => {
                p.vy += GRAVITY * 0.5;
                const nextX = p.x + p.vx, nextY = p.y + p.vy;
                const nextIX = Math.floor(nextX), nextIY = Math.floor(nextY);

                const gridBlocked = getGrid(nextIX, nextIY) !== MAT.EMPTY && !GASES.has(getGrid(nextIX, nextIY));
                const rigidBlocked = getAuxData(etcChunkMap, nextIX, nextIY) === 1; // 1 means rigid body
                const isObstructed = gridBlocked || rigidBlocked;
                const hasStopped = (p.vx*p.vx + p.vy*p.vy < 1.0);

                if (isObstructed || hasStopped) {
                    let placeX = Math.floor(p.x), placeY = Math.floor(p.y);
                    while (true) {
                        if (getGrid(placeX, placeY) === MAT.EMPTY || GASES.has(getGrid(placeX, placeY))) {
                            setGrid(placeX, placeY, p.type);
                            break;
                        }
                        placeY--;
                        if (placeY < camera.y - 100) break; // Safety break
                    }
                    return false;
                } else {
                    p.x = nextX; p.y = nextY;
                    return true;
                }
            });
        }
        
        // This group of functions can remain mostly as-is
		function shootFire(){/*...no changes needed...*/};
		function updateProjectiles(){/*...no changes needed...*/};
        const movedPouch = new Uint8Array(pouchWidth*pouchHeight);
        const movedFlask = new Uint8Array(flaskWidth*flaskHeight);
        
        

        function updateCamera() {
            const targetCamX = player.x - viewWidth/2;
            camera.x += (targetCamX - camera.x) * 0.1;
            const targetCamY = player.y - viewHeight/2;
            camera.y += (targetCamY - camera.y) * 0.1;
            // No more clamping
        }

        
        function isLiquid (type) {
            return LIQUIDS.has(type);
        }
        
        // --- START OF REPLACEMENT ---
        function runWorldSimulationWithChunks() {
            movedInFrame.clear(); // Clear the set once per frame
            const scanDir = (frameCount % 2 === 0);

            // Iterate over the active CHUNKS, not individual pixels
            for (const key of activeChunks) {
                const chunk = chunkMap.get(key);
                if (!chunk) continue;

                const startX = chunk.cx * CHUNK_SIZE;
                const startY = chunk.cy * CHUNK_SIZE;
                
                // By processing the entire chunk at once, we maximize cache hits
                // and reduce the overhead of chunk lookups dramatically.
                _lastChunk = chunk;
                _lastChunkCX = chunk.cx;
                _lastChunkCY = chunk.cy;

                // PASS 1: solids, gas, fire (bottom-up)
                for (let ly = CHUNK_SIZE - 1; ly >= 0; ly--) {
                    for (let lx = (scanDir ? 0 : CHUNK_SIZE - 1);
                        (scanDir ? lx < CHUNK_SIZE : lx >= 0);
                        lx += (scanDir ? 1 : -1)) {
                        
                        stepNonLiquid(startX + lx, startY + ly);
                    }
                }

                // PASS 2: liquids (bottom-up)
                for (let ly = CHUNK_SIZE - 1; ly >= 0; ly--) {
                    for (let lx = (scanDir ? 0 : CHUNK_SIZE - 1);
                        (scanDir ? lx < CHUNK_SIZE : lx >= 0);
                        lx += (scanDir ? 1 : -1)) {
                            
                        stepLiquid(startX + lx, startY + ly);
                    }
                }

                // --- ADD PASS 3 for GASES (top-down) ---
                for (let ly = 0; ly < CHUNK_SIZE; ly++) {
                    for (let lx = (scanDir ? 0 : CHUNK_SIZE - 1);
                        (scanDir ? lx < CHUNK_SIZE : lx >= 0);
                        lx += (scanDir ? 1 : -1)) {
                            
                        stepGas(startX + lx, startY + ly);
                    }
                }
            }
        }

        // This function is now ONLY for small inventory grids
        function runSimulationOnSmallGrid(moved, currentGrid, gridWidth, gridHeight, setter) {
             moved.fill(0);
             const localGetIdx = (x, y) => getIdx(x, y, gridWidth, gridHeight);
             const scanDir = (frameCount % 2 === 0);
             for(let y=gridHeight-1;y>=0;y--) for(let x=(scanDir?0:gridWidth-1);(scanDir?x<gridWidth:x>=0);x+=(scanDir?1:-1)) stepNonLiquid(x,y,moved,currentGrid,gridWidth,gridHeight,localGetIdx,setter);
             for(let y=gridHeight-1;y>=0;y--) for(let x=(scanDir?0:gridWidth-1);(scanDir?x<gridWidth:x>=0);x+=(scanDir?1:-1)) stepLiquid(x,y,moved,currentGrid,gridWidth,gridHeight,localGetIdx,setter);
        }

        function stepNonLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const type = isWorldSim ? getGrid(x, y) : grid[getIdx(x, y)];
            const idx = isWorldSim ? -1 : getIdx(x, y);

            if(isWorldSim && movedInFrame.has(coordToKey(x,y))) return;
            if(!isWorldSim && moved[idx]) return;

            if (WALL_TYPES.has(type) || [MAT.EMPTY, MAT.WOOD, MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.RUNE_WALL, MAT.RIGID_BODY_STUB, MAT.GROUND, MAT.IRON, MAT.RUSTED_IRON, MAT.OBSIDIAN].includes(type) || LIQUIDS.has(type) || GASES.has(type)) return;
            
            if (type === MAT.FIRE) updateFire(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if ([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM].includes(type)) updateSolid(x, y, type, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.COAL_BURNING) updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.GUNPOWDER_IGNITED) updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter);
        }

        function stepLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const type = isWorldSim ? getGrid(x, y) : grid[getIdx(x, y)];
            const idx = isWorldSim ? -1 : getIdx(x, y);

            if(isWorldSim && movedInFrame.has(coordToKey(x,y))) return;
            if(!isWorldSim && moved[idx]) return;

            if (!LIQUIDS.has(type)) return;
            
            updateLiquid(x, y, type, idx, moved, grid, w, h, getIdx, setter);
        }

        function stepGas(x, y, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const type = isWorldSim ? getGrid(x, y) : grid[getIdx(x, y)];
            const idx = isWorldSim ? -1 : getIdx(x, y);

            if(isWorldSim && movedInFrame.has(coordToKey(x,y))) return;
            if(!isWorldSim && moved[idx]) return;

            if (!GASES.has(type)) return;
            
            if (type === MAT.METHANE_BURNING) {
                updateBurningMethane(x, y, type, idx, moved, grid, w, h, getIdx, setter);
            } else {
                updateGas(x, y, type, idx, moved, grid, w, h, getIdx, setter);
            }
        }

        function updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            if (isWorldSim) {
                let timer = getAuxData(etcChunkMap, x, y);
                timer--;
                setAuxData(etcChunkMap, x, y, timer);
                for (let n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                    const nx = x + n.x, ny = y + n.y;
                    if (Math.random() < 0.35 && getGrid(nx, ny) === MAT.GUNPOWDER) {
                        setGrid(nx, ny, MAT.GUNPOWDER_IGNITED);
                        setAuxData(etcChunkMap, nx, ny, 8 + Math.floor(Math.random() * 6));
                    }
                }
                if (timer <= 0) {
                    setGrid(x, y, MAT.EMPTY);
                    triggerExplosion(x, y, 6);
                }
            } else {
                // No timer or explosion in small grids, just burns out
                if (Math.random() < 0.2) {
                    setter(idx, MAT.FIRE);
                    moved[idx] = 1;
                }
            }
        }

        /**
         * Creates an explosion that affects both the static grid and dynamic rigid bodies.
         * @param {number} centerX - The world X coordinate for the center of the blast.
         * @param {number} centerY - The world Y coordinate for the center of the blast.
         * @param {number} radius - The radius of the explosion in pixels.
         */
        function triggerExplosion(centerX, centerY, radius) {
            const rSquared = radius * radius;

            // --- Part 1: Affect the static grid ---
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const distSq = dx * dx + dy * dy;
                    if (distSq > rSquared) continue;

                    const ex = Math.floor(centerX + dx);
                    const ey = Math.floor(centerY + dy);
                    
                    // Skip this grid cell if a rigid body is there; we handle them in Part 2.
                    if (getAuxData(etcChunkMap, ex, ey) === 1) continue;

                    const type = getGrid(ex, ey);

                    // Check if the material is blast-resistant (e.g., Adamantium, special walls)
                    if (!WALL_TYPES.has(type) && type !== MAT.ADAMANTIUM && type !== MAT.RUNE_WALL) {
                        const rand = Math.random();
                        let newType = (rand < 0.3) ? MAT.FIRE : (rand < 0.7) ? MAT.SMOKE : MAT.EMPTY;
                        setGrid(ex, ey, newType);
                    } else if (radius > 15 && type !== MAT.ADAMANTIUM && type !== MAT.RUNE_WALL) { // Large explosions can chip away at walls
                        setGrid(ex, ey, MAT.SMOKE);
                    }
                    
                    // Any modification requires the chunk to be activated for the next simulation step.
                    ensureChunkIsActive(ex, ey);
                }
            }

            // --- Part 2: Affect rigid bodies ---
            const explosionCenterB2 = pl.Vec2(centerX / B2_SCALE, centerY / B2_SCALE);
            const blastPower = 100.0 * radius; // Base value for the physical force

            for (const body of rigidBodies) {
                if (!body.body || body.isDestroyed) continue;

                const bodyCenterB2 = body.body.getWorldCenter();
                const direction = pl.Vec2.sub(bodyCenterB2, explosionCenterB2);
                const distance = direction.normalize(); // This gets the distance and makes 'direction' a unit vector

                // Skip bodies outside the blast radius
                if (distance > radius / B2_SCALE) continue;

                // Apply a physics impulse (force) that weakens with distance
                const falloff = 1 - (distance * B2_SCALE / radius);
                const impulse = pl.Vec2.mul(direction, blastPower * falloff * body.body.getMass());
                body.body.applyLinearImpulse(impulse, bodyCenterB2, true);

                // Damage the pixels of the rigid body
                let pixelsChanged = 0;
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const lIdx = y * body.width + x;
                        if (body.pixels[lIdx] === MAT.EMPTY) continue;

                        // Convert local pixel coordinate to world coordinate
                        const lPos = pl.Vec2((x - body.width / 2 + 0.5) / B2_SCALE, (y - body.height / 2 + 0.5) / B2_SCALE);
                        const wPos = body.body.getWorldPoint(lPos);

                        const dx = (wPos.x * B2_SCALE) - centerX;
                        const dy = (wPos.y * B2_SCALE) - centerY;

                        if (dx * dx + dy * dy < rSquared) {
                            if (Math.random() < 0.8) { // 80% chance to destroy a pixel in the blast
                                body.pixels[lIdx] = MAT.EMPTY;
                                pixelsChanged++;
                            }
                        }
                    }
                }
                
                // If pixels were destroyed, flag the body to update its physical shape.
                if (pixelsChanged > 0) {
                    body.pendingStructuralDelta += pixelsChanged;
                    if(body.pendingStructuralDelta > 25) { // Trigger a shape rebuild if enough damage is done
                        body.needsShapeUpdate = true;
                    }
                }
            }
        }
        
        function updateFire(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };

            let nearbyFuel = false;
            for (let n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0},{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}]) {
                const nx = x + n.x, ny = y + n.y;
                const nType = _get(nx, ny);
                if (nType === MAT.SAND && Math.random() < 0.05) _set(nx, ny, MAT.GLASS);
                if (nType === MAT.GUNPOWDER && Math.random() < 0.5) {
                    if (isWorldSim) { setGrid(nx, ny, MAT.GUNPOWDER_IGNITED); setAuxData(etcChunkMap, nx, ny, 8 + Math.floor(Math.random() * 6)); } 
                    else { _set(nx, ny, MAT.FIRE); }
                    return;
                }
                if (nType === MAT.OIL) { _set(nx, ny, MAT.OIL_BURNING); return; }
                if (nType === MAT.COAL) { _set(nx, ny, MAT.COAL_BURNING); return; }

                // --- START OF FIX ---
                // Add the missing check to see if fire is next to methane.
                if (nType === MAT.METHANE && Math.random() < 0.9) {
                    if (isWorldSim) {
                        tryIgniteAt(nx, ny); // This correctly sets the METHANE_BURNING state and timer
                    } else {
                        // Simplified ignition for non-world grids (e.g., inventory)
                       _set(nx, ny, MAT.FIRE);
                    }
                    _set(x, y, MAT.SMOKE); // The fire is consumed igniting the gas
                    return; // Stop processing this fire pixel for this frame
                }
                // --- END OF FIX ---

                if (nType === MAT.WOOD) { nearbyFuel = true; if (Math.random() < 0.02) _set(nx, ny, MAT.FIRE); }
                if (nType === MAT.WATER) { _set(nx, ny, MAT.STEAM); _set(x, y, MAT.STEAM); return; }
            }
            let targetX = x, targetY = y;
            if (!nearbyFuel && y > 0) {
                let nextX = x, nextY = y - 1;
                if (Math.random() < 0.5) nextX += Math.random() < 0.5 ? -1 : 1;
                const nextType = _get(nextX, nextY);
                if (FIRE_PASSABLE.has(nextType)) {
                    _set(x, y, nextType);
                    _set(nextX, nextY, MAT.FIRE);
                    targetX = nextX; targetY = nextY;
                }
            }
            if (Math.random() < (nearbyFuel ? 0.01 : 0.15)) {
                _set(targetX, targetY, Math.random() < 0.15 ? MAT.SMOKE : MAT.EMPTY);
            }
        }

        function updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
             const _tryIgniteAt = (gx, gy, prob) => {
                if (isWorldSim) tryIgniteAt(gx, gy, prob);
                // No complex ignition in small grids for now
            };

            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                const nx = x + n.x, ny = y + n.y;
                if (_get(nx, ny) === MAT.SAND && Math.random() < 0.08) _set(nx, ny, MAT.GLASS);
                _tryIgniteAt(nx, ny, 0.02);
            }
            if (Math.random() < 0.02 && _get(x, y - 1) === MAT.EMPTY) _set(x, y - 1, MAT.FIRE);
            if (Math.random() < 0.003) _set(x, y, Math.random() < 0.15 ? MAT.SMOKE : MAT.EMPTY);
            if (isWorldSim && getGrid(x, y) === MAT.COAL_BURNING) activateChunkAt(x, y);
        }

        function updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
            const _tryIgniteAt = (gx, gy, prob) => {
                 if (isWorldSim) tryIgniteAt(gx, gy, prob);
            };

            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0},{x:1,y:1},{x:-1,y:1},{x:1,y:-1},{x:-1,y:-1}]) {
                const nx = x + n.x, ny = y + n.y;
                if (_get(nx, ny) === MAT.SAND && Math.random() < 0.1) _set(nx, ny, MAT.GLASS);
                _tryIgniteAt(nx, ny, 0.05);
            }
            if (Math.random() < 0.05 && _get(x, y - 1) === MAT.EMPTY) _set(x, y - 1, MAT.FIRE);
            if (Math.random() < 0.008) _set(x, y, Math.random() < 0.15 ? MAT.SMOKE : MAT.EMPTY);
            if (isWorldSim && getGrid(x, y) === MAT.OIL_BURNING) activateChunkAt(x, y);
        }

        function updateBurningMethane(x, y, type, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype, true);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };

            // 1. Manage Lifespan Timer
            let timer = isWorldSim ? getAuxData(etcChunkMap, x, y) : 1;
            timer--;

            if (timer <= 0) {
                Math.random() < 0.2 ? _set(x, y, MAT.SMOKE) : _set(x, y, MAT.EMPTY);
                if (isWorldSim) setAuxData(etcChunkMap, x, y, 0);
                if(!isWorldSim && idx!==-1) moved[idx] = 1;
                return;
            }

            // --- START OF REPLACEMENT LOGIC ---
            // 2. Spread fire to ALL adjacent flammable materials
            const DIRS_8 = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
            for (const dir of DIRS_8) {
                const nx = x + dir[0], ny = y + dir[1];
                const neighborType = _get(nx, ny);

                // Use the generic isFlammable check to ignite any valid neighbor
                if (isFlammable(neighborType) && Math.random() < 0.6) {
                    if (isWorldSim) {
                        tryIgniteAt(nx, ny);
                    } else {
                         _set(nx, ny, MAT.FIRE); // Simplified ignition for inventories
                    }
                }
            }
            // --- END OF REPLACEMENT LOGIC ---

            // 3. Persist the new decremented timer value
            if (isWorldSim) {
                setAuxData(etcChunkMap, x, y, timer);
            }

            // 4. If not burned out, move like a normal gas
            updateGas(x, y, type, idx, moved, grid, w, h, getIdx, setter);
        }

        function updateSolid(x, y, type, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype, true);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
             const _getAux = (gx, gy) => isWorldSim ? getAuxData(etcChunkMap, gx, gy) : 0;

            if (isWorldSim) { // This logic only applies to the main world simulation
                const destY = y + 1;
                // Quick check: is the destination pixel marked as being part of a rigid body?
                if (getAuxData(etcChunkMap, x, destY) === 1) {
                    // Slower check: find the specific body and its definition
                    const body = getRigidBodyAt(x, destY);
                    if (body) {
                        const def = OBJECT_DEFINITIONS[body.body.getUserData().definitionId];
                        // Does this body's definition allow it to contain this material type?
                        if (def && def.canContain && def.canContain.has(type)) {
                            // Attempt to add the pixel to the body's internal grid
                            if (body.addPixel(type)) {
                                _set(x, y, MAT.EMPTY); // Remove the pixel from the world
                                if (idx !== -1 && !isWorldSim) moved[idx] = 1;
                                return; // Stop further simulation for this pixel this frame
                            }
                        }
                    }
                }
            }

            if (_get(x, y + 1) === MAT.FIRE && type === MAT.COAL) { _set(x, y, MAT.COAL_BURNING); if(!isWorldSim && idx!==-1) moved[idx] = 1; return; }
            if (_getAux(x, y + 1) !== 1) {
                const belowType = _get(x, y + 1);
                if ([MAT.EMPTY, ...GASES].includes(belowType) || isLiquid(belowType)) {
                    _set(x, y, belowType);
                    _set(x, y + 1, type);
                    if(!isWorldSim && idx!==-1) moved[idx] = 1;
                    return;
                }
            }
            const dir = Math.random() < 0.5 ? -1 : 1;
            for (let dx of [dir, -dir]) {
                if (_getAux(x + dx, y + 1) !== 1) {
                    const diagType = _get(x + dx, y + 1);
                    if ([MAT.EMPTY, ...GASES].includes(diagType) || isLiquid(diagType)) {
                        _set(x, y, diagType);
                        _set(x + dx, y + 1, type);
                        if(!isWorldSim && idx!==-1) moved[idx] = 1;
                        return;
                    }
                }
            }
        }
        
        function updateLiquid(x, y, type, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
            const _getAux = (gx, gy) => isWorldSim ? getAuxData(etcChunkMap, gx, gy) : 0;

            // --- Phase 1: Reactions ---

            if (type === MAT.WATER && _get(x, y + 1) === MAT.OBSIDIAN) {
                let isLavaBelow = false;
                for (let i = 1; i <= LAVA_SOLIDIFICATION_DEPTH + 1; i++) {
                    if (_get(x, y + 1 + i) === MAT.LAVA) {
                        isLavaBelow = true;
                        break;
                    }
                }

                if (isLavaBelow) {
                    _set(x, y, MAT.STEAM);
                    const depthVariation = (PerlinNoise.noise(x * 0.1, 42) * 4);
                    const dynamicDepth = Math.max(2, LAVA_SOLIDIFICATION_DEPTH + Math.floor(depthVariation));

                    for (let i = 1; i <= dynamicDepth; i++) {
                        const scanY = y + 1 + i;
                        const scannedCell = _get(x, scanY);
                        
                        if (scannedCell === MAT.LAVA) {
                            _set(x, scanY, MAT.OBSIDIAN);
                        } else if (scannedCell !== MAT.OBSIDIAN) {
                            break;
                        }
                    }
                    if(!isWorldSim && idx!==-1) moved[idx] = 1; return;
                }
            }

            const DIRS_4 = [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}];
            for (const dir of DIRS_4) {
                const nx = x + dir.x, ny = y + dir.y;
                const nType = _get(nx, ny);

                if (type === MAT.LAVA && nType === MAT.WATER) {
                    _set(nx, ny, MAT.STEAM);
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (_get(nx + dx, ny + dy) === MAT.LAVA) {
                                _set(nx + dx, ny + dy, MAT.OBSIDIAN);
                            }
                        }
                    }
                    if(!isWorldSim && idx!==-1) moved[idx] = 1; return;
                }
                if (type === MAT.WATER && nType === MAT.LAVA) {
                    _set(x, y, MAT.STEAM);
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (_get(x + dx, y + dy) === MAT.LAVA) {
                                _set(x + dx, y + dy, MAT.OBSIDIAN);
                            }
                        }
                    }
                    if(!isWorldSim && idx!==-1) moved[idx] = 1; return;
                }
            }


            // --- Phase 2: Behaviors (if no reaction occurred) ---
            if (type === MAT.LAVA) {
                //
                // --- START OF MODIFICATION ---
                // Spread heat to neighbors AND melt obsidian
                for (const dir of DIRS_4) {
                    const nx = x + dir.x;
                    const ny = y + dir.y;
                    const nType = _get(nx, ny);

                    // New logic: Small chance to melt adjacent obsidian back into lava
                    if (isWorldSim && nType === MAT.OBSIDIAN) ensureChunkIsActive(x, y);
                    if (nType === MAT.OBSIDIAN && Math.random() < 0.005) { // 1% chance per neighbor per frame
                        _set(nx, ny, MAT.LAVA);
                        
                    }

                    // Existing logic: Ignite flammable materials
                    if (isWorldSim) tryIgniteAt(nx, ny, 0.4);
                }
                // --- END OF MODIFICATION ---
            }

            if (type === MAT.ACID) {
                let consumed = false;
                for (const dir of DIRS_4) {
                    const nx = x + dir.x, ny = y + dir.y;
                    const nType = _get(nx, ny);
                    const isImmune = [MAT.EMPTY,MAT.GLASS,MAT.GLASS_WALL,MAT.ADAMANTIUM,MAT.RUNE_WALL, MAT.OBSIDIAN, ...GASES].includes(nType);
                    if (!isImmune && !isLiquid(nType) && Math.random() < 0.25) {
                        _set(nx, ny, MAT.EMPTY);
                        if (Math.random() < 0.2) { _set(x, y, MAT.EMPTY); consumed = true; break; }
                    }
                }
                if (consumed) { if(!isWorldSim && idx!==-1) moved[idx] = 1; return; }
            }
             if (type === MAT.OIL_BURNING) {
                updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter);
             }


            // --- Phase 3: Movement (if no reaction occurred) ---
            if (_getAux(x, y + 1) === 1) { 
                tryMoveLiquidSide(x, y, type, Math.random() < 0.5 ? -1 : 1, 20, 1, idx, moved, grid, w, h, getIdx, setter);
                return;
            }
            const belowType = _get(x, y + 1);
            if (belowType === MAT.FIRE) {
                if (type === MAT.OIL) _set(x, y, MAT.OIL_BURNING);
                else { _set(x, y, MAT.STEAM); _set(x, y + 1, MAT.STEAM); } 
                if(!isWorldSim && idx!==-1) moved[idx] = 1;
                return;
            }
            if ([MAT.EMPTY, ...GASES].includes(belowType)) { 
                _set(x, y, belowType); _set(x, y + 1, type); if(!isWorldSim && idx!==-1) moved[idx] = 1; return;
            }
            if (LIQUID_DENSITY[type] > LIQUID_DENSITY[belowType]) { 
                _set(x, y, belowType); _set(x, y + 1, type); if(!isWorldSim && idx!==-1) moved[idx] = 1; return;
            }
            tryMoveLiquidSide(x, y, type, Math.random() < 0.5 ? -1 : 1, 20, 1, idx, moved, grid, w, h, getIdx, setter);
        }

        function updateGas(x, y, type, idx, moved, grid, w, h, getIdx, setter) {
             const isWorldSim = !grid;
             const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
             const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype, true);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
            
            const aboveType = _get(x, y - 1);

            // --- START OF MODIFICATION: DENSITY CHECK ---
            // If the space above is another gas, check densities
            if (GASES.has(aboveType)) {
                if (GAS_DENSITY[type] < GAS_DENSITY[aboveType]) {
                    // This gas is lighter, so it should rise. Swap with the gas above.
                    _set(x, y, aboveType);
                    _set(x, y - 1, type);
                    if(!isWorldSim && idx!==-1) moved[idx] = 1;
                    return;
                }
            }
            // Otherwise, check if it can rise into non-gas materials
            else if ([MAT.EMPTY, MAT.WATER, MAT.OIL, MAT.ACID, MAT.SAND, MAT.SOIL, MAT.GUNPOWDER].includes(aboveType)) {
                _set(x, y, aboveType);
                _set(x, y - 1, type);
                 if(!isWorldSim && idx!==-1) moved[idx] = 1;
                return;
            }
            // --- END OF MODIFICATION ---

            // If it can't move up, try to move sideways
            tryMoveLiquidSide(x, y, type, Math.random() < 0.5 ? -1 : 1, 4, -1, idx, moved, grid, w, h, getIdx, setter);
        }

        function tryMoveLiquidSide(x, y, type, dir, limit, vDir, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
            const _getAux = (gx, gy) => isWorldSim ? getAuxData(etcChunkMap, gx, gy) : 0;
            
            let targetX = x;
            const movable = [MAT.EMPTY];
            const allMovable = [...LIQUIDS, ...GASES, ...movable];
            for (let i = 1; i <= limit; i++) {
                const nextX = x + (dir * i);
                if (_getAux(nextX, y) === 1) break;
                const content = _get(nextX, y);

                if (GASES.has(type) && GASES.has(content)) {
                    // A gas can only push a gas of equal or greater density sideways.
                    if (GAS_DENSITY[type] < GAS_DENSITY[content]) break;
                }

                if (allMovable.includes(content) && type != content) {
                    targetX = nextX;
                    const vType = _get(nextX, y + vDir);
                    if (movable.includes(vType)) break;
                } else break;
            }

            if (targetX !== x) {
                const tType = _get(targetX, y);
                _set(x, y, tType);
                _set(targetX, y, type);
                if(!isWorldSim && idx!==-1) moved[idx] = 1;
                return true;
            }
            return false;
        }


        function findGroundBelow(x, startY) {
            for (let y = startY; y < startY + 500; y++) {
                if (getGrid(x, y) !== MAT.EMPTY) return y;
            }
            return startY + 500;
        }

        function createReservoir({x,y,width,height,fillType,wallType=MAT.WOOD}) {
            const groundY = findGroundBelow(x, y);
            const topY = Math.max(y - 200, groundY - height);
            const leftX = Math.floor(x - width / 2), rightX = Math.floor(x + width / 2);
            const wallWidth = 2;
            for (let iy = topY; iy <= groundY; iy++) {
                for (let ix = leftX; ix <= rightX; ix++) {
                    const isWall = ix <= leftX + wallWidth || ix >= rightX - wallWidth || iy >= groundY - wallWidth;
                    setGrid(ix, iy, isWall ? wallType : fillType);
                }
            }
        }

        function createCircle({x,y,radius,type}) {
            const r2=radius*radius; for(let dy=-radius;dy<=radius;dy++) for(let dx=-radius;dx<=radius;dx++) if(dx*dx+dy*dy<=r2) setGrid(Math.floor(x+dx),Math.floor(y+dy),type);
        }
        function createCircleOutline({x,y,radius,thickness=1,type}) {
            const r2=radius*radius, inner=(radius-thickness)**2; for(let dy=-radius;dy<=radius;dy++) for(let dx=-radius;dx<=radius;dx++) {const d2=dx*dx+dy*dy; if(d2<=r2&&d2>=inner) setGrid(x+dx,y+dy,type);}
        }

        /**
         * A unified, high-performance light propagation function.
         * Takes a queue of initial light source coordinates and spreads light outwards.
         * Returns a Set of neighboring chunk keys that were affected.
         */
        function propagateLightFromQueue(queue) {
            const neighborsToActivate = new Set();
            let head = 0;
            const DIRS_4 = [{ x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: -1 }, { x: 0, y: 1 }];

            while (head < queue.length) {
                const current = queue[head++];
                const currentLight = getAuxData(lightChunkMap, current.x, current.y);
                if (currentLight <= 1) continue;

                const currentChunkX = Math.floor(current.x / CHUNK_SIZE);
                const currentChunkY = Math.floor(current.y / CHUNK_SIZE);

                for (const dir of DIRS_4) {
                    const nextX = current.x + dir.x;
                    const nextY = current.y + dir.y;

                    const nextSectorX = Math.floor(nextX / SECTOR_SIZE);
                    const nextSectorY = Math.floor(nextY / SECTOR_SIZE);
                    if (sectorGrid.get(coordToKey(nextSectorX, nextSectorY)) !== 'ready') continue;

                    const lightLoss = WALL_TYPES.has(getGrid(nextX, nextY)) ? 3 : 0;
                    const nextLight = currentLight - lightLoss;

                    if (nextLight > getAuxData(lightChunkMap, nextX, nextY)) {
                        setAuxData(lightChunkMap, nextX, nextY, nextLight);
                        queue.push({ x: nextX, y: nextY });

                        const nextChunkX = Math.floor(nextX / CHUNK_SIZE);
                        const nextChunkY = Math.floor(nextY / CHUNK_SIZE);

                        if (nextChunkX !== currentChunkX || nextChunkY !== currentChunkY) {
                            neighborsToActivate.add(coordToKey(nextChunkX, nextChunkY));
                        }
                    }
                }
            }
            return neighborsToActivate;
        }

        
        /**
         * Performs an ADDITIVE lighting update on a "dirty" chunk.
         * It re-evaluates the light level of all pixels in the chunk based on their neighbors,
         * ensuring that both newly created empty spaces and existing walls are updated correctly.
         */
        function updateLocalLightingAndFindNeighbors(chunkKey) {
            const chunk = chunkMap.get(chunkKey);
            if (!chunk) return new Set();

            const startX = chunk.cx * CHUNK_SIZE;
            const startY = chunk.cy * CHUNK_SIZE;
            const endX = startX + CHUNK_SIZE;
            const endY = startY + CHUNK_SIZE;
            const queue = [];

            // Seeding Pass: Re-evaluate ALL pixels in the chunk
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    let newLight = 0;
                    
                    if (getGrid(x, y) === MAT.EMPTY) {
                        // For empty space, start with max light
                        newLight = MAX_LIGHT_LEVEL;
                    }

                    // --- THIS IS THE FIX ---
                    // For ALL pixels (empty or solid), check neighbors and pull in brighter light.
                    const DIRS_4 = [{ x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: -1 }, { x: 0, y: 1 }];
                    for (const dir of DIRS_4) {
                        const nX = x + dir.x;
                        const nY = y + dir.y;

                        // Calculate how much light would be lost moving from the neighbor to the current pixel
                        const lightLoss = WALL_TYPES.has(getGrid(x, y)) ? 3 : 1;
                        
                        // Find the brightest possible light level from any neighbor
                        newLight = Math.max(newLight, getAuxData(lightChunkMap, nX, nY) - lightLoss);
                    }
                    // --- END OF FIX ---

                    // If the newly calculated light is brighter than what's currently stored,
                    // update it and add this pixel to the queue to propagate its new light outwards.
                    if (newLight > getAuxData(lightChunkMap, x, y)) {
                        setAuxData(lightChunkMap, x, y, newLight);
                        queue.push({ x, y });
                    }
                }
            }

            // Propagation Pass: Use the unified function to spread the newly seeded light.
            return propagateLightFromQueue(queue);
        }

        function renderNpcs(anim) {
            for (const npc of npcs) {
                // For now, we reuse the player rendering logic
                const npcScreenX = Math.round(npc.x - camera.x);
                const npcScreenY = Math.round(npc.y - camera.y);
                drawPlayerBodyScreen(npcScreenX, npcScreenY, false, anim.bob, anim.frameIdx);
            }
        }

        // --- In index.html ---

        function renderDialogueUI() {
            if (!DialogueManager.isVisible) return;

            const boxW = renderWidth - 40;
            const boxH = 100;
            const boxX = (renderWidth - boxW) / 2;
            const boxY = renderHeight - boxH - 20;

            // Draw background box
            ctx.fillStyle = 'rgba(20, 20, 30, 0.85)';
            ctx.fillRect(boxX, boxY, boxW, boxH);
            ctx.strokeStyle = '#a0a0c0';
            ctx.strokeRect(boxX, boxY, boxW, boxH);

            // Draw NPC Name
            ctx.fillStyle = '#ffd966';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(DialogueManager.npcName, boxX + 10, boxY + 10);

            // --- START: Word Wrapping Implementation ---

            ctx.fillStyle = 'white';
            ctx.font = '8px monospace';
            
            const text = DialogueManager.currentNode.text;
            const textX = boxX + 10;
            let textY = boxY + 30; // The starting Y position for the first line
            const maxWidth = boxW - 20; // Box width minus horizontal padding
            const lineHeight = 10; // The distance between lines of text

            const words = text.split(' ');
            let currentLine = '';

            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine + word + ' ';
                const metrics = ctx.measureText(testLine);

                // If the next word makes the line too long, draw the current line and start a new one.
                if (metrics.width > maxWidth && i > 0) {
                    ctx.fillText(currentLine, textX, textY);
                    currentLine = word + ' ';
                    textY += lineHeight;
                } else {
                    // Otherwise, add the word to the current line.
                    currentLine = testLine;
                }
            }
            // Draw the final remaining line.
            ctx.fillText(currentLine, textX, textY);
            
            // --- END: Word Wrapping Implementation ---

            // Draw Player Options, positioning them dynamically below the wrapped text.
            let yOff = textY + lineHeight + 10; // Start options below the last line of dialogue.
            DialogueManager.currentNode.options.forEach((opt, index) => {
                // Only draw options if they still fit inside the dialogue box.
                if (yOff < boxY + boxH - 10) {
                    ctx.fillText(`[${index + 1}] ${opt.text}`, boxX + 20, yOff);
                    yOff += 12;
                }
            });
        }

        // --- RENDERING ---
        function setPixel(x,y,r,g,b,a=255){ const i=(y*renderWidth+x)*4; pixels[i]=r; pixels[i+1]=g; pixels[i+2]=b; pixels[i+3]=a; }

        function render() {
            firePixelsCoords = [];

            const startX = Math.floor(camera.x);
            const startY = Math.floor(camera.y);

            // --- NEW: Optimized Background Rendering ---
            const bgData = backgroundTileData.data;
            const bgWidth = backgroundTileData.width;
            const bgHeight = backgroundTileData.height;

            // Pass 1: Manually draw background AND world materials in one loop
            for (let screenY = 0; screenY < viewHeight; screenY++) {
                for (let screenX = 0; screenX < viewWidth; screenX++) {
                    const worldX = screenX + startX;
                    const worldY = screenY + startY;
                    const destI = (screenY * renderWidth + screenX) * 4;

                    // --- Step 1: Calculate and draw the background pixel ---
                    // Use modulo to wrap coordinates for the repeating tile
                    const bgX = (worldX % bgWidth + bgWidth) % bgWidth; 
                    const bgY = (worldY % bgHeight + bgHeight) % bgHeight;
                    const bgI = (bgY * bgWidth + bgX) * 4;

                    pixels[destI]     = bgData[bgI];
                    pixels[destI + 1] = bgData[bgI + 1];
                    pixels[destI + 2] = bgData[bgI + 2];
                    pixels[destI + 3] = 255;

                    // --- Step 2: Draw the world material on top (if it exists) ---
                    const type = getGrid(worldX, worldY);
                    if (type === MAT.EMPTY || type === MAT.RIGID_BODY_STUB) continue;
                    
                    const lightLevel = getAuxData(lightChunkMap, worldX, worldY);

                    if (lightLevel === 0 && !ALWAYS_VISIBLE_MATERIALS.has(type)) {
                        pixels[destI] = 0; pixels[destI + 1] = 0; pixels[destI + 2] = 0;
                        continue;
                    }
                    
                    let r, g, b;
                    [r, g, b] = COLORS[type];

                    // Color variations (fire, shimmer, etc.) - no changes here
                    if (type === MAT.FIRE) { r = 255; g = 80 + Math.random() * 80; b = 0; firePixelsCoords.push({ x: screenX, y: screenY }); } 
                    else if (type === MAT.OIL_BURNING || type === MAT.COAL_BURNING) { firePixelsCoords.push({ x: screenX, y: screenY });[r, g, b] = varyColor(...COLORS[type], worldX, worldY, type, 4); } 
                    else if (LIQUIDS.has(type)) { [r, g, b] = varyColor(...COLORS[type], worldX, worldY, type, 4); } 
                    else { if (SHIMMERING_METALS.has(type)) { [r, g, b] = metallicColor(worldX, worldY, COLORS[type]); } else { [r, g, b] = varyColor(...COLORS[type], worldX, worldY, type, 16); } }
                    
                    if (SHIMMERING_METALS.has(type)) { const h = hashCell(worldX, worldY, Math.floor(frameCount / 4)); if (h > 254) { const br = 35; r = Math.min(255, r + br); g = Math.min(255, g + br); b = Math.min(255, b + br); } }
                    
                    // Lighting
                    if (!ALWAYS_VISIBLE_MATERIALS.has(type)) { const br = lightLevel / MAX_LIGHT_LEVEL; r = (r * br) | 0; g = (g * br) | 0; b = (b * br) | 0; }
                    
                    // Blend or draw opaque
                    if (isFluid(type)) {
                        blendPixel(pixels, destI, r | 0, g | 0, b | 0, fluidAlpha(type));
                    } else {
                        pixels[destI] = r | 0; pixels[destI + 1] = g | 0; pixels[destI + 2] = b | 0; pixels[destI + 3] = 255;
                    }
                }
            }

            // --- The rest of the function remains the same ---
            ctx.putImageData(imageData, 0, 0);
            renderBloom();

            // Render Rigid Bodies
            for (const body of rigidBodies) {
                if (!body.body) continue;
                const pos = body.body.getPosition(), angle = body.body.getAngle();
                ctx.save();
                ctx.translate(pos.x * B2_SCALE - camera.x, pos.y * B2_SCALE - camera.y);
                ctx.rotate(angle);
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const type = body.pixels[y * body.width + x];
                        if (type === MAT.EMPTY) continue;
                        let r, g, b;
                        if (SHIMMERING_METALS.has(type)) { [r, g, b] = metallicColor(x, y, COLORS[type]); } else { [r, g, b] = varyColor(...COLORS[type], x, y, type, 8); }
                        ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
                        ctx.fillRect(x - body.width / 2, y - body.height / 2, 1, 1);
                    }
                }
                ctx.restore();
            }

            
            // Player and Particles
            if (player.isSpawning) {
                renderSpawnAnimation();
                // Set wand position to a default during spawn
                wandScreenX = Math.round(player.x - camera.x + 4);
                wandScreenY = Math.round(player.y - camera.y + 9);
                renderNpcs({bob:0, frameIdx:0});
            } else {
                const aim = computePlayerAim();
                const anim = getPlayerAnimFrame();
                const playerDraw = renderPlayer(aim, anim);
                wandScreenX = playerDraw.wandOriginX;
                wandScreenY = playerDraw.wandOriginY;
                renderNpcs(anim);
            }


            for (const p of pouredParticles) { const [r, g, b] = COLORS[p.type]; ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1); }
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) { const p = magicParticlePool[i]; if (p.active) { ctx.fillStyle = `rgb(${p.color[0]},${p.color[1]},${p.color[2]})`; ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1); } }

            if (player.canInteract && player.currentInteractable) {
                const interactable = player.currentInteractable.target;
                let hintX, hintY;

                if (player.currentInteractable.type === 'trigger') {
                    hintX = Math.round(interactable.x - camera.x + interactable.width / 2);
                    hintY = Math.round(interactable.y - camera.y - 15);
                } else { // It's an 'object' (RigidBody)
                    const pos = interactable.body.getPosition();
                    hintX = Math.round(pos.x * B2_SCALE - camera.x);
                    hintY = Math.round(pos.y * B2_SCALE - camera.y - 15);
                }
                
                const animatedY = hintY + Math.sin(frameCount * 0.05) * 3;
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(hintX - 8, animatedY - 12, 16, 16);
                ctx.font = 'bold 12px monospace'; ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('E', hintX, animatedY);
            }

            ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.moveTo(wandScreenX, wandScreenY); ctx.lineTo(mouse.x / scale, mouse.y / scale); ctx.stroke();

            renderDialogueUI();
            renderPlayerStatsUI();
            renderAlchemyUI();
            renderTradeUI();
            renderFloatingArrow();
            renderMessageUI();

            if (debugMode)
            {
                drawActiveChunkOutlines();
                renderStationGeometryDebug();
            } 
        }
        
        // This group of functions can remain as-is
		const PLAYER_SPRITE = [["....##..","...####.","..######","..##F##.","..##F##.","..######",".#######",".#######",".#######",".#######","..######","..######","...####.","..######",".######.","########"],["....##..","...####.","..######","..##F##.","..##F##.","..######",".#######",".#######",".#######",".#######","..######","...#####","..#####.","..######",".######.","########"]];
		function drawPlayerBodyScreen(baseScreenX,baseScreenY,facingRight,bob,frameIdx){const cloak=[0x4a,0x2d,0x5e],face=[0x21,0x1e,0x20],sprite=PLAYER_SPRITE[frameIdx&1];for(let y=0;y<16;y++){const row=sprite[y];for(let x=0;x<8;x++){const ch=row[x];if(ch==='.')continue;const fx=facingRight?x:(7-x),sx=baseScreenX+fx,sy=baseScreenY+y+bob;if(ch==='F')drawPlayerPx(sx,sy,face[0],face[1],face[2]);else drawPlayerPx(sx,sy,cloak[0],cloak[1],cloak[2]);}}}
		function blendPixel(pixels,destI,r,g,b,a){if(a>=255){pixels[destI]=r;pixels[destI+1]=g;pixels[destI+2]=b;pixels[destI+3]=255;return;}if(a<=0)return;const invA=255-a;pixels[destI]=((r*a+pixels[destI]*invA)/255)|0;pixels[destI+1]=((g*a+pixels[destI+1]*invA)/255)|0;pixels[destI+2]=((b*a+pixels[destI+2]*invA)/255)|0;pixels[destI+3]=255;}
        function getWorldTypeAtScreen(screenX,screenY){ const worldX=(screenX+camera.x)|0, worldY=(screenY+camera.y)|0; return getGrid(worldX, worldY); }
		function playerAlphaAtScreen(screenX,screenY){const t=getWorldTypeAtScreen(screenX,screenY);if(!isFluid(t))return 1;const a=fluidAlpha(t)/255,minAlpha=0.20,strength=0.85,out=1-a*strength;return out<minAlpha?minAlpha:out;}
		function drawPlayerPx(screenX,screenY,r,g,b){const a=playerAlphaAtScreen(screenX,screenY);if(a>=0.999){ctx.fillStyle=`rgb(${r|0},${g|0},${b|0})`;ctx.fillRect(screenX,screenY,1,1);return;}ctx.save();ctx.globalAlpha=a;ctx.fillStyle=`rgb(${r|0},${g|0},${b|0})`;ctx.fillRect(screenX,screenY,1,1);ctx.restore();}
		const PLAYER_SPRITE_SCALE=1.0;

		function computePlayerAim(){
            // --- START OF MODIFICATION ---
            const aimDX = mouse.worldX - (player.x + player.width / 2),
                  aimDY = mouse.worldY - (player.y + 9), // The vertical origin of the player's arm
                  aimAngle = Math.atan2(aimDY, aimDX);
            // --- END OF MODIFICATION ---
            
            const wandDir = angleToDir16(aimAngle);
            playerFacingRight = aimDX >= 0;
            return { facingRight: playerFacingRight, wandDir, aimAngle };
        }

		function getPlayerAnimFrame(){const moving=keys['KeyA']||keys['KeyD']||keys['KeyW']||Math.abs(player.vx)>0.05||Math.abs(player.vy)>0.05,rate=moving?6:14,frameIdx=((frameCount/rate)|0)&1;return{bob:frameIdx?1:0,armBob:frameIdx?1:0,frameIdx};}
		function drawWand(ctx,baseScreenX,baseScreenY,facingRight,wandDir,bob,armBob){const handLocalX=facingRight?8:-1,handLocalY=9+bob-armBob,handX=baseScreenX+handLocalX,handY=baseScreenY+handLocalY,wandLen=3,dx=wandDir.x,dy=wandDir.y,mag=Math.max(Math.abs(dx),Math.abs(dy))||1;ctx.fillStyle='#bfa76a';for(let i=0;i<wandLen;i++)ctx.fillRect(handX+Math.round(dx*i/mag),handY+Math.round(dy*i/mag),1,1);ctx.fillStyle='#ffcc66';ctx.fillRect(handX+Math.round(dx*wandLen/mag),handY+Math.round(dy*wandLen/mag),1,1);return{wandOriginX:handX,wandOriginY:handY};}
		
        function renderPlayer(aim, anim){
			const baseW=8,baseH=16,playerScreenX=Math.round(player.x-camera.x),playerScreenY=Math.round(player.y-camera.y);
			ctx.imageSmoothingEnabled=false;
			const anchorX=playerScreenX+(baseW/2),anchorY=playerScreenY+baseH;
			ctx.save();
			ctx.translate(anchorX,anchorY);
			ctx.scale(PLAYER_SPRITE_SCALE,PLAYER_SPRITE_SCALE);
			const localX=-baseW/2,localY=-baseH;
			ctx.translate(localX,localY);
			ctx.restore();
			const scaledBaseX=Math.round(anchorX+localX*PLAYER_SPRITE_SCALE),scaledBaseY=Math.round(anchorY+localY*PLAYER_SPRITE_SCALE);
			
            drawPlayerBodyScreen(scaledBaseX,scaledBaseY,aim.facingRight,anim.bob,anim.frameIdx);
            
            // --- START OF REPLACEMENT LOGIC ---

            // Calculate the hand's position, which is the anchor for any held item.
            const handLocalX = aim.facingRight ? 8 : -1;
            const handLocalY = 9 + anim.bob - anim.armBob;
            const handX = scaledBaseX + handLocalX;
            const handY = scaledBaseY + handLocalY;

            let itemRendered = false;

            // Try to render a tool if it's the active container
            if (activeContainer === 'tool' && player.toolPocket.length > 0) {
                const toolName = player.toolPocket[0];
                const toolDef = Object.values(OBJECT_DEFINITIONS).find(d => d.name === toolName);
                if (toolDef) {
                    renderItemInHand(toolDef.pixels, toolDef.width, toolDef.height, handX, handY, aim.aimAngle, aim.facingRight);
                    itemRendered = true;
                }
            }
            // Try to render a structure if it's the active container
            else if (activeContainer === 'structure' && player.structurePocket.length > 0) {
                const body = player.structurePocket[0];
                renderItemInHand(body.pixels, body.width, body.height, handX, handY, aim.aimAngle, aim.facingRight);
                itemRendered = true;
            }

            // If nothing else was rendered, draw the default wand
            if (!itemRendered) {
                drawWand(ctx, scaledBaseX, scaledBaseY, aim.facingRight, aim.wandDir, anim.bob, anim.armBob);
            }

            // The hand position is the origin for the aim line
            return { wandOriginX: handX, wandOriginY: handY };
            // --- END OF REPLACEMENT LOGIC ---
		}

        /**
         * A generic function to draw an array of pixels as a held item, rotated to the aim angle.
         */
        function renderItemInHand(pixels, width, height, handX, handY, angle, facingRight) {
            ctx.save();
            ctx.translate(handX, handY);
            ctx.rotate(angle);

            // --- START OF FIX ---
            // If facing left, the rotation will make the item upside down.
            // A vertical scale flip corrects the item's orientation.
            if (!facingRight) {
                ctx.scale(1, -1);
            }
            // --- END OF FIX ---

            ctx.scale(0.5, 0.5);
            
            const offsetX = -width / 2;
            const offsetY = -height / 2;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const type = pixels[y * width + x];
                    if (type !== MAT.EMPTY) {
                        const color = COLORS[type];
                        if (color) {
                            ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                            ctx.fillRect(offsetX + x, offsetY + y, 1, 1);
                        }
                    }
                }
            }
            ctx.restore();
        }

        // --- END OF NEW FUNCTION ---
		function createWoodenBox(x,y,width=16,height=16){const box=new RigidBody(x,y,width,height,MAT.WOOD);rigidBodies.push(box);}
        
        function updateRigidBodyInteractions() {
            const now = performance.now();
            const SPLIT_COOLDOWN_MS = 250, SPLIT_DELTA_THRESHOLD = 25;
            const RB_GAS_BUDGET_PER_BODY = 10, RB_GAS_CHANCE = 0.25;
            const isStructural = (t)=>(t!==MAT.EMPTY&&!GASES.has(t));

            // --- START OF NEW CONSTANTS FOR EXPLOSION ---
            const BASE_BARREL_EXPLOSION_RADIUS = 4.0;
            const GUNPOWDER_RADIUS_FACTOR = 0.4; // Each pixel of gunpowder adds this much to the radius
            // --- END OF NEW CONSTANTS ---

            for (const body of rigidBodies) {
                if (body.isDestroyed) continue;
                body.lastSplitTime=body.lastSplitTime??0; body.pendingStructuralDelta=body.pendingStructuralDelta??0;
                let pixelsChanged=false, structuralEditsThisTick=0;
                
                body_pixel_loop: for(let y=0;y<body.height;y++){ for(let x=0;x<body.width;x++){
                    const lIdx=y*body.width+x, type=body.pixels[lIdx]; if(type===MAT.EMPTY)continue;
                    const lPos=pl.Vec2((x-body.width/2+0.5)/B2_SCALE,(y-body.height/2+0.5)/B2_SCALE), wPos=body.body.getWorldPoint(lPos);
                    const wX=Math.floor(wPos.x*B2_SCALE), wY=Math.floor(wPos.y*B2_SCALE);
                    
                    if (type === MAT.WOOD){ for(let dy=-2;dy<=2;dy++){ for(let dx=-2;dx<=2;dx++){
                        const worldMaterial = getGrid(wX+dx, wY+dy);
                        if(worldMaterial===MAT.ACID){ const oldT=body.pixels[lIdx],newT=MAT.EMPTY;if(oldT!==newT){body.pixels[lIdx]=newT;setGrid(wX+dx,wY+dy,MAT.EMPTY);pixelsChanged=true;if(isStructural(oldT)!==isStructural(newT))structuralEditsThisTick++;} continue body_pixel_loop; }
                        
                        if((worldMaterial===MAT.FIRE||worldMaterial===MAT.OIL_BURNING||worldMaterial===MAT.COAL_BURNING||worldMaterial===MAT.METHANE_BURNING)&&Math.random()<0.25){
                            // --- START OF MODIFICATION: BARREL EXPLOSION LOGIC ---
                            const userData = body.body.getUserData();
                            if (userData.definitionId === 'wooden_barrel') {
                                let gunpowderCount = 0;
                                for (const p of body.pixels) {
                                    if (p === MAT.GUNPOWDER) gunpowderCount++;
                                }

                                if (gunpowderCount > 0) {
                                    const center = body.body.getWorldCenter();
                                    const radius = BASE_BARREL_EXPLOSION_RADIUS + (gunpowderCount * GUNPOWDER_RADIUS_FACTOR);
                                    
                                    triggerExplosion(center.x * B2_SCALE, center.y * B2_SCALE, radius);
                                    body.isDestroyed = true;
                                    
                                    // The body is gone, so stop processing its pixels immediately.
                                    break body_pixel_loop;
                                }
                            }
                            // --- END OF MODIFICATION ---

                            // If it wasn't a barrel with gunpowder, it burns normally.
                            const oldT=body.pixels[lIdx],newT=MAT.FIRE;if(oldT!==newT){body.pixels[lIdx]=newT;pixelsChanged=true;if(isStructural(oldT)!==isStructural(newT))structuralEditsThisTick++;} continue body_pixel_loop;
                        }
                    }}}
                }}

                let rbGasBudget=RB_GAS_BUDGET_PER_BODY;
                function emitGas(lIdx){ const lx=lIdx%body.width,ly=(lIdx/body.width)|0,lPos=pl.Vec2((lx-body.width/2+0.5)/B2_SCALE,(ly-body.height/2+0.5)/B2_SCALE),wPos=body.body.getWorldPoint(lPos),wx=Math.floor(wPos.x*B2_SCALE),wy=Math.floor(wPos.y*B2_SCALE); if(getGrid(wx,wy)===MAT.EMPTY||getGrid(wx,wy)===MAT.SMOKE)setGrid(wx,wy,MAT.SMOKE); }
                const localSetter=(idx,type)=>{ if(idx===-1)return; const oldT=body.pixels[idx]; if(type===MAT.SMOKE){ if(rbGasBudget>0&&Math.random()<RB_GAS_CHANCE){emitGas(idx);rbGasBudget--;} const newT=MAT.EMPTY;if(oldT!==newT){body.pixels[idx]=newT;pixelsChanged=true;if(isStructural(oldT)!==isStructural(newT))structuralEditsThisTick++;} return; } if(oldT!==type){body.pixels[idx]=type;pixelsChanged=true;if(isStructural(oldT)!==isStructural(type))structuralEditsThisTick++;} };
                runSimulationOnSmallGrid(body.moved,body.pixels,body.width,body.height,localSetter);
                if (pixelsChanged){ let leaks=0; for(let y=0;y<body.height&&leaks<3;y++){ for(let x=0;x<body.width&&leaks<3;x++){ if(body.pixels[y*body.width+x]!==MAT.FIRE)continue; const lPos=pl.Vec2((x-body.width/2+0.5)/B2_SCALE,(y-body.height/2+0.5)/B2_SCALE),wPos=body.body.getWorldPoint(lPos),wX=Math.floor(wPos.x*B2_SCALE),wY=Math.floor(wPos.y*B2_SCALE); const dirs=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}],d=dirs[(Math.random()*dirs.length)|0]; const checkType=getGrid(wX+d.dx,wY+d.dy); if(checkType===MAT.EMPTY||checkType===MAT.SMOKE){setGrid(wX+d.dx,wY+d.dy,MAT.FIRE);leaks++;} }}}
                if(structuralEditsThisTick>0)body.pendingStructuralDelta+=structuralEditsThisTick;
                if(body.pendingStructuralDelta>=SPLIT_DELTA_THRESHOLD&&(now-body.lastSplitTime)>SPLIT_COOLDOWN_MS){body.needsShapeUpdate=true;body.pendingStructuralDelta=0;body.lastSplitTime=now;}
            }
        }

        function renderContainers() {
            const commonY = 40;
            const pouchX = renderWidth - pouchWidth - 12;
            const flaskX = pouchX - flaskWidth - 8;
            
            renderContainer(pouchGrid,pouchWidth,pouchHeight,pouchX,commonY,activeContainer==='pouch');
            renderContainer(flaskGrid,flaskWidth,flaskHeight,flaskX,commonY,activeContainer==='flask');

            const pocketW = 48, pocketH = 24;
            const toolX = flaskX - pocketW - 8;
            const structX = toolX - pocketW - 8;
            
            // --- START OF MODIFICATION: TOOL POCKET VISUALS ---
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(toolX-2,commonY-2,pocketW+4,pocketH+4);
            ctx.strokeStyle=activeContainer==='tool'?'white':'#888'; ctx.lineWidth=2; ctx.strokeRect(toolX-2,commonY-2,pocketW+4,pocketH+4);
            if (player.toolPocket.length > 0) {
                const toolName = player.toolPocket[0];
                const toolDef = Object.values(OBJECT_DEFINITIONS).find(d => d.name === toolName);

                if (toolDef) {
                    const scale = Math.min((pocketW - 4) / toolDef.width, (pocketH - 4) / toolDef.height);
                    const renderW = toolDef.width * scale;
                    const renderH = toolDef.height * scale;
                    const offsetX = toolX + (pocketW - renderW) / 2;
                    const offsetY = commonY + (pocketH - renderH) / 2;

                    for (let y = 0; y < toolDef.height; y++) {
                        for (let x = 0; x < toolDef.width; x++) {
                            const type = toolDef.pixels[y * toolDef.width + x];
                            if (type !== MAT.EMPTY) {
                                const color = COLORS[type];
                                if(color) {
                                    ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                                    ctx.fillRect(offsetX + x * scale, offsetY + y * scale, scale, scale);
                                }
                            }
                        }
                    }
                }
            }
            // --- END OF MODIFICATION ---

            // Structure Pocket
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(structX-2,commonY-2,pocketW+4,pocketH+4);
            ctx.strokeStyle=activeContainer==='structure'?'white':'#888'; ctx.lineWidth=2; ctx.strokeRect(structX-2,commonY-2,pocketW+4,pocketH+4);
             if (player.structurePocket.length > 0) {
                const body = player.structurePocket[0]; 
                const scale = Math.min((pocketW - 4) / body.width, (pocketH - 4) / body.height);
                const renderW = body.width * scale;
                const renderH = body.height * scale;
                const offsetX = structX + (pocketW - renderW) / 2;
                const offsetY = commonY + (pocketH - renderH) / 2;

                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const type = body.pixels[y * body.width + x];
                        if (type !== MAT.EMPTY) {
                            const color = COLORS[type];
                            if(color) {
                                ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                                ctx.fillRect(offsetX + x * scale, offsetY + y * scale, scale, scale);
                            }
                        }
                    }
                }
             }
        }

        function renderContainer(cGrid,cW,cH,screenX,screenY,isActive) {
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(screenX-2,screenY-2,cW+4,cH+4);
            ctx.strokeStyle=isActive?'white':'#888'; ctx.lineWidth=2; ctx.strokeRect(screenX-2,screenY-2,cW+4,cH+4);
            for(let y=0;y<cH;y++)for(let x=0;x<cW;x++){
                const type=cGrid[getIdx(x,y,cW,cH)];
                if(type!==MAT.EMPTY){ let r,g,b; if(SHIMMERING_METALS.has(type)){[r,g,b]=metallicColor(x,y,COLORS[type]);}else{[r,g,b]=varyColor(...COLORS[type],x,y,type,8);} ctx.fillStyle=`rgb(${r},${g},${b})`;ctx.fillRect(screenX+x,screenY+y,1,1); }
            }
        }

        function renderBloom() {
            const bloomResolution = 4, blurPasses = 3;
            bloomCtx.clearRect(0, 0, bloomCanvas.width, bloomCanvas.height);
            bloomCtx.globalCompositeOperation = 'source-over';
            const camX = Math.floor(camera.x), camY = Math.floor(camera.y);

            for (let y = 0; y < viewHeight; y++) {
                for (let x = 0; x < viewWidth; x++) {
                    const type = getGrid(x + camX, y + camY);
                    const bloomConfig = BLOOM_MATERIALS[type];
                    if (bloomConfig) {
                        const [r, g, b] = bloomConfig.color;
                        bloomCtx.fillStyle = `rgba(${r},${g},${b},${bloomConfig.intensity})`;
                        bloomCtx.fillRect(x/bloomResolution,y/bloomResolution,1,1);
                    }
                }
            }
            bloomCtx.globalCompositeOperation = 'copy';
            for (let i = 0; i < blurPasses; i++) {
                bloomCtx.filter = `blur(${1 << i}px)`;
                bloomCtx.drawImage(bloomCanvas, 0, 0);
            }
            bloomCtx.filter = 'none';
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 1.0;
            ctx.drawImage(bloomCanvas, 0, 0, renderWidth, renderHeight);
            ctx.restore();
        }

        const WAND_DIRS_16 = [
            {x:1, y:0}, {x:2, y:1}, {x:1, y:1}, {x:1, y:2}, {x:0, y:1}, {x:-1, y:2}, {x:-1, y:1}, {x:-2, y:1}, 
            {x:-1, y:0}, {x:-2, y:-1}, {x:-1, y:-1}, {x:-1, y:-2}, {x:0, y:-1}, {x:1, y:-2}, {x:1, y:-1}, {x:2, y:-1}
        ];

        function angleToDir16(a){ const step=Math.PI/8; const i=Math.round(a/step)&15; return WAND_DIRS_16[i]; }
        function hashCell(x,y,type){ let h=x*374761393+y*668265263+type*1442695041; h=(h^(h>>13))*1274126177; return(h^(h>>16))&0xff; }
        function metallicColor(x,y,baseRGB){const[br,bg,bb]=baseRGB,s1=0.5+0.5*Math.sin((x*0.35)+(y*0.18)),s2=0.5+0.5*Math.sin((x*0.08)-(y*0.12)),t=0.65*s1+0.35*s2,glint=(Math.sin(x*0.9+y*0.25)>0.985)?0.25:0.0,m=0.85+0.35*t+glint,r=Math.min(255,Math.max(0,br*m)),g=Math.min(255,Math.max(0,bg*(m*0.98))),b=Math.min(255,Math.max(0,bb*(m*1.05)));return[r|0,g|0,b|0];}
        function varyColor(r,g,b,x,y,type,strength=18){ const n=hashCell(x,y,type)/255, delta=(n-0.5)*strength*2; return[Math.max(0,Math.min(255,r+delta)),Math.max(0,Math.min(255,g+delta)),Math.max(0,Math.min(255,b+delta))]; }
        function updateHoverMaterial(){ hudMaterial = MATERIAL_NAME[getGrid(mouse.worldX, mouse.worldY)] || 'Unknown'; }
        
        function generateRunicSlab(slabX,slabY,slabWidth,slabHeight,bgMat,runeMat) {
            for(let y=slabY;y<slabY+slabHeight;y++)for(let x=slabX;x<slabX+slabWidth;x++) setGrid(x,y,bgMat);
            const vPad=Math.floor((slabHeight-DWARVEN_RUNES.RUNE_HEIGHT)/2),runesTopY=slabY+vPad,runesBottomY=runesTopY+DWARVEN_RUNES.RUNE_HEIGHT-1;
            const linePad=3,topLineY=runesTopY-linePad,bottomLineY=runesBottomY+linePad;
            for(let x=slabX;x<slabX+slabWidth;x++){ setGrid(x,topLineY,runeMat); setGrid(x,bottomLineY,runeMat); }
            let cursorX = slabX + 5;
            while(cursorX+DWARVEN_RUNES.RUNE_WIDTH+5<slabX+slabWidth){
                const pattern=DWARVEN_RUNES.PATTERNS[Math.floor(Math.random()*DWARVEN_RUNES.PATTERNS.length)];
                for(let y=0;y<DWARVEN_RUNES.RUNE_HEIGHT;y++)for(let x=0;x<DWARVEN_RUNES.RUNE_WIDTH;x++) if(pattern[y][x]===1) setGrid(cursorX+x,runesTopY+y,runeMat);
                cursorX+=DWARVEN_RUNES.RUNE_WIDTH+5;
            }
        }
        
        // This group of functions can remain as-is
		function createMagicEmitter(options) {
            const emitter = {
                id: nextEmitterId++,
                mainColor: options.mainColor || [255, 255, 255],
                spawnRate: options.spawnRate || 0.2,
                spawnType: options.spawnType || 'area',
                x: options.x || 0,
                y: options.y || 0,
                spawnArea: options.spawnArea || {
                    width: 10,
                    height: 5
                },
                x1: options.x1 || 0,
                y1: options.y1 || 0,
                x2: options.x2 || 0,
                y2: options.y2 || 0,
                particleLifespan: options.particleLifespan || {
                    min: 60,
                    max: 150
                },
                particleVelocity: options.particleVelocity || {
                    vx: {
                        min: -0.2,
                        max: 0.2
                    },
                    vy: {
                        min: -0.2,
                        max: -0.6
                    }
                },
                colorVariance: options.colorVariance || 60
            };
            magicEmitters.push(emitter);
            return emitter.id;
        }

        function removeMagicEmitter(id) {
            magicEmitters = magicEmitters.filter(e => e.id !== id);
        }

        function updateMagicEmitters() {
            for (const emitter of magicEmitters) {
                if (Math.random() < emitter.spawnRate) {
                    for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                        const p = magicParticlePool[i];
                        if (!p.active) {
                            let spawnX, spawnY;
                            if (emitter.spawnType === 'line') {
                                const t = Math.random();
                                spawnX = emitter.x1 + t * (emitter.x2 - emitter.x1);
                                spawnY = emitter.y1 + t * (emitter.y2 - emitter.y1);
                            } else {
                                spawnX = emitter.x + (Math.random() - 0.5) * emitter.spawnArea.width;
                                spawnY = emitter.y + (Math.random() - 0.5) * emitter.spawnArea.height;
                            }
                            const r = Math.max(0, Math.min(255, emitter.mainColor[0] + (Math.random() - 0.5) * emitter.colorVariance)),
                                g = Math.max(0, Math.min(255, emitter.mainColor[1] + (Math.random() - 0.5) * emitter.colorVariance)),
                                b = Math.max(0, Math.min(255, emitter.mainColor[2] + (Math.random() - 0.5) * emitter.colorVariance));
                            p.active = true;
                            p.gravity = 0;
                            p.x = spawnX;
                            p.y = spawnY;
                            p.vx = emitter.particleVelocity.vx.min + Math.random() * (emitter.particleVelocity.vx.max - emitter.particleVelocity.vx.min);
                            p.vy = emitter.particleVelocity.vy.min + Math.random() * (emitter.particleVelocity.vy.max - emitter.particleVelocity.vy.min);
                            p.lifespan = emitter.particleLifespan.min + Math.random() * (emitter.particleLifespan.max - emitter.particleLifespan.min);
                            p.color = [r, g, b];
                            break;
                        }
                    }
                }
            }
        }

        function spawnLevitationParticles(count) {
            let spawnedCount = 0;
            const baseX = player.x + player.width / 2,
                baseY = player.y + player.height - 2;
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) {
                    p.active = true;
                    p.x = baseX + (Math.random() - 0.5) * 4;
                    p.y = baseY + (Math.random() - 0.5) * 2;
                    p.vx = (Math.random() - 0.5) * 0.5;
                    p.vy = (Math.random() * 0.8) + 0.4 - (player.vy * 0.1);
                    p.gravity = 0;
                    const baseColor = [180, 200, 255],
                        colorVariance = 40;
                    p.color = [Math.max(0, Math.min(255, baseColor[0] + (Math.random() - 0.5) * colorVariance)), Math.max(0, Math.min(255, baseColor[1] + (Math.random() - 0.5) * colorVariance)), Math.max(0, Math.min(255, baseColor[2] + (Math.random() - 0.5) * colorVariance))];
                    p.lifespan = 15 + Math.random() * 20;
                    spawnedCount++;
                    if (spawnedCount >= count) return;
                }
            }
        }

        function spawnMagicParticles(count, x, y, mainColor) {
            let spawnedCount = 0;
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) {
                    p.active = true;
                    p.x = x + (Math.random() - 0.5) * 20;
                    p.y = y + (Math.random() - 0.5) * 10;
                    p.gravity = 0;
                    const colorVariance = 60,
                        r = Math.max(0, Math.min(255, mainColor[0] + (Math.random() - 0.5) * colorVariance)),
                        g = Math.max(0, Math.min(255, mainColor[1] + (Math.random() - 0.5) * colorVariance)),
                        b = Math.max(0, Math.min(255, mainColor[2] + (Math.random() - 0.5) * colorVariance));
                    p.color = [r, g, b];
                    p.vx = (Math.random() - 0.5) * 0.3;
                    p.vy = -0.2 + (Math.random() * -0.4);
                    p.lifespan = 60 + Math.random() * 90;
                    spawnedCount++;
                    if (spawnedCount >= count) return;
                }
            }
        }

        function updateMagicParticles() {
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) continue;
                p.x += p.vx;
                p.y += p.vy;
                if (p.gravity) p.vy += p.gravity;
                p.lifespan--;
                if (p.lifespan <= 0) p.active = false;
            }
        }
        
        function checkForLiquidSplashes(now) {
            const MIN_SPLASH_SPEED = 2.0;
            const allBodies = [...rigidBodies, player];
            for (const bodyInst of allBodies) {
                if (!bodyInst.body || bodyInst.isDestroyed) continue;
                bodyInst.wasInLiquid = bodyInst.wasInLiquid ?? false;
                let isInLiquid=false, splashX=0, splashY=0, splashMat=0;
                const samplePointsX=[bodyInst.width*0.25,bodyInst.width*0.5,bodyInst.width*0.75], localY=bodyInst.height-1;
                for(const localX of samplePointsX){
                    const wPos=bodyInst.body.getWorldPoint(pl.Vec2((localX-bodyInst.width/2)/B2_SCALE,(localY-bodyInst.height/2)/B2_SCALE));
                    const wX=Math.floor(wPos.x*B2_SCALE),wY=Math.floor(wPos.y*B2_SCALE);
                    const matType=getGrid(wX,wY);
                    if(isLiquid(matType)){isInLiquid=true;splashX=wX;splashY=wY;splashMat=matType;break;}
                }
                if(isInLiquid&&!bodyInst.wasInLiquid){ const speed=bodyInst.body.getLinearVelocity().length(); if(speed>MIN_SPLASH_SPEED)createSplashEffect(splashX,splashY,splashMat,speed); }
                bodyInst.wasInLiquid = isInLiquid;
            }
        }
        function createSplashEffect(x,y,matType,vel){
            const isLiq=LIQUIDS.has(matType),baseColor=COLORS[matType]||[255,255,255],pCount=Math.min(10,Math.ceil(vel*3)),velMult=0.5+vel*0.2;
            let spawned=0;
            for(let i=0;i<MAX_MAGIC_PARTICLES&&spawned<pCount;i++){
                const p=magicParticlePool[i]; if(p.active)continue; p.active=true; p.x=x+(Math.random()-0.5)*4; p.y=y;
                const v=30; p.color=[Math.max(0,Math.min(255,baseColor[0]+(Math.random()-0.5)*v)),Math.max(0,Math.min(255,baseColor[1]+(Math.random()-0.5)*v)),Math.max(0,Math.min(255,baseColor[2]+(Math.random()-0.5)*v))];
                const angle=(Math.random()*Math.PI)+Math.PI,speed=Math.random()*1.5*velMult;
                if(isLiq){p.vx=Math.cos(angle)*speed;p.vy=Math.sin(angle)*speed*1.5;p.gravity=0.05;p.lifespan=15+Math.random()*15;}
                else{p.vx=Math.cos(angle)*speed*1.2;p.vy=Math.sin(angle)*speed*0.5;p.gravity=0;p.lifespan=10+Math.random()*10;}
                spawned++;
            }
        }
        
        // This group of functions can remain as-is
		function getDominantMaterialInArea(x, y, width, height) {
            const counts = {};
            let maxCount = 0,
                domMat = null;
            for (let iy = y; iy < y + height; iy++) {
                for (let ix = x; ix < x + width; ix++) {
                    const type = getGrid(ix, iy);
                    if (STORABLE_SOLIDS.has(type) || STORABLE_LIQUIDS.has(type)) {
                        counts[type] = (counts[type] || 0) + 1;
                        if (counts[type] > maxCount) {
                            maxCount = counts[type];
                            domMat = type;
                        }
                    }
                }
            }
            return domMat;
        }

        function processAlchemyJobs() {
            if (alchemyJobs.length === 0) return;
            const particlesToTeleport = 5;
            for (let i = alchemyJobs.length - 1; i >= 0; i--) {
                const job = alchemyJobs[i],
                    target = job.target;
                for (let j = 0; j < particlesToTeleport; j++) {
                    if (job.manifest.length === 0) {
                        alchemyJobs.splice(i, 1);
                        break;
                    }
                    const matInfo = job.manifest.shift();
                    const rimX = target.cx,
                        rimY = target.cy,
                        span = target.r * 0.6,
                        spawnX = Math.floor(rimX + (Math.random() * 2 - 1) * span),
                        spawnY = Math.floor(rimY - (30 + Math.random() * 10));
                    const spawnType = getGrid(spawnX, spawnY);
                    if (spawnType === MAT.EMPTY) {
                        setGrid(spawnX, spawnY, matInfo.type);
                        activateChunkAt(spawnX, spawnY);
                    } else {
                        job.manifest.unshift(matInfo);
                    }
                }
            }
        }
        const ALCHEMY_REACTIONS = {
            'filter_material': {
                name: "Filter Material",
                execute: function(station) {
                    const filterMat = getDominantMaterialInSemicircle(station.sampler);
                    if (filterMat === null) {
                        console.log("filterMat empty");
                        return;
                    }
                    const source = station.cauldrons.left,
                        target = station.cauldrons.right,
                        manifest = [];
                    forEachInDownwardSemicircle(source, (x, y) => {
                        if (getGrid(x, y) === filterMat) {
                            manifest.push({
                                type: filterMat
                            });
                            setGrid(x, y, MAT.EMPTY);
                            activateChunkAt(x, y);
                        }
                    });
                    if (manifest.length === 0) return;
                    alchemyJobs.push({
                        manifest: manifest,
                        target: target
                    });
                }
            },
            'heat_material': {
                name: "Heat Material",
                execute: function(station) {
                    const source = station.cauldrons.left;
                    spawnMagicParticles(50, source.cx, source.cy + source.r * 0.5, [255, 100, 0]);
                    forEachInDownwardSemicircle(source, (x, y) => {
                        let changed = true;
                        switch (getGrid(x, y)) {
                            case MAT.SAND:
                                setGrid(x, y, MAT.GLASS);
                                break;
                            case MAT.WOOD:
                                setGrid(x, y, MAT.FIRE);
                                break;
                            case MAT.OIL:
                                setGrid(x, y, MAT.OIL_BURNING);
                                break;
                            case MAT.COAL:
                                setGrid(x, y, MAT.COAL_BURNING);
                                break;
                            case MAT.GUNPOWDER:
                                setGrid(x, y, MAT.GUNPOWDER_IGNITED);
                                setAuxData(etcChunkMap, x, y, 8 + Math.floor(Math.random() * 6));
                                break;
                            case MAT.WATER:
                                setGrid(x, y, MAT.STEAM);
                                break;
                            default:
                                changed = false;
                                break;
                        }
                        if (changed) activateChunkAt(x, y);
                    });
                }
            },
            'clear_cauldrons': {
                name: "Clear Cauldrons",
                execute: function(station) {
                    const areas = [station.cauldrons.left, station.cauldrons.right, station.sampler];
                    for (const area of areas) {
                        spawnMagicParticles(30, area.cx, area.cy, [200, 200, 255]);
                        forEachInDownwardSemicircle(area, (x, y) => {
                            const type = getGrid(x, y);
                            if (type !== MAT.ADAMANTIUM && type !== MAT.RUNE_WALL) {
                                setGrid(x, y, MAT.EMPTY);
                                activateChunkAt(x, y);
                            }
                        });
                    }
                }
            }
        };

        function forEachInDownwardSemicircle(area, fn) {
            const cx = area.cx,
                cy = area.cy,
                r = area.r,
                r2 = r * r,
                minX = Math.floor(cx - r),
                maxX = Math.ceil(cx + r),
                minY = Math.floor(cy),
                maxY = Math.ceil(cy + r);
            for (let y = minY; y <= maxY; y++) {
                const dy = y - cy,
                    dy2 = dy * dy;
                for (let x = minX; x <= maxX; x++) {
                    const dx = x - cx;
                    if (dx * dx + dy2 <= r2) fn(x, y);
                }
            }
        }

        function getDominantMaterialInSemicircle(area) {
            const counts = new Map();
            forEachInDownwardSemicircle(area, (x, y) => {
                const t = getGrid(x, y);
                if (t === MAT.EMPTY || t === MAT.ADAMANTIUM || t === MAT.RUNE_WALL) return;
                counts.set(t, (counts.get(t) || 0) + 1);
            });
            let bestType = null,
                bestCount = 0;
            for (const [t, c] of counts)
                if (c > bestCount) {
                    bestType = t;
                    bestCount = c;
                } return bestType;
        }
        
        function generateAlchemyStation() {
            const width=600,height=200,startX=0,startY=-200,floorY=startY+height-20;
            for(let y=startY;y<startY+height;y++)for(let x=startX;x<startX+width;x++)setGrid(x,y,MAT.EMPTY);
            for(let y=floorY;y<startY+height;y++)for(let x=startX;x<startX+width;x++)setGrid(x,y,MAT.ADAMANTIUM);
            const slabH=15,slabW=70,slabY=floorY-slabH,slabX=startX+130;
            generateRunicSlab(slabX,slabY,slabW,slabH,MAT.ADAMANTIUM,MAT.RUNE_WALL);
            const leftX=startX+260,rightX=startX+390,samplerX=startX+325,rimY=floorY-15,cauldronR=32,cauldronT=4,cauldronInnerR=cauldronR-cauldronT,samplerR=16,samplerT=4,samplerInnerR=samplerR-samplerT;
            createCauldron(leftX,rimY,cauldronR,cauldronT,MAT.ADAMANTIUM,MAT.RUNE_WALL);
            createCauldron(rightX,rimY,cauldronR,cauldronT,MAT.ADAMANTIUM,MAT.RUNE_WALL);
            createCauldron(samplerX,floorY-10,samplerR,samplerT,MAT.ADAMANTIUM,MAT.RUNE_WALL);
            const stationGeo={cauldrons:{left:{cx:leftX,cy:rimY,r:cauldronInnerR},right:{cx:rightX,cy:rimY,r:cauldronInnerR}},sampler:{cx:samplerX,cy:floorY-10,r:samplerInnerR}};
            createTrigger({x:slabX,y:slabY,width:slabW,height:slabH,onEnter:function(t){const eId=createMagicEmitter({spawnType:'line',x1:slabX,y1:slabY,x2:slabX+slabW,y2:slabY,mainColor:[255,230,100],spawnRate:0.5});t.associatedData.emitterId=eId;},onLeave:function(t){if(t.associatedData.emitterId!=null){removeMagicEmitter(t.associatedData.emitterId);t.associatedData.emitterId=null;}},onInteract:function(){isAlchemyUIVisible=true;},associatedData:{stationGeometry:stationGeo}});
        }
        function createCauldron(cx,rimY,radius,thickness,material,edgeMaterial){const r2=radius*radius,orInner=radius-1,orInner2=orInner*orInner,ir=radius-thickness,ir2=ir*ir;for(let dy=0;dy<=radius;dy++)for(let dx=-radius;dx<=radius;dx++){const d2=dx*dx+dy*dy;if(d2<=r2)setGrid(cx+dx,rimY+dy,d2>orInner2?edgeMaterial:material);}for(let dy=0;dy<ir;dy++)for(let dx=-ir;dx<=ir;dx++)if(dx*dx+dy*dy<=ir2)setGrid(cx+dx,rimY+dy,MAT.EMPTY);}

        function prioritizeAndLimitActiveChunks() {
            const allChunksToConsider = new Set([...pendingActiveChunks, ...nextActiveChunks]);
            nextActiveChunks.clear();

            const priorityChunks = new Set();
            const otherChunks = [];
            const camChunkX1 = Math.floor(camera.x / CHUNK_SIZE), camChunkX2 = Math.floor((camera.x + viewWidth) / CHUNK_SIZE);
            const camChunkY1 = Math.floor(camera.y / CHUNK_SIZE), camChunkY2 = Math.floor((camera.y + viewHeight) / CHUNK_SIZE);

            for (const key of allChunksToConsider) {
                const chunk = chunkMap.get(key);
                if (!chunk) continue; // Should not happen, but a good safeguard

                const cx = chunk.cx;
                const cy = chunk.cy;
                if (cx >= camChunkX1 && cx <= camChunkX2 && cy >= camChunkY1 && cy <= camChunkY2) {
                    priorityChunks.add(key);
                } else {
                    otherChunks.push(key);
                }
            }
            const pChunkX = Math.floor(player.x / CHUNK_SIZE), pChunkY = Math.floor(player.y / CHUNK_SIZE);
            otherChunks.sort((a, b) => {
                const chunkA = chunkMap.get(a);
                const chunkB = chunkMap.get(b);
                if (!chunkA || !chunkB) return 0;
                
                const distA = (chunkA.cx - pChunkX) ** 2 + (chunkA.cy - pChunkY) ** 2;
                const distB = (chunkB.cx - pChunkX) ** 2 + (chunkB.cy - pChunkY) ** 2;
                return distA - distB;
            });
            const processingOrder = [...priorityChunks, ...otherChunks];

            // --- START OF FIX ---
            // The bug was here. It should slice to MAX_CHUNKS_PER_FRAME, not add to it.
            const chunksToProcess = processingOrder.slice(0, MAX_CHUNKS_PER_FRAME);
            pendingActiveChunks = processingOrder.slice(MAX_CHUNKS_PER_FRAME);
            // --- END OF FIX ---
            
            activeChunks.clear();
            for (const key of chunksToProcess) activeChunks.add(key);
        }

        // --- GAME LOOP ---
        async function gameLoop(now = performance.now()) {
            debugStats.getCalls = 0;
            debugStats.getHits = 0;
            debugStats.setCalls = 0;
            debugStats.setHits = 0;

            frameCount++;
            framesThisSecond++;
            if (now - lastFpsTime >= 1000) {
                hudFPS = framesThisSecond;
                framesThisSecond = 0;
                lastFpsTime = now;
            }

            checkGenerationQueue() 

            await updateSectors(); // Await the async function
            manageSectorMemory();  // Check if we need to unload a sector
            const t0 = performance.now();
            if (frameCount % VISIBLE_LIQUID_SCAN_INTERVAL === 0) {
                findAndActivateLiquidSurfaces(); // Call renamed function
                findAndActivateGasClouds();      // Call new function
            }
            prioritizeAndLimitActiveChunks();
            
            // --- UPDATE LOGIC ---
            if (toolUseCooldown > 0) toolUseCooldown--;
            updateSpawnAnimation();
            updatePlayer();
            updateRigidBodyInteractions();
            // --- THIS IS THE FIX ---
            // This call advances the PlanckJS physics simulation, applying gravity and forces.
            tOtherMs2 = performance.now() - t0;
            updateRigidBodies(now);
            // --- END OF FIX ---
            
            syncPlayerWithBody();
            checkForLiquidSplashes(now);
            updateRigidBodyGrid();

            //x

            const newBodiesFromSplits = [];
            for (let i = rigidBodies.length - 1; i >= 0; i--) {
                const body = rigidBodies[i];
                if (body.isDestroyed) continue;

                if (body.needsShapeUpdate && (now - body.lastRebuildTime > REBUILD_COOLDOWN)) {
                    const newBodies = checkForSplits(body);
                    if (newBodies && newBodies.length) {
                        newBodiesFromSplits.push(...newBodies);
                        body.needsShapeUpdate = false;
                        body.lastRebuildTime = now;
                    } else {
                        body.rebuildFixtures();
                        body.lastRebuildTime = now;
                    }
                }
            }
            if (newBodiesFromSplits.length > 0) rigidBodies.push(...newBodiesFromSplits);
            
            cleanupDestroyedBodies();

            updatePouredParticles();
            processAlchemyJobs();
            updateMagicParticles();
            updateMagicEmitters();
            updateInteractions();
            updateMessageSystem();

            const lightingQueue = [...activeChunks];
            const processedChunks = new Set(activeChunks);
            let head = 0;
            while (head < lightingQueue.length) {
                const chunkToUpdate = lightingQueue[head++];
                const newNeighbors = updateLocalLightingAndFindNeighbors(chunkToUpdate);
                for (const neighbor of newNeighbors) {
                    if (!processedChunks.has(neighbor)) {
                        processedChunks.add(neighbor);
                        lightingQueue.push(neighbor);
                    }
                }
            }

            if (isPouring) pourFromContainer();
            if (isStoring) storeMaterial(mouse.worldX, mouse.worldY);
            if (isDrawing || isPouring || isStoring) activateChunkAt(mouse.worldX, mouse.worldY);

            tOtherMs3 = performance.now() - t0 - tOtherMs2;

            const t1 = performance.now();
            // --- SIMULATIONS ---
            for (let i = 0; i < SIMULATION_STEPS_PER_FRAME; i++) {
                runWorldSimulationWithChunks();
                if (i === 0) {
                    const pouchSetter = (idx, type) => { if (idx !== -1) pouchGrid[idx] = type; };
                    runSimulationOnSmallGrid(movedPouch, pouchGrid, pouchWidth, pouchHeight, pouchSetter);
                    const flaskSetter = (idx, type) => { if (idx !== -1) flaskGrid[idx] = type; };
                    runSimulationOnSmallGrid(movedFlask, flaskGrid, flaskWidth, flaskHeight, flaskSetter);
                }
            }
            tSimMs = performance.now() - t1;

            updateCamera();
            mouse.worldX = Math.floor(camera.x + mouse.x / scale);
            mouse.worldY = Math.floor(camera.y + mouse.y / scale);

            const t2 = performance.now();
            // --- RENDER LOGIC ---
            render();
            renderContainers();
            drawHUD();
            tRenderMs = performance.now() - t2;
            
            if ((frameCount % 2) === 0) updateHoverMaterial();
            
            requestAnimationFrame(gameLoop);
            
            tOtherMs = performance.now() - t0 - tSimMs - tRenderMs;

            if (debugMode) {
                renderDebugUI();
                ctx.fillStyle = "white";
                ctx.font = "8px monospace";
                ctx.textAlign = "right";
                ctx.fillText(`sim: ${tSimMs.toFixed(2)}ms`, renderWidth - 6, renderHeight - 10);
                ctx.fillText(`render: ${tRenderMs.toFixed(2)}ms`, renderWidth - 6, renderHeight - 20);
                ctx.fillText(`other: ${tOtherMs.toFixed(2)}ms`, renderWidth - 6, renderHeight - 30);
                ctx.fillText(`coords: ${player.x.toFixed(0)} ${player.y.toFixed(0)}`, renderWidth - 6, renderHeight - 40);
                ctx.textAlign = "left";
            }
        }
        
        function cleanupDestroyedBodies(){
            const kept=[];
            for(const rb of rigidBodies){
                if(!rb.isDestroyed){kept.push(rb);continue;}
                if(rb.body){rb.body.setUserData(null);rb.body.setActive(false);world.destroyBody(rb.body);rb.body=null;}
            }
            rigidBodies=kept;
        }

        function drawHUD(){
            ctx.imageSmoothingEnabled=false;ctx.font='8px monospace';ctx.textAlign='right';ctx.textBaseline='top';
            ctx.fillStyle='#00ff90';ctx.fillText(`FPS: ${hudFPS}`,renderWidth-6,6);
            ctx.fillStyle='#ffd966';ctx.fillText(`MAT: ${hudMaterial}`,renderWidth-6,6+10);
        }

        function renderStationGeometryDebug() {
            const slabTrigger = triggers.find(t => t.name === 'alchemy_slab');
            if (!slabTrigger || !slabTrigger.associatedData || !slabTrigger.associatedData.stationGeometry) {
                return;
            }

            const stationGeo = slabTrigger.associatedData.stationGeometry;
            
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
            ctx.lineWidth = 1;

            // Draw left cauldron
            const leftCauldron = stationGeo.cauldrons.left;
            const screenLeftX = leftCauldron.cx - camera.x;
            const screenLeftY = leftCauldron.cy - camera.y;
            ctx.beginPath();
            ctx.arc(screenLeftX, screenLeftY, leftCauldron.r, 0, Math.PI);
            ctx.fill();
            ctx.stroke();

            // Draw right cauldron
            const rightCauldron = stationGeo.cauldrons.right;
            const screenRightX = rightCauldron.cx - camera.x;
            const screenRightY = rightCauldron.cy - camera.y;
            ctx.beginPath();
            ctx.arc(screenRightX, screenRightY, rightCauldron.r, 0, Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Draw sampler
            const sampler = stationGeo.sampler;
            const screenSamplerX = sampler.cx - camera.x;
            const screenSamplerY = sampler.cy - camera.y;
            ctx.beginPath();
            ctx.arc(screenSamplerX, screenSamplerY, sampler.r, 0, Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        function renderDebugUI() {
            // Calculate derived stats
            const activeSectors = Array.from(sectorGrid.values()).filter(s => s.state === 'ready').length;
            const getHitRatio = debugStats.getCalls > 0 ? (debugStats.getHits / debugStats.getCalls * 100).toFixed(1) : "N/A";
            const setHitRatio = debugStats.setCalls > 0 ? (debugStats.setHits / debugStats.setCalls * 100).toFixed(1) : "N/A";
            const getMisses = debugStats.getCalls - debugStats.getHits;
            const setMisses = debugStats.setCalls - debugStats.setHits;

            // UI positioning and styling
            const startX = 10;
            let startY = 50; // Position below the player stats
            const lineHeight = 10;
            const indent = 10;
            
            ctx.font = "8px monospace";
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            
            // Draw a semi-transparent background for readability
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(startX - 4, startY - 4, 180, 88);

            // Set text color for the stats
            ctx.fillStyle = "white";

            // Display stats
            ctx.fillText(`Active Chunks: ${activeChunks.size}`, startX, startY);
            startY += lineHeight;
            ctx.fillText(`Ready Sectors: ${activeSectors} / ${MAX_READY_SECTORS}`, startX, startY);
            startY += (lineHeight * 1.5); // Add extra space

            ctx.fillText(`setGrid Calls: ${debugStats.setCalls}`, startX, startY);
            startY += lineHeight;
            ctx.fillText(`- Hits: ${debugStats.setHits} / Miss: ${setMisses} (${setHitRatio}%)`, startX + indent, startY);
            startY += (lineHeight * 1.5);

            ctx.fillText(`getGrid Calls: ${debugStats.getCalls}`, startX, startY);
            startY += lineHeight;
            ctx.fillText(`- Hits: ${debugStats.getHits} / Miss: ${getMisses} (${getHitRatio}%)`, startX + indent, startY);
        }

        // --- START OF NEW FUNCTION ---
        /**
         * Draws a red border on the screen around all currently active simulation chunks.
         */
        function drawActiveChunkOutlines() {
            ctx.lineWidth = 1;

            // Draw processed chunks in GREEN
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
            for (const key of activeChunks) {
                const chunk = chunkMap.get(key);
                if (!chunk) continue;

                const screenX = chunk.cx * CHUNK_SIZE - camera.x;
                const screenY = chunk.cy * CHUNK_SIZE - camera.y;
                ctx.strokeRect(screenX, screenY, CHUNK_SIZE, CHUNK_SIZE);
            }

            // Draw deferred (pending) chunks in RED
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
            for (const key of pendingActiveChunks) {
                const chunk = chunkMap.get(key);
                if (!chunk) continue;

                const screenX = chunk.cx * CHUNK_SIZE - camera.x;
                const screenY = chunk.cy * CHUNK_SIZE - camera.y;
                ctx.strokeRect(screenX, screenY, CHUNK_SIZE, CHUNK_SIZE);
            }
        }
        // --- END OF NEW FUNCTION ---

        function createTrigger(options){
            const trigger={id:nextTriggerId++,name: options.name || null,x:options.x,y:options.y,width:options.width,height:options.height,onEnter:options.onEnter||function(){},onLeave:options.onLeave||function(){},onInteract:options.onInteract||function(){},isActive:false,associatedData:options.associatedData, isVolatile: options.isVolatile || false, isDestroyed: false};
            triggers.push(trigger);return trigger.id;
        }

        function updateInteractions() {
            for (const trigger of triggers) {
                if (trigger.isDestroyed) continue;

                const isInside = (player.x + player.width > trigger.x && player.x < trigger.x + trigger.width &&
                                  player.y + player.height > trigger.y && player.y < trigger.y + trigger.height);

                if (isInside && !trigger.isActive) {
                    // Player has just entered
                    trigger.isActive = true;
                    if (trigger.onEnter) trigger.onEnter(trigger);
                } else if (!isInside && trigger.isActive) {
                    // Player has just left
                    trigger.isActive = false;
                    if (trigger.onLeave) trigger.onLeave(trigger);
                }
            }

            let closestInteractable = null;
            let minDistanceSq = PLAYER_INTERACTION_RADIUS * PLAYER_INTERACTION_RADIUS;

            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            // Phase 1: Check static triggers (like the alchemy slab or NPC dialogues)
            for (const trigger of triggers) {
                if (trigger.isDestroyed) continue;
                
                const isInside = (player.x + player.width > trigger.x && player.x < trigger.x + trigger.width &&
                                  player.y + player.height > trigger.y && player.y < trigger.y + trigger.height);
                
                if (isInside) {
                    const triggerCenterX = trigger.x + trigger.width / 2;
                    const triggerCenterY = trigger.y + trigger.height / 2;
                    const distSq = (playerCenterX - triggerCenterX)**2 + (playerCenterY - triggerCenterY)**2;

                    if (distSq < minDistanceSq) {
                        minDistanceSq = distSq;
                        closestInteractable = { type: 'trigger', target: trigger };
                    }
                }
            }

            // Phase 2: Check dynamic, pickupable objects
            for (const body of rigidBodies) {
                if (body.isDestroyed || !body.body || !body.body.getUserData().isPickup) continue;

                const bodyPos = body.body.getPosition();
                const worldX = bodyPos.x * B2_SCALE;
                const worldY = bodyPos.y * B2_SCALE;

                const distSq = (playerCenterX - worldX)**2 + (playerCenterY - worldY)**2;

                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestInteractable = { type: 'object', target: body };
                }
            }

            // Final Step: Update the player's state
            player.currentInteractable = closestInteractable;
            player.canInteract = (closestInteractable !== null);
        }

        function renderTradeUI() {
            if (!TradeManager.isVisible) return;

            // --- START: NEW LOGIC TO COUNT METALS ---
            const station = player.activeStationGeometry;
            let availableMetals = { [MAT.COPPER]: 0, [MAT.SILVER]: 0, [MAT.GOLD]: 0 };
            if (station) {
                availableMetals = countMetalsInCauldron(station.cauldrons.left);
            }
            // --- END: NEW LOGIC TO COUNT METALS ---

            ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, 0, renderWidth, renderHeight);
            const boxW = 340, boxH = 180, boxX = (renderWidth - boxW) / 2, boxY = (renderHeight - boxH) / 2;
            ctx.fillStyle = '#222'; ctx.fillRect(boxX, boxY, boxW, boxH);
            ctx.strokeStyle = '#888'; ctx.strokeRect(boxX, boxY, boxW, boxH);
            ctx.fillStyle = 'white'; ctx.font = '16px monospace'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
            ctx.fillText("Alchemist's Wares:", boxX + 10, boxY + 10);

            // --- ADD: DISPLAY AVAILABLE PAYMENT ---
            ctx.fillStyle = '#c0c0c0';
            ctx.font = '8px monospace';
            const paymentText = `Payment Available: ${availableMetals[MAT.COPPER]} Copper, ${availableMetals[MAT.SILVER]} Silver, ${availableMetals[MAT.GOLD]} Gold`;
            ctx.fillText(paymentText, boxX + 10, boxY + 30);


            const startIndex = TradeManager.currentPage * TradeManager.itemsPerPage;
            const endIndex = startIndex + TradeManager.itemsPerPage;
            const itemsToShow = TRADE_INVENTORY.slice(startIndex, endIndex);

            // --- MODIFICATION: SINGLE-LINE ITEM DISPLAY ---
            let yOff = 50; // Adjusted starting Y-offset
            itemsToShow.forEach((item, index) => {
                const itemNum = index + 1;
                let costString = Object.entries(item.cost).map(([mat, amount]) => {
                    return `${amount} ${MATERIAL_NAME[mat]}`;
                }).join(', ');

                const fullItemText = `[${itemNum}] ${item.name} (Cost: ${costString})`;
                
                ctx.fillStyle = 'white';
                ctx.font = '8px monospace';
                ctx.fillText(fullItemText, boxX + 20, boxY + yOff);
                yOff += 15; // Use a smaller increment for single lines
            });

            const totalPages = Math.ceil(TRADE_INVENTORY.length / TradeManager.itemsPerPage);
            if (totalPages > 1) {
                ctx.fillStyle = '#ffd966';
                ctx.font = '8px monospace';
                // --- MODIFICATION: CLEARER NEXT PAGE TEXT ---
                ctx.fillText(`Press [0] for Next Page (${TradeManager.currentPage + 1}/${totalPages})`, boxX + 20, boxY + boxH - 40);
            }

            ctx.fillStyle = '#aaa';
            ctx.font = '8px monospace';
            ctx.fillText("Press [ESC] to close.", boxX + 10, boxY + boxH - 25);
        }

        function renderAlchemyUI() {
            if(!isAlchemyUIVisible)return;
            ctx.fillStyle='rgba(0,0,0,0.6)';ctx.fillRect(0,0,renderWidth,renderHeight);
            const boxW=300,boxH=150,boxX=(renderWidth-boxW)/2,boxY=(renderHeight-boxH)/2;
            ctx.fillStyle='#222';ctx.fillRect(boxX,boxY,boxW,boxH);ctx.strokeStyle='#888';ctx.strokeRect(boxX,boxY,boxW,boxH);
            ctx.fillStyle='white';ctx.font='16px monospace';ctx.textAlign='left';ctx.textBaseline='top';ctx.fillText("Select a Reaction:",boxX+10,boxY+10);
            let yOff=40;

            if (player.unlockedReactions.length === 0) {
                ctx.fillStyle='#aaa';
                ctx.fillText("No reactions unlocked.", boxX+20, boxY+yOff);
            } else {
                player.unlockedReactions.forEach((reactionKey, idx) => {
                    const r = ALCHEMY_REACTIONS[reactionKey];
                    if (r) {
                        ctx.fillText(`[${idx + 1}] ${r.name}`, boxX+20, boxY+yOff);
                        yOff += 20;
                    }
                });
            }

            ctx.fillStyle='#aaa';ctx.fillText("Press [ESC] to close.",boxX+10,boxY+boxH-25);
        }

        function updateLoadingStatus(message) { document.getElementById('loading-status').innerText=message; }

        async function mainLoader() {
            localStorage.clear();
            const loadingOverlay = document.getElementById('loading-overlay');
            const yieldToBrowser = () => new Promise(resolve => setTimeout(resolve, 20));
            
            WORLD_SEED = Math.floor(Math.random() * 1000000);
            // Initialize the main, persistent worker for in-game generation
            generationWorker.postMessage({ type: 'init', seed: WORLD_SEED });

            PerlinNoise.seed(WORLD_SEED);
            
            staticPixelBuffer = new Uint8ClampedArray(renderWidth * renderHeight * 4);
            isRenderCacheInvalid = true;
            lastCameraX = -1;
            lastCameraY = -1;

            const bloomResolution = 4; // Use a canvas 1/4th the size
            bloomCanvas = document.createElement('canvas');
            bloomCanvas.width = renderWidth / bloomResolution;
            bloomCanvas.height = renderHeight / bloomResolution;
            bloomCtx = bloomCanvas.getContext('2d');

            updateLoadingStatus('Carving Background Strata...');
            await yieldToBrowser();
            const bgTileCanvas = generateCaveBackgroundTile(BACKGROUND_TILE_SIZE, BACKGROUND_TILE_SIZE * 5);
            const bgTileCtx = bgTileCanvas.getContext('2d');
            backgroundTileData = bgTileCtx.getImageData(0, 0, bgTileCanvas.width, bgTileCanvas.height);

            // Store the player's spawn sector coordinates for biome and set piece calculations
            playerSpawnSX = Math.floor(player.x / SECTOR_SIZE);
            playerSpawnSY = Math.floor(player.y / SECTOR_SIZE);

            updateLoadingStatus('Preparing Spawn Area...');
            await yieldToBrowser();

            // Loop through the 9 sectors around the player's start and generate them one by one.
            let sectorsLoaded = 0;
            const totalSectors = 9;
            for (let sy = playerSpawnSY - 1; sy <= playerSpawnSY + 1; sy++) {
                for (let sx = playerSpawnSX - 1; sx <= playerSpawnSX + 1; sx++) {
                    sectorsLoaded++;
                    updateLoadingStatus(`Generating Starting Area (${sectorsLoaded}/${totalSectors})...`);
                    
                    // --- START OF THE FIX ---
                    // This promise now contains the full, correct logic for generating a single sector.
                    const sectorGenerationPromise = new Promise(resolve => {
                        // A temporary worker is used just for this initial loading task.
                        const tempLocalGenerator = new Worker('generation.worker.js');
                        
                        // Define how to handle messages FROM the temporary worker.
                        tempLocalGenerator.onmessage = event => {
                            const { type, chunks, lightChunks } = event.data;

                            if (type === 'init-ack') {
                                // The worker is ready. Now we can send it the generation command.
                                const biomeInfo = BiomeManager.getBiomeForSector(sx, sy);
                                const setPieces = SetPieceManager.getSetPiecesForSector(sx, sy);
                                const finalBiomeInfo = biomeInfo || { name: "OceanOfRock", params: {} };

                                tempLocalGenerator.postMessage({
                                    type: 'generate-and-bake',
                                    sx: sx,
                                    sy: sy,
                                    borderContext: gatherBorderContext(sx, sy),
                                    biomeInfo: finalBiomeInfo,
                                    setPieces: setPieces
                                });
                            } 
                            else if (type === 'result') {
                                // The worker has finished and sent back the terrain data.
                                // Integrate the chunk data into the main game state.
                                for (const [key, payload] of chunks) {
                                    const chunk = getChunk(chunkMap, key);
                                    chunk.data = payload.data;
                                    chunk.cx = payload.cx;
                                    chunk.cy = payload.cy;
                                }
                                if (lightChunks) {
                                    for (const [key, payload] of lightChunks) {
                                        const chunk = getChunk(lightChunkMap, key);
                                        chunk.data = payload.data;
                                        chunk.cx = payload.cx;
                                        chunk.cy = payload.cy;
                                    }
                                }
                                
                                tempLocalGenerator.terminate(); // Clean up the worker
                                resolve(); // Resolve the promise to signal completion
                            }
                        };

                        // Start the process by initializing the temporary worker.
                        tempLocalGenerator.postMessage({ type: 'init', seed: WORLD_SEED });
                    });
                    
                    await sectorGenerationPromise; // Wait for the current sector to finish before starting the next
                    // --- END OF THE FIX ---

                    const key = coordToKey(sx, sy);
                    sectorGrid.set(key, { state: 'ready', sx: sx, sy: sy });
                }
            }

            updateLoadingStatus('Constructing Ancient Structures...');
            await yieldToBrowser();
            
            // --- START: Run Post-Generation Hooks for Set Pieces ---
            const processedHooks = new Set(); // Prevents running a hook more than once
            for (let sy = playerSpawnSY - 1; sy <= playerSpawnSY + 1; sy++) {
                for (let sx = playerSpawnSX - 1; sx <= playerSpawnSX + 1; sx++) {
                    const setPiecesInSector = SetPieceManager.getSetPiecesForSector(sx, sy);
                    for (const pieceInfo of setPiecesInSector) {
                        if (!processedHooks.has(pieceInfo.name)) {
                            // Find the full set piece definition to get its hook function
                            const pieceDef = SetPieceManager.setPieces.find(p => p.name === pieceInfo.name);
                            if (pieceDef && pieceDef.postGenerationHook) {
                                pieceDef.postGenerationHook(pieceInfo);
                                processedHooks.add(pieceInfo.name);
                            }
                        }
                    }
                }
            }

            updateLoadingStatus('Populating World...');
            await yieldToBrowser();
            
            // Spawn 'Ylialkemisti' in the alchemy station
            createNpc({
                name: 'Ylialkemisti',
                x: 450, // Positioned to the right of the cauldrons
                y: STATION_FLOOR_Y - 16,
                dialogueTreeId: 'ylialkemisti_main'
            });

            const stationPieceDef = SetPieceManager.setPieces.find(p => p.name === 'AlchemistStation');
            if (stationPieceDef) {
                const pieceInfo = { name: "AlchemistStation", bounds: stationPieceDef.getBounds() };
                const npcObject = npcs.find(n => n.name === 'Ylialkemisti');
                if(npcObject) {
                    npcObject.associatedData.stationGeometry = stationPieceDef.postGenerationHook.call(stationPieceDef, pieceInfo).stationGeometry;
                }
            }

            //createObjectInWorld('stone_pick', 480, STATION_FLOOR_Y - 16);
            //createObjectInWorld('wooden_barrel', 520, STATION_FLOOR_Y - 16);

            updateLoadingStatus('Finalizing...');
            await yieldToBrowser();
            activateInitialChunks();
            //createPlayerBody();
            //createWoodenBox(150, -150, 24, 64);

            updateLoadingStatus('Done!');
            await new Promise(resolve => setTimeout(resolve, 100));
            loadingOverlay.style.transition = 'opacity 0.5s';
            loadingOverlay.style.opacity = '0';
            await new Promise(resolve => setTimeout(() => {
                loadingOverlay.style.display = 'none';
                resolve();
            }, 500));
            gameLoop();
        }

        function updateWorldColliders(now) {
            const neededChunks = new Set(),
                lookahead = 1,
                allDynBodies = [...rigidBodies, player];
            for (const bodyObj of allDynBodies) {
                if (!bodyObj.body) continue;
                const body = bodyObj.body;
                let aabb = null;
                for (let f = body.getFixtureList(); f; f = f.getNext()) {
                    const f_aabb = f.getAABB(0);
                    if (!aabb) aabb = { lX: f_aabb.lowerBound.x, lY: f_aabb.lowerBound.y, uX: f_aabb.upperBound.x, uY: f_aabb.upperBound.y };
                    else { aabb.lX = Math.min(aabb.lX, f_aabb.lowerBound.x); aabb.lY = Math.min(aabb.lY, f_aabb.lowerBound.y); aabb.uX = Math.max(aabb.uX, f_aabb.upperBound.x); aabb.uY = Math.max(aabb.uY, f_aabb.upperBound.y); }
                }
                if (!aabb) continue;
                const minCX = Math.floor(aabb.lX * B2_SCALE / CHUNK_SIZE) - lookahead,
                    maxCX = Math.ceil(aabb.uX * B2_SCALE / CHUNK_SIZE) + lookahead;
                const minCY = Math.floor(aabb.lY * B2_SCALE / CHUNK_SIZE) - lookahead,
                    maxCY = Math.ceil(aabb.uY * B2_SCALE / CHUNK_SIZE) + lookahead;
                for (let cy = minCY; cy <= maxCY; cy++)
                    for (let cx = minCX; cx <= maxCX; cx++) {
                        // --- THIS IS THE FIX ---
                        neededChunks.add(coordToKey(cx, cy)); // Use numeric key
                    }
            }
            for (const key of activeStaticChunks) {
                if (!neededChunks.has(key)) {
                    const chunk = chunkMap.get(key);
                    if (chunk && chunk.staticBody) chunk.staticBody.setActive(false);
                }
            }
            for (const key of neededChunks) {
                const chunk = getChunk(chunkMap, key);
                if (chunk.dirty && chunk.staticBody) {
                    if (now - chunk.lastRegenTime > REGEN_COOLDOWN) { world.destroyBody(chunk.staticBody); chunk.staticBody = null; }
                }
                if (!chunk.staticBody) { chunk.staticBody = generateStaticBodyForChunk(chunk); chunk.dirty = false; chunk.lastRegenTime = now; }
                chunk.staticBody.setActive(true);
            }
            activeStaticChunks = neededChunks;
        }

        function updateRigidBodies(now) {
            // THE FIX: Only run the expensive collider update logic periodically.
            if (now - lastColliderUpdateTime > COLLIDER_UPDATE_INTERVAL) {
                updateWorldColliders(now);
                lastColliderUpdateTime = now;
            }

            // The core physics step still runs every frame.
            world.step(1 / 60);
        }

        function generateStaticBodyForChunk(chunk) {
            const body=world.createBody({type:'static'});
            const startX=chunk.cx*CHUNK_SIZE, startY=chunk.cy*CHUNK_SIZE;
            const mask=new Uint8Array(CHUNK_SIZE*CHUNK_SIZE);
            for(let y=0;y<CHUNK_SIZE;y++)for(let x=0;x<CHUNK_SIZE;x++){
                const wX=startX+x, wY=startY+y;
                mask[y*CHUNK_SIZE+x]=isSolidForPlayer(getGrid(wX,wY)) && getAuxData(etcChunkMap, wX, wY) !== 1 ? 1 : 0;
            }
            const islands=extractIslands(mask,CHUNK_SIZE,CHUNK_SIZE);
            for(const island of islands){
                const outline=marchingSquares(island,CHUNK_SIZE,CHUNK_SIZE); if(outline.length<3)continue;
                const simplifiedPre=simplifyDouglasPeucker(outline,0.2); if(simplifiedPre.length<3)continue;
                const simplified=removeCollinear(simplifiedPre,0.001); if(simplified.length<3)continue;
                validatePolygon(simplified);
                const flat=[];for(const p of simplified)flat.push(p.x,p.y);
                const indices=earcut(flat);
                for(let i=0;i<indices.length;i+=3){
                    const p0=simplified[indices[i]],p1=simplified[indices[i+1]],p2=simplified[indices[i+2]];
                    const ax=(startX+p0.x)/B2_SCALE,ay=(startY+p0.y)/B2_SCALE,bx=(startX+p1.x)/B2_SCALE,by=(startY+p1.y)/B2_SCALE,cx=(startX+p2.x)/B2_SCALE,cy=(startY+p2.y)/B2_SCALE;
                    body.createFixture(pl.Polygon([pl.Vec2(ax,ay),pl.Vec2(bx,by),pl.Vec2(cx,cy)]));
                }
            }
            body.setActive(false);
            return body;
        }
        
        function renderPlayerStatsUI() {
            const barW = 75,
                barH = 8,
                x = 16;
            let y = 8;
            ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barW, barH);
            const hpP = player.hp / player.maxHp;
            ctx.fillStyle = '#d14242';
            ctx.fillRect(x, y, barW * hpP, barH);
            ctx.fillStyle = 'white';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${player.hp}/${player.maxHp}`, x + barW / 2, y + barH / 2);
            y += barH + 5;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barW, barH);
            const enP = player.hoverEnergy / player.maxHoverEnergy;
            ctx.fillStyle = '#DDED64';
            ctx.fillRect(x, y, barW * enP, barH);
            ctx.fillStyle = 'white';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${Math.round(player.hoverEnergy)}/${player.maxHoverEnergy}`, x + barW / 2, y + barH / 2);
        }

        window.onload = function() {
            const loadingStatus = document.getElementById('loading-status');
            loadingStatus.innerText = 'Loading Physics Engine...';
            mainLoader();
        };
    </script>
</body>
</html>