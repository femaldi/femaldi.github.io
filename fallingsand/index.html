<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Sand Platformer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            user-select: none;
            overflow: hidden;
        }
        h1 { margin-bottom: 10px; }
        .controls {
            margin-bottom: 10px;
            background: #333;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        .btn-sand { background-color: #f6d7b0; color: #333; }
        .btn-water { background-color: #4fa4f4; color: white; }
        .btn-soil { background-color: #5d4037; color: white; }
        .btn-wall { background-color: #888; color: white; }
        .btn-gas { background-color: #e0e0e0; color: #333; }
        .btn-fire { background-color: #ff4500; color: white; }
        .btn-oil {
            background-color: #5a4622;
            color: #fff;
        }
        .btn-coal {
            background-color: #111111;
            color: #fff;
        }
        .btn-wood { background-color: #8b4513; color: white; }
        .btn-gunpowder { background-color: #444; color: #fff; border: 1px solid #777; }
        .btn-acid { background-color: #00ff00; color: white; }
        .btn-glass { background-color: #e0e0ff; color: #333; }
        .btn-glass-wall { background-color: #b4b4e0; color: #333; }
        .btn-adamantium { background-color: #4d5257; color: white; border: 1px solid #aeb5be; }
        .btn-copper { background-color: #b87333; color: white; }
        .btn-silver { background-color: #c0c0c0; color: #333; }
        .btn-gold { background-color: #ffd700; color: #333; }
        .btn-platinum { background-color: #e5e4e2; color: #333; }
        .btn-rune-wall { background-color: #2a2a3a; color: #d0c0ff; border: 1px solid #5a4a7a; }
        .btn-eraser { background-color: #000; color: white; border: 1px solid #555; }
        button.active {
            outline: 2px solid white;
            box-shadow: 0 0 8px rgba(255,255,255,0.6);
        }
        .info-bar { font-size: 14px; color: #ccc; }
        .info-bar strong { color: white; }
        canvas {
            border: 2px solid #555;
            background-color: #000;
            cursor: crosshair;
            image-rendering: pixelated; 
        }
        #controls_ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 8px 10px;
            border-radius: 6px;
            pointer-events: none;
        }
    </style>
</head>
<body>
   <div id="loading-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a2a; color: #fff; z-index: 1000; display: flex; justify-content: center; align-items: center; flex-direction: column;">
        <h1 style="font-size: 2.5em; margin-bottom: 20px;">Falling Sand Platformer</h1>
        <p id="loading-status" style="font-size: 1.2em; font-family: monospace;">Initializing...</p>
    </div>

    <h1>Falling Sand Platformer</h1>
    <div class="info-bar">
        Use <strong>A/D</strong> to Move, <strong>W</strong> to Jump. Use the mouse to build and destroy.
    </div>

    <div class="controls">
        <button class="btn-sand active" onclick="setMaterial('sand')">Sand</button>
        <button class="btn-soil" onclick="setMaterial('soil')">Soil</button>
        <button class="btn-water" onclick="setMaterial('water')">Water</button>
        <button class="btn-gas" onclick="setMaterial('gas')">Gas</button>
        <button class="btn-wall" onclick="setMaterial('wall')">Wall</button>
        <button class="btn-wood" onclick="setMaterial('wood')">Wood</button>
        <button class="btn-fire" onclick="setMaterial('fire')">Fire</button>
        <button class="btn-gunpowder" onclick="setMaterial('gunpowder')">Gunpowder</button>
        <button class="btn-oil" onclick="setMaterial('oil')">Oil</button>
        <button class="btn-coal" onclick="setMaterial('coal')">Coal</button>
        <button class="btn-acid" onclick="setMaterial('acid')">Acid</button>
        <button class="btn-glass" onclick="setMaterial('glass')">Glass</button>
        <button class="btn-glass-wall" onclick="setMaterial('glass-wall')">Glass Wall</button>
        <button class="btn-adamantium" onclick="setMaterial('adamantium')">Adamantium</button>
        <button class="btn-copper" onclick="setMaterial('copper')">Copper</button>
        <button class="btn-silver" onclick="setMaterial('silver')">Silver</button>
        <button class="btn-gold" onclick="setMaterial('gold')">Gold</button>
        <button class="btn-platinum" onclick="setMaterial('platinum')">Platinum</button>
        <button class="btn-rune-wall" onclick="setMaterial('rune-wall')">Rune Wall</button>
        <button class="btn-eraser" onclick="setMaterial('empty')">Eraser</button>
    </div>

    <div id="controls_ui">
        <b>Controls</b><br>
        A / D – Move<br>
        W – Jump<br>
        Q – Switch Container<br>
        Left Click – Pour<br>
        Right Click – Store<br>
        Middle Click – Paint Brush
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // --- CONFIGURATION ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const CHUNK_SIZE = 16; // Chunks will be 16x16 pixels
        let chunkWidth, chunkHeight;
        let chunkGrid; // This will hold state for each chunk
        let activeChunks = new Set(); // A set of active chunk indices for the current frame
        let nextActiveChunks = new Set(); // A set of chunks to activate for the *next* frame


        // NEW: Increased view area and reduced scale
        const viewWidth = 600;
        const viewHeight = 400;
        const scale = 2; // Smaller pixels

        const SIMULATION_STEPS_PER_FRAME = 2;

        // canvas.width = viewWidth * scale; // Same canvas size: 300*4 = 1200
        // canvas.height = viewHeight * scale; // Same canvas size: 200*4 = 800
        canvas.width = viewWidth;
        canvas.height = viewHeight;

        canvas.style.width = viewWidth * scale + "px";
        canvas.style.height = viewHeight * scale + "px";

        canvas.style.imageRendering = "pixelated";


        const worldWidth = viewWidth * 30;
        const worldHeight = viewHeight * 10;

        const renderWidth = viewWidth;
        const renderHeight = viewHeight;

        const imageData = ctx.createImageData(renderWidth, renderHeight);
        const pixels = imageData.data; // Uint8ClampedArray

        // --- MATERIAL DEFINITIONS ---
        const MAT = {
            EMPTY: 0, WALL: 1, SAND: 2, WATER: 3, SOIL: 4, GAS: 5, 
            WOOD: 10, FIRE: 11, GUNPOWDER: 12, GUNPOWDER_IGNITED: 13,
            OIL: 14, OIL_BURNING: 15,
            COAL:16, COAL_BURNING:17,
            ACID:18, GLASS:19, GLASS_WALL: 20,
            ADAMANTIUM: 21, COPPER: 22, SILVER: 23, GOLD: 24, PLATINUM: 25, RUNE_WALL: 26
        };

        const COLORS = {
            [MAT.WALL]: [100, 100, 100], [MAT.SAND]: [246, 215, 176],
            [MAT.WATER]: [79, 164, 244], [MAT.SOIL]: [93, 64, 55],
            [MAT.GAS]: [200, 200, 200], [MAT.WOOD]: [139, 69, 19],
            [MAT.FIRE]: [255, 69, 0], [MAT.GUNPOWDER]: [60, 60, 60],
            [MAT.GUNPOWDER_IGNITED]: [120, 80, 80], [MAT.OIL]: [90, 70, 30], [MAT.OIL_BURNING]: [255, 69, 0],
            [MAT.COAL]: [30, 30, 30], [MAT.COAL_BURNING]: [255, 69, 0],
            [MAT.ACID]: [0, 255, 0], [MAT.GLASS]: [200, 200, 255], [MAT.GLASS_WALL]: [180, 180, 235],
            [MAT.ADAMANTIUM]: [77, 82, 87], [MAT.COPPER]: [184, 115, 51],
            [MAT.SILVER]: [192, 192, 192], [MAT.GOLD]: [255, 215, 0],
            [MAT.PLATINUM]: [229, 228, 226], [MAT.RUNE_WALL]: [200, 200, 100]
        };

        const MATERIAL_NAME = {
            [MAT.EMPTY]: 'Empty',
            [MAT.WALL]: 'Wall',
            [MAT.SAND]: 'Sand',
            [MAT.WATER]: 'Water',
            [MAT.SOIL]: 'Soil',
            [MAT.GAS]: 'Gas',
            [MAT.WOOD]: 'Wood',
            [MAT.FIRE]: 'Fire',
            [MAT.GUNPOWDER]: 'Gunpowder',
            [MAT.GUNPOWDER_IGNITED]: 'Gunpowder (Ignited)',
            [MAT.OIL]: 'Oil',
            [MAT.OIL_BURNING]: 'Burning Oil',
            [MAT.COAL]: 'Coal',
            [MAT.COAL_BURNING]: 'Burning Coal',
            [MAT.ACID]: 'Acid',
            [MAT.GLASS]: 'Glass',
            [MAT.GLASS_WALL]: 'Glass Wall',
            [MAT.ADAMANTIUM]: 'Adamantium', 
            [MAT.COPPER]: 'Copper',
            [MAT.SILVER]: 'Silver', 
            [MAT.GOLD]: 'Gold', 
            [MAT.PLATINUM]: 'Platinum',
            [MAT.RUNE_WALL]: 'Rune Wall'
        };

        // --- RUNE DEFINITIONS ---
        // A library of rune patterns. 1 represents the rune material, 0 is empty.
        const DWARVEN_RUNES = {
            // A simple 7x9 pixel font for the runes
            RUNE_WIDTH: 7,
            RUNE_HEIGHT: 9,
            PATTERNS: [
                // "Axe"
                [
                    [0,1,1,1,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,0,1,1,0]
                ],
                // "Hammer"
                [
                    [1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0]
                ],
                // "Shield"
                [
                    [1,1,1,1,1,1,1],
                    [1,0,0,1,0,0,1],
                    [1,0,0,1,0,0,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1]
                ],
                // "Spear"
                [
                    [0,0,0,1,0,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,1,1,1,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ],
                // "Pickaxe"
                [
                    [1,1,0,0,0,1,1],
                    [0,1,1,0,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ]
            ]
        };


        const LIQUID_DENSITY = {
            [MAT.ACID]: 3,
            [MAT.WATER]: 2,
            [MAT.OIL]: 1,
            [MAT.OIL_BURNING]: 1
        };

        const ALWAYS_VISIBLE_MATERIALS = new Set([
            MAT.RUNE_WALL,
            MAT.ADAMANTIUM // Also used for the alchemy station and world borders
        ]);

        const SHIMMERING_METALS = new Set([
            MAT.ADAMANTIUM,
            MAT.COPPER,
            MAT.SILVER,
            MAT.GOLD,
            MAT.PLATINUM,
            MAT.RUNE_WALL
        ]);

        // NEW: Materials that don't need to be simulated at the start of the game.
        const STATIC_MATERIALS = new Set([
            MAT.WALL,
            MAT.WOOD,
            MAT.GLASS_WALL,
            MAT.ADAMANTIUM,
            MAT.RUNE_WALL
        ]);


        const MAX_STEP_HEIGHT = 2;
        const GRAVITY = 0.1;
        const MAX_FALL_SPEED = 4;
        const MAX_HOVER_SPEED = 2;

        const MAX_CHUNKS_PER_FRAME = 250; // Max number of off-screen chunks to process per frame. On-screen chunks are always processed.
        let pendingActiveChunks = []; // An array to hold active chunks that were deferred from the previous frame.
        
        let grid = new Uint8Array(worldWidth * worldHeight).fill(MAT.EMPTY);
        let ignitionTimer = new Uint8Array(worldWidth * worldHeight);
        let currentMaterial = MAT.SAND;
        let isDrawing = false;
        let isStoring = false;
        let frameCount = 0;
        let playerFacingRight = true;
		let projectiles = [];
        let alchemyJobs = [];

        let lightGrid = new Uint8Array(worldWidth * worldHeight).fill(0); // 0 = black, 15 = brightest
        const MAX_LIGHT_LEVEL = 15;
        const LIGHTING_UPDATE_INTERVAL = 30; // Update lighting every 30 frames

        const MAX_VISIBLE_DISTANCE = 8;

        // --- Magic Particle System ---
        const MAX_MAGIC_PARTICLES = 5000;
        const magicParticlePool = [];
        for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
            magicParticlePool.push({ x: 0, y: 0, vx: 0, vy: 0, lifespan: 0, color: [0,0,0], active: false });
        }

        let magicEmitters = [];
        let nextEmitterId = 0;
        let firePixelsCoords = [];
        let triggers = [];
        let nextTriggerId = 0;
        let isAlchemyUIVisible = false;

        let lastFpsTime = performance.now();
        let framesThisSecond = 0;
        let fps = 0;
        let leftToRight = true;

        let hudFPS = 0;
        let hudMaterial = '--';
        let hudTimer = 0;

        let skyImageData = null;

        // --- INVENTORY AND CONTAINERS ---
        const pouchWidth = 32;
        const pouchHeight = 32;
        const flaskWidth = 24;
        const flaskHeight = 40;

        let pouchGrid = new Array(pouchWidth * pouchHeight).fill(MAT.EMPTY);
        let flaskGrid = new Array(flaskWidth * flaskHeight).fill(MAT.EMPTY);

        let activeContainer = 'pouch'; // 'pouch' or 'flask'
        let isPouring = false;
        let pourCooldown = 0;
        let pouredParticles = []; // For the pouring stream effect

        const STORABLE_SOLIDS = new Set([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM]);
        const STORABLE_LIQUIDS = new Set([MAT.WATER, MAT.OIL, MAT.ACID]);

        function initializeChunks() {
            chunkWidth = Math.ceil(worldWidth / CHUNK_SIZE);
            chunkHeight = Math.ceil(worldHeight / CHUNK_SIZE);
            chunkGrid = new Array(chunkWidth * chunkHeight);

            for (let i = 0; i < chunkGrid.length; i++) {
                chunkGrid[i] = { index: i }; 
            }

            // Only activate chunks containing DYNAMIC materials.
            for (let y = 0; y < worldHeight; y++) {
                for (let x = 0; x < worldWidth; x++) {
                    const type = grid[getIdx(x, y)];
                    // If the material is not empty AND not static, then activate its chunk.
                    if (type !== MAT.EMPTY && !STATIC_MATERIALS.has(type)) {
                        activateChunkAt(x, y);
                    }
                }
            }
        }

        function setGrid(idx, type) {
            if (idx === -1) return;

            const oldType = grid[idx];
            if (type === oldType) return;

            // The 'lightingNeedsUpdate = true' line has been REMOVED from here.
            
            grid[idx] = type;

            const x = idx % worldWidth;
            const y = Math.floor(idx / worldWidth);
            activateChunkAt(x, y);
        }

        /**
         * Activates the chunk at the given world coordinates, as well as its 8 neighbors.
         * This ensures interactions across chunk borders are always simulated.
         */
        function activateChunkAt(worldX, worldY) {
            const chunkX = Math.floor(worldX / CHUNK_SIZE);
            const chunkY = Math.floor(worldY / CHUNK_SIZE);

            // Activate the 3x3 grid of chunks around the target
            for (let cy = chunkY - 1; cy <= chunkY + 1; cy++) {
                for (let cx = chunkX - 1; cx <= chunkX + 1; cx++) {
                    if (cx >= 0 && cx < chunkWidth && cy >= 0 && cy < chunkHeight) {
                        const chunkIndex = cy * chunkWidth + cx;
                        nextActiveChunks.add(chunkGrid[chunkIndex]);
                    }
                }
            }
        }

        /**
         * A self-contained Perlin Noise generator object.
         * Based on the original implementation by Ken Perlin.
         */
        const PerlinNoise = {
            p: [],
            seed: function(s) {
                // Use a seeded PRNG to ensure the permutation table is the same for a given seed.
                let random = (function() {
                    let seed = s;
                    return function() {
                        seed = (seed * 9301 + 49297) % 233280;
                        return seed / 233280;
                    };
                })();
                
                this.p = new Uint8Array(512);
                let permutation = [];
                for (let i = 0; i < 256; i++) {
                    permutation.push(i);
                }
                // Shuffle permutation table
                for (let i = permutation.length - 1; i > 0; i--) {
                    const j = Math.floor(random() * (i + 1));
                    [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
                }
                // Duplicate the permutation table to avoid buffer overflows
                for (let i = 0; i < 256; i++) {
                    this.p[i] = this.p[i + 256] = permutation[i];
                }
            },
            fade: function(t) { return t * t * t * (t * (t * 6 - 15) + 10); },
            lerp: function(t, a, b) { return a + t * (b - a); },
            grad: function(hash, x, y, z) {
                let h = hash & 15;
                let u = h < 8 ? x : y,
                    v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            },
            noise: function(x, y, z = 0) {
                let X = Math.floor(x) & 255,
                    Y = Math.floor(y) & 255,
                    Z = Math.floor(z) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                let u = this.fade(x),
                    v = this.fade(y),
                    w = this.fade(z);
                let A = this.p[X] + Y, AA = this.p[A] + Z, AB = this.p[A + 1] + Z,
                    B = this.p[X + 1] + Y, BA = this.p[B] + Z, BB = this.p[B + 1] + Z;

                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z),
                                                              this.grad(this.p[BA], x - 1, y, z)),
                                                      this.lerp(u, this.grad(this.p[AB], x, y - 1, z),
                                                              this.grad(this.p[BB], x - 1, y - 1, z))),
                                       this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
                                                              this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                                                      this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),
                                                              this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));
            }
        };

        /**
         * Generates a high-quality, themed, multi-layered cave interior background.
         * This version is correctly tuned to generate patterns across the full worldWidth.
         */
        function generateCaveBackground(width, height) {
            const img = ctx.createImageData(width, height);
            const d = img.data;
            const layerHeight = height / 5;
            const transitionSize = 40;

            PerlinNoise.seed(1337);

            const hash = (x, y, s = 0) => { /* ... */ };
            const lerp = (a, b, t) => a + (b - a) * t;
            const lerpColor = (c1, c2, t) => [lerp(c1[0],c2[0],t), lerp(c1[1],c2[1],t), lerp(c1[2],c2[2],t)];

            // --- RE-TUNED Layer Generators ---
            const getSandCaveColor = (x, y) => {
                const n1 = PerlinNoise.noise(x * 0.004, y * 0.02); // x freq adjusted
                const n2 = PerlinNoise.noise(x * 0.016, y * 0.08); // x freq adjusted
                const baseNoise = (n1 + n2 * 0.25) / 1.25;
                let c = lerpColor([80, 60, 40], [60, 45, 30], (baseNoise + 1) / 2);
                const ripple = Math.sin(y * 0.1 + PerlinNoise.noise(x * 0.002, y * 0.05) * 5); // x freq adjusted
                c = lerpColor(c, [90, 70, 50], (ripple + 1) / 2 * 0.1);
                return c;
            };
            const getCoalMineColor = (x, y) => {
                const n1 = PerlinNoise.noise(x * 0.01, y * 0.05); // x freq adjusted
                const n2 = PerlinNoise.noise(x * 0.04, y * 0.2); // x freq adjusted
                let c = lerpColor([28, 25, 25], [12, 10, 10], (n1 + n2 * 0.3) / 1.3);
                const seamNoise = PerlinNoise.noise(x * 0.001, y * 0.15); // x freq adjusted
                const seamFactor = Math.pow(Math.abs(seamNoise), 3) * 2;
                if (seamFactor > 0.4) { c = lerpColor(c, [0, 0, 0], Math.min(1, (seamFactor - 0.4) * 2)); }
                return c;
            };
            const getVolcanicColor = (x, y) => {
                let c = lerpColor([30, 10, 5], [10, 5, 2], PerlinNoise.noise(x * 0.02, y * 0.1)); // x freq adjusted
                const crackle = Math.abs(PerlinNoise.noise(x * 0.006, y * 0.03) * 2); // x freq adjusted
                if (crackle > 0.9) { const glow = (crackle - 0.9) * 10; const glowColor = lerpColor([255, 180, 0], [255, 60, 0], crackle); c = lerpColor(c, glowColor, glow); }
                return c;
            };
            const getLabyrinthColor = (x, y) => {
                const gx = Math.floor(x / 24); const gy = Math.floor(y / 24);
                let c = hash(gx, gy) > 128 ? [50, 55, 60] : [40, 45, 50];
                const grain = PerlinNoise.noise(x * 0.06, y * 0.3) * 10; // x freq adjusted
                c = [c[0] + grain, c[1] + grain, c[2] + grain];
                const isEdgeX = x % 24 < 1 || x % 24 > 22; const isEdgeY = y % 24 < 1 || y % 24 > 22;
                if (isEdgeX || isEdgeY) { c = [c[0] * 0.7, c[1] * 0.7, c[2] * 0.7]; }
                return c;
            };
            const getMagicDungeonColor = (x, y) => {
                const n1 = PerlinNoise.noise(x * 0.0016, y * 0.008); // x freq adjusted
                const n2 = PerlinNoise.noise(x * 0.006, y * 0.03); // x freq adjusted
                let c = lerpColor([20, 5, 40], [40, 15, 60], (n1 + n2 * 0.3) / 1.3);
                const crystalNoise = Math.abs(PerlinNoise.noise(x * 0.01, y * 0.05) * 1.5); // x freq adjusted
                if (crystalNoise > 0.95) { const glow = (crystalNoise - 0.95) * 20; c = lerpColor(c, [180, 150, 255], glow); }
                if (hash(x, y, 1) > 254) c = [220, 220, 255];
                return c;
            };
            const layerFunctions = [getSandCaveColor, getCoalMineColor, getVolcanicColor, getLabyrinthColor, getMagicDungeonColor];

            // Main Pixel Loop
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const layerIndex = Math.min(layerFunctions.length - 1, Math.floor(y / layerHeight));
                    const yInLayer = y % layerHeight;
                    let color;
                    if (layerIndex > 0 && yInLayer < transitionSize) {
                        const t = yInLayer / transitionSize;
                        color = lerpColor(layerFunctions[layerIndex-1](x,y), layerFunctions[layerIndex](x,y), t);
                    } else {
                        color = layerFunctions[layerIndex](x, y);
                    }
                    const i = (y * width + x) * 4;
                    d[i]=color[0]; d[i+1]=color[1]; d[i+2]=color[2]; d[i+3]=255;
                }
            }
            return img;
        }

        // --- PLAYER AND CAMERA ---
        const player = {
            x: 30, y: 80, vx: 0, vy: 0,
            width: 8, height: 16, speed: 1, onGround: false,
            canInteract: false,
            currentTrigger: null,
            maxHoverEnergy: 100,
            hoverEnergy: 100,
            hoverForce: 0.25,      // Upward force, must be > GRAVITY to ascend
            hoverDrainRate: 0.5,     // Energy used per frame of hovering
            hoverRechargeRate: 1, // Energy recovered per frame when not hovering
            maxHp: 100,
            hp: 100
        };
        const camera = { x: player.x - viewWidth / 2, y: 0 };
		const mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };
        
        // --- INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', (e) => {
            // If the UI is open, input is handled differently
            if (isAlchemyUIVisible) {
                if (e.code === 'Escape') {
                    isAlchemyUIVisible = false;
                }
                // Check if a number key was pressed
                if (e.code.startsWith('Digit')) {
                    const index = parseInt(e.code.replace('Digit', ''), 10) - 1;
                    const reactionKeys = Object.keys(ALCHEMY_REACTIONS);
                    if (index >= 0 && index < reactionKeys.length) {
                        const reactionKey = reactionKeys[index];
                        // Pass the station's geometry to the execute function
                        ALCHEMY_REACTIONS[reactionKey].execute(player.currentTrigger.associatedData.stationGeometry);
                        isAlchemyUIVisible = false; // Close UI after executing
                    }
                }
                return; // Stop further input processing
            }

            keys[e.code] = true;

            if (e.code === 'KeyQ') {
                activeContainer = activeContainer === 'pouch' ? 'flask' : 'pouch';
            }

            if (e.code === 'KeyE') {
                // Check if the player is currently in a trigger zone
                if (player.canInteract && player.currentTrigger) {
                    // Fire the specific trigger's onInteract function
                    player.currentTrigger.onInteract(player.currentTrigger);
                }
            }
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        function setMaterial(name) {
            const map = {
                sand: MAT.SAND, water: MAT.WATER, oil: MAT.OIL, coal: MAT.COAL,
                soil: MAT.SOIL, wall: MAT.WALL, gas: MAT.GAS, wood: MAT.WOOD,
                fire: MAT.FIRE, gunpowder: MAT.GUNPOWDER, acid: MAT.ACID,
                glass: MAT.GLASS, 'glass-wall': MAT.GLASS_WALL, empty: MAT.EMPTY,
                adamantium: MAT.ADAMANTIUM, copper: MAT.COPPER, silver: MAT.SILVER,
                gold: MAT.GOLD, platinum: MAT.PLATINUM,
                'rune-wall': MAT.RUNE_WALL
            };

            if (map[name] === undefined) {
                console.warn('Unknown material:', name);
                return;
            }

            currentMaterial = map[name];

            document.querySelectorAll('.controls button')
                .forEach(btn => btn.classList.remove('active'));

            const btn = document.querySelector(`.btn-${name}`);
            if (btn) btn.classList.add('active');
        }

        function isFlammable(type) {
            return (
                type === MAT.WOOD ||
                type === MAT.GUNPOWDER ||
                type === MAT.OIL ||
                type === MAT.COAL
            );
        }

        const LIQUIDS = new Set([
            MAT.WATER,
            MAT.OIL,
            MAT.OIL_BURNING,
            MAT.ACID
        ]);

        function tryIgniteAt(x, y, probability = 1.0) {
            const idx = getIdx(x, y);
            if (idx === -1) return;

            const type = grid[idx];

            if (!isFlammable(type)) return;
            if (Math.random() > probability) return;

            switch (type) {
                case MAT.GUNPOWDER:
                    setGrid(idx, MAT.GUNPOWDER_IGNITED);
                    ignitionTimer[idx] = 3 + Math.floor(Math.random() * 5);
                    break;

                case MAT.OIL:
                    setGrid(idx, MAT.OIL_BURNING);
                    break;

                case MAT.COAL:
                    setGrid(idx, MAT.COAL_BURNING);
                    break;

                case MAT.WOOD:
                    setGrid(idx, MAT.FIRE);
                    break;
            }
        }


        const getMousePos = (evt) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = evt.clientX - rect.left;
            mouse.y = evt.clientY - rect.top;
        };

        function draw(x, y) {
            const brushSize = 10; // Scaled brush size
            const r = Math.floor(brushSize / 2);
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (dx*dx + dy*dy <= r*r) {
                        const px = x + dx; const py = y + dy;
                        const idx = getIdx(px, py);
                        if (idx !== -1 && grid[idx] !== MAT.WALL) {
                            setGrid(idx, currentMaterial);
                            activateChunkAt(px, py);
                        }
                    }
                }
            }
        }
        canvas.addEventListener('mousemove', getMousePos);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { isPouring = true; } // Left-click to pour
            else if (e.button === 1) { isDrawing = true; draw(mouse.worldX, mouse.worldY); e.preventDefault(); } // Middle-click to draw
            else if (e.button === 2) { 
                isStoring = true; // Set storing state to true
                storeMaterial(mouse.worldX, mouse.worldY); // Store immediately on click
            } 
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) isPouring = false;
            if (e.button === 1) isDrawing = false;
            if (e.button === 2) isStoring = false; // Set storing state to false
        });

        canvas.addEventListener('mousemove', (e) => {
             if (isDrawing) draw(mouse.worldX, mouse.worldY);
        });

        // --- CORE PHYSICS ENGINE ---
        const getIdx = (x, y, w = worldWidth, h = worldHeight) => {
            x = Math.floor(x);
            y = Math.floor(y);
            if (x < 0 || x >= w || y < 0 || y >= h) return -1;
            return y * w + x;
        };

        const isSolidForPlayer = (type) => [
            MAT.WALL, MAT.SOIL, MAT.WOOD, MAT.SAND, 
            MAT.GUNPOWDER, MAT.COAL, MAT.COAL_BURNING, MAT.GLASS, 
            MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.COPPER, MAT.SILVER, 
            MAT.GOLD, MAT.PLATINUM, MAT.RUNE_WALL
        ].includes(type);

        function collidesAt(x, y) {
            for (let iy = 0; iy < player.height; iy++) {
                for (let ix = 0; ix < player.width; ix++) {
                    const idx = getIdx(Math.floor(x + ix), Math.floor(y + iy));
                    if (idx !== -1 && isSolidForPlayer(grid[idx])) {
                        return true;
                    }
                }
            }
            return false;
        }

        function collidesAtSides(x, y, dir) {
            const edgeX = dir > 0
                ? Math.floor(x + player.width - 1) // right edge
                : Math.floor(x);                   // left edge

            for (let iy = 0; iy < player.height - 1; iy++) { // ignore feet
                const idx = getIdx(edgeX, Math.floor(y + iy));
                if (idx !== -1 && isSolidForPlayer(grid[idx])) {
                    return true;
                }
            }
            return false;
        }

        function updatePlayer() {
            if (isAlchemyUIVisible) {
                player.vx = 0; // Prevent sliding
                return;
            }

            const wasOnGround = player.onGround;

            // --- 1. APPLY FORCES TO VELOCITY ---
            // Horizontal input
            if (keys['KeyA']) {
                player.vx = -player.speed;
                playerFacingRight = false;
            } else if (keys['KeyD']) {
                player.vx = player.speed;
                playerFacingRight = true;
            } else {
                player.vx = 0;
            }

            // Levitation and Energy
            if (keys['KeyW'] && player.hoverEnergy > 0) {
                player.vy -= player.hoverForce;
                player.hoverEnergy = Math.max(0, player.hoverEnergy - player.hoverDrainRate);
                spawnLevitationParticles(2);
            } else {
                if (player.hoverEnergy < player.maxHoverEnergy && player.onGround) {
                    player.hoverEnergy = Math.min(player.maxHoverEnergy, player.hoverEnergy + player.hoverRechargeRate);
                }
            }
            
            // Gravity and Velocity Clamping
            player.vy += GRAVITY;
            if (player.vy > MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED;
            if (player.vy < -MAX_HOVER_SPEED) player.vy = -MAX_HOVER_SPEED;


            // --- 2. RESOLVE HORIZONTAL MOVEMENT AND COLLISIONS FIRST ---
            let nextX = player.x + player.vx;
            if (player.vx !== 0) {
                if (!collidesAtSides(nextX, player.y, Math.sign(player.vx))) {
                    player.x = nextX;
                } else {
                    // Wall collision detected. Can we step up?
                    // The step-up is now part of the horizontal check.
                    let couldStepUp = false;
                    if (wasOnGround) { // Only allow stepping from the ground
                        for (let step = 1; step <= MAX_STEP_HEIGHT; step++) {
                            const stepY = player.y - step;
                            if (!collidesAt(player.x, stepY) && !collidesAtSides(nextX, stepY, Math.sign(player.vx))) {
                                player.y = stepY;
                                player.x = nextX;
                                couldStepUp = true;
                                break;
                            }
                        }
                    }
                    // If we hit a wall and couldn't step, stop horizontal movement.
                    if (!couldStepUp) {
                        player.vx = 0;
                    }
                }
            }


            // --- 3. RESOLVE VERTICAL MOVEMENT AND COLLISIONS SECOND ---
            // By now, player.x is final for this frame.
            let nextY = player.y + player.vy;
            player.onGround = false;

            if (!collidesAt(player.x, nextY)) {
                player.y = nextY;
            } else {
                const dir = Math.sign(player.vy);

                if (!collidesAt(player.x, player.y + dir)) {
                    player.y += dir;
                }

                // If we collided while moving down, we are on the ground.
                if (dir > 0) {
                    player.onGround = true;
                }
                
                // Stop vertical movement upon collision.
                player.vy = 0;
            }
        }

        /**
         * Scans a 3x3 area in the world and teleports valid materials into the correct container.
         */
        function storeMaterial(worldX, worldY) {
            const storeRadius = 1; // Creates a 3x3 area
            for (let dy = -storeRadius; dy <= storeRadius; dy++) {
                for (let dx = -storeRadius; dx <= storeRadius; dx++) {
                    const wx = worldX + dx;
                    const wy = worldY + dy;
                    const worldIdx = getIdx(wx, wy, worldWidth, worldHeight);
                    if (worldIdx === -1) continue;

                    const type = grid[worldIdx];
                    let targetGrid, targetW, targetH;

                    if (STORABLE_SOLIDS.has(type)) {
                        targetGrid = pouchGrid; targetW = pouchWidth; targetH = pouchHeight;
                    } else if (STORABLE_LIQUIDS.has(type)) {
                        targetGrid = flaskGrid; targetW = flaskWidth; targetH = flaskHeight;
                    } else {
                        continue; // Can't store this type
                    }

                    // NEW: Scan from the top of the container downwards, across the full width, to find an empty spot.
                    let spotFound = false;
                    for (let y = 0; y < targetH; y++) {
                        // Start scanning at a random x-offset each time to prevent filling bias on one side.
                        const xOffset = Math.floor(Math.random() * targetW);
                        for (let i = 0; i < targetW; i++) {
                            const x = (i + xOffset) % targetW; // Loop through all x-coordinates
                            
                            const containerIdx = getIdx(x, y, targetW, targetH);
                            if (containerIdx !== -1 && targetGrid[containerIdx] === MAT.EMPTY) {
                                targetGrid[containerIdx] = type; // Place material
                                setGrid(worldIdx, MAT.EMPTY);      // Remove from world
                                spotFound = true;
                                break; // Exit inner x-loop
                            }
                        }
                        if (spotFound) {
                            break; // Exit outer y-loop
                        }
                    }
                }
            }
        }

        /**
         * Takes one particle from the bottom of the active container and adds it to the pouredParticles array.
         */
        function pourFromContainer() {
            const [containerGrid, containerW, containerH] = activeContainer === 'pouch'
                ? [pouchGrid, pouchWidth, pouchHeight]
                : [flaskGrid, flaskWidth, flaskHeight];

            // NEW: Variables to control how many particles are poured each frame
            const maxPourPerFrame = 3; 
            let pouredCount = 0;

            // Find particles at the bottom to pour
            for (let y = containerH - 1; y >= 0; y--) {
                for (let i = 0; i < containerW; i++) {
                    // Scan from the center outwards
                    const x = Math.floor(containerW / 2) + (i % 2 === 0 ? 1 : -1) * Math.floor(i / 2);
                    const idx = getIdx(x, y, containerW, containerH);
                    const type = containerGrid[idx];

                    if (type !== MAT.EMPTY && type !== MAT.GAS) { // Cannot pour gas
                        containerGrid[idx] = MAT.EMPTY; // Remove from container

                        // --- Start of Noita-style Variance Logic ---

                        // 1. Add variance to spawn position
                        const baseSpawnX = player.x + (playerFacingRight ? player.width : 0);
                        const baseSpawnY = player.y + 9;
                        const spawnOffsetX = (Math.random() - 0.5) * 2; 
                        const spawnOffsetY = (Math.random() - 0.5) * 2; 
                        const finalSpawnX = baseSpawnX + spawnOffsetX;
                        const finalSpawnY = baseSpawnY + spawnOffsetY;

                        // 2. Add variance to the angle (spread)
                        const baseAngle = Math.atan2(mouse.worldY - finalSpawnY, mouse.worldX - finalSpawnX);
                        const spread = 0.05; // CHANGED: Reduced from 0.25 to make the stream tighter
                        const finalAngle = baseAngle + (Math.random() - 0.5) * spread;

                        // 3. Add variance to the velocity
                        const baseVelocity = 4.0;
                        const velocityVariance = 0.5;
                        const finalVelocity = baseVelocity + (Math.random() - 0.5) * velocityVariance;

                        // --- End of Noita-style Variance Logic ---

                        pouredParticles.push({
                            x: finalSpawnX, 
                            y: finalSpawnY,
                            vx: Math.cos(finalAngle) * finalVelocity,
                            vy: Math.sin(finalAngle) * finalVelocity,
                            type: type
                        });
                        
                        pouredCount++;
                        if (pouredCount >= maxPourPerFrame) {
                           return; // Exit after pouring the max number of particles
                        }
                    }
                }
            }
        }

        /**
         * Updates the position and state of all particles currently being poured.
         */
        function updatePouredParticles() {
            pouredParticles = pouredParticles.filter(p => {
                // Apply gravity
                p.vy += GRAVITY * 0.5;

                // 1. Calculate the particle's potential next position
                const nextX = p.x + p.vx;
                const nextY = p.y + p.vy;
                const nextIX = Math.floor(nextX);
                const nextIY = Math.floor(nextY);

                const worldIdx = getIdx(nextIX, nextIY);
                
                // Check if the particle is about to go off-screen
                if (worldIdx === -1) {
                    return false; // Remove if it leaves the world
                }
                
                // 2. Check for an obstruction at that future position
                const isObstructed = grid[worldIdx] !== MAT.EMPTY && grid[worldIdx] !== MAT.GAS;
                const hasStopped = (p.vx * p.vx + p.vy * p.vy < 1.0);

                // 3. If a collision is predicted OR the particle has stopped, materialize it
                if (isObstructed || hasStopped) {
                    // THE FIX: Start the search from the particle's CURRENT, known-good position, not the invalid future one.
                    let placeX = Math.floor(p.x);
                    let placeY = Math.floor(p.y);
                    
                    // The upward search is still useful for stacking, but now starts from a safe location.
                    while (true) {
                        const checkIdx = getIdx(placeX, placeY);
                        
                        // Stop if we search off the top of the map
                        if (checkIdx === -1) {
                            break; 
                        }

                        // If we find an empty spot, place the material and we're done.
                        if (grid[checkIdx] === MAT.EMPTY || grid[checkIdx] === MAT.GAS) {
                            setGrid(checkIdx, p.type);
                            activateChunkAt(placeX, placeY);
                            break;
                        }
                        
                        // If the spot was taken, move up one pixel and try again.
                        placeY--;
                    }
                    
                    // The particle's journey is over. Remove it.
                    return false;
                } else {
                    // 4. If no collision is predicted, update the particle's position and keep it alive.
                    p.x = nextX;
                    p.y = nextY;
                    return true; 
                }
            });
        }

        function shootFire() {
            const projectileSpeed = 1.0; 
            
            // Calculate wand tip position in world coordinates for the larger sprite
            const wandTipX = player.x + (playerFacingRight ? player.width + 2 : -4);
            const wandTipY = player.y + 9; // Centered on the new wand vertically

            const angle = Math.atan2(mouse.worldY - wandTipY, mouse.worldX - wandTipX);
            projectiles.push({
                x: wandTipX, y: wandTipY,
                vx: Math.cos(angle) * projectileSpeed, vy: Math.sin(angle) * projectileSpeed
            });
        }
		
		function updateProjectiles() {
            projectiles = projectiles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                const idx = getIdx(p.x, p.y);
                if (idx === -1) return false; 
                if (grid[idx] !== MAT.EMPTY) {
                    setGrid(idx, MAT.FIRE); return false;
                }
                return true;
            });
        }

        const movedWorld = new Uint8Array(worldWidth * worldHeight);
        const movedPouch = new Uint8Array(pouchWidth * pouchHeight);
        const movedFlask = new Uint8Array(flaskWidth * flaskHeight);
        
        /**
         * Runs the simulation on the main world grid using the active chunk optimization.
         */
        function runWorldSimulationWithChunks(moved) {
            moved.fill(0);
            const localGetIdx = (x, y) => getIdx(x, y, worldWidth, worldHeight);
            const scanDir = (frameCount % 2 === 0);
            
            // For the main world, the "setter" is the original setGrid function.
            const setter = setGrid; 

            for (const chunk of activeChunks) {
                const chunkX = chunk.index % chunkWidth;
                const chunkY = Math.floor(chunk.index / chunkWidth);
                const startX = chunkX * CHUNK_SIZE;
                const startY = chunkY * CHUNK_SIZE;
                const endX = startX + CHUNK_SIZE;
                const endY = startY + CHUNK_SIZE;

                // PASS 1: solids, gas, fire
                for (let y = endY - 1; y >= startY; y--) {
                    for (let x = (scanDir ? startX : endX - 1); (scanDir ? x < endX : x >= startX); x += (scanDir ? 1 : -1)) {
                        stepNonLiquid(x, y, moved, grid, worldWidth, worldHeight, localGetIdx, setter);
                    }
                }

                // PASS 2: liquids
                for (let y = endY - 1; y >= startY; y--) {
                    for (let x = (scanDir ? startX : endX - 1); (scanDir ? x < endX : x >= startX); x += (scanDir ? 1 : -1)) {
                        stepLiquid(x, y, moved, grid, worldWidth, worldHeight, localGetIdx, setter);
                    }
                }
            }
        }

        /**
         * Runs the simulation on a small, self-contained grid like the pouch or flask.
         */
        function runSimulationOnSmallGrid(moved, currentGrid, gridWidth, gridHeight) {
             moved.fill(0);
             const localGetIdx = (x, y) => getIdx(x, y, gridWidth, gridHeight);
             const scanDir = (frameCount % 2 === 0);

             // For sub-grids, the "setter" is a simple function that modifies the provided grid directly.
             const setter = (idx, type) => {
                if (idx !== -1) currentGrid[idx] = type;
             };

            // PASS 1: solids, gas, fire
            for (let y = gridHeight - 1; y >= 0; y--) {
                 for (let x = (scanDir ? 0 : gridWidth - 1); (scanDir ? x < gridWidth : x >= 0); x += (scanDir ? 1 : -1)) {
                    stepNonLiquid(x, y, moved, currentGrid, gridWidth, gridHeight, localGetIdx, setter);
                }
            }

            // PASS 2: liquids
            for (let y = gridHeight - 1; y >= 0; y--) {
                 for (let x = (scanDir ? 0 : gridWidth - 1); (scanDir ? x < gridWidth : x >= 0); x += (scanDir ? 1 : -1)) {
                    stepLiquid(x, y, moved, currentGrid, gridWidth, gridHeight, localGetIdx, setter);
                }
            }
        }

        function stepAll(x, y, moved) {
            const idx = getIdx(x, y);
            if (idx === -1 || moved[idx]) return;

            const type = grid[idx];
            if ([MAT.EMPTY, MAT.WALL, MAT.WOOD].includes(type)) return;
            if (type === MAT.WATER) updateLiquid(x, y, idx, moved);
            if (type === MAT.FIRE) updateFire(x, y, idx, moved);
            else if ([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER].includes(type))
                updateSolid(x, y, idx, type, moved);
            else if (type === MAT.GAS) updateGas(x, y, idx, moved);
            else if (type >= 20) updateSource(x, y, idx, type);
        }

        function stepNonLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const idx = getIdx(x, y); 
            if (idx === -1 || moved[idx]) return;
            const type = grid[idx];
            if ([MAT.EMPTY, MAT.WALL, MAT.WOOD, MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.RUNE_WALL].includes(type) || LIQUIDS.has(type)) return;

            if (type === MAT.FIRE) updateFire(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if ([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.COAL_BURNING, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM].includes(type)) updateSolid(x, y, idx, type, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.COAL_BURNING) updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.GAS) updateGas(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.GUNPOWDER_IGNITED) updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter);
        }

        function stepLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const idx = getIdx(x, y, w, h);
            if (idx === -1 || moved[idx]) return;
            if (![MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.ACID].includes(grid[idx])) return;

            updateLiquid(x, y, idx, moved, grid, w, h, getIdx, setter);
        }


        function updateCamera() {
            // Follow player on X-axis
            const targetCamX = player.x - viewWidth / 2;
            camera.x += (targetCamX - camera.x) * 0.1;

            // Follow player on Y-axis
            const targetCamY = player.y - viewHeight / 2;
            camera.y += (targetCamY - camera.y) * 0.1;

            // Clamp camera to world bounds
            if (camera.x < 0) camera.x = 0;
            if (camera.x > worldWidth - viewWidth) camera.x = worldWidth - viewWidth;
            if (camera.y < 0) camera.y = 0;
            if (camera.y > worldHeight - viewHeight) camera.y = worldHeight - viewHeight;
        }

        function updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter) {
            ignitionTimer[idx]--;

            for (let n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                const nIdx = getIdx(x + n.x, y + n.y);
                if (Math.random() < 0.35) {
                    if (nIdx !== -1 && grid[nIdx] === MAT.GUNPOWDER) {
                        setter(nIdx, MAT.GUNPOWDER_IGNITED);
                        ignitionTimer[nIdx] = 8 + Math.floor(Math.random() * 6);
                    }
                }
            }

            if (ignitionTimer[idx] <= 0) {
                setter(idx, MAT.EMPTY);
                // Explosions only happen in the main world, so we can still call setGrid here.
                if (setter === setGrid) triggerExplosion(x, y, 6);
            }
        }

        function triggerExplosion(centerX, centerY, radius) {
            const maxRadius = 100; // Scaled max radius
            if (radius > maxRadius) radius = maxRadius;
            const rSquared = radius * radius;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx*dx + dy*dy > rSquared) continue;
                    const ex = Math.floor(centerX + dx);
                    const ey = Math.floor(centerY + dy);
                    const idx = getIdx(ex, ey);
                    if (idx === -1 || ex === 0 || ex === worldWidth - 1 || ey === 0 || ey === worldHeight - 1) continue;
                    
                    if (grid[idx] !== MAT.WALL && grid[idx] !== MAT.ADAMANTIUM) {
                        const rand = Math.random();
                        if (rand < 0.3) setGrid(idx, MAT.FIRE);
                        else if (rand < 0.7) setGrid(idx, MAT.GAS); 
                        else setGrid(idx, MAT.EMPTY);
                    } else if (radius > 20 && Math.random() < 0.5) { // Scaled check
                        setGrid(idx, MAT.GAS);
                    }
                }
            }
        }

        function explodeCluster(startX, startY) {
            let queue = [{x: startX, y: startY}];
            let cluster = [{x: startX, y: startY}]; 
            let visited = new Set([`${startX},${startY}`]);
            setGrid(getIdx(startX, startY), MAT.EMPTY);
            let iterations = 0; const maxIterations = 3000;
            while (queue.length > 0 && iterations++ < maxIterations) {
                let current = queue.shift();
                for (let d of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                    const nx = current.x + d.x, ny = current.y + d.y;
                    const key = `${nx},${ny}`;
                    const nIdx = getIdx(nx, ny);
                    if (nIdx !== -1 && !visited.has(key) && grid[nIdx] === MAT.GUNPOWDER) {
                        visited.add(key); queue.push({x: nx, y: ny});
                        cluster.push({x: nx, y: ny}); setGrid(nIdx, MAT.EMPTY);
                    }
                }
            }
            let sumX = 0, sumY = 0;
            for (let p of cluster) { sumX += p.x; sumY += p.y; }
            triggerExplosion(sumX / cluster.length, sumY / cluster.length, 5 + Math.sqrt(cluster.length));
        }

        function updateFire(x, y, idx, moved, grid, w, h, getIdx, setter) {
            let nearbyFuel = false;
            for (let n of [{x:0,y:1},{x:0,y:1},{x:-1,y:0},{x:1,y:0},{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}]) {
                const nx = x + n.x, ny = y + n.y;
                const nIdx = getIdx(nx, ny);
                if (nIdx === -1) continue;
                const nType = grid[nIdx];

                if (nType === MAT.SAND && Math.random() < 0.05) setter(nIdx, MAT.GLASS);
                if (nType === MAT.GUNPOWDER && Math.random() < 0.5) {
                    setter(nIdx, MAT.GUNPOWDER_IGNITED);
                    ignitionTimer[nIdx] = 8 + Math.floor(Math.random() * 6);
                    return;
                }
                if (nType === MAT.OIL) { setter(nIdx, MAT.OIL_BURNING); return; }
                if (nType === MAT.COAL) { setter(nIdx, MAT.COAL_BURNING); return; }
                if (nType === MAT.WOOD) {
                    nearbyFuel = true;
                    if (Math.random() < 0.01) { setter(nIdx, MAT.FIRE); moved[nIdx] = 1; }
                }
                if (nType === MAT.WATER) { setter(nIdx, MAT.GAS); setter(idx, MAT.GAS); return; }
            }
            let targetIdx = idx;
            if (!nearbyFuel && y > 0) {
                let nextX = x, nextY = y - 1;
                if (Math.random() < 0.5) nextX += Math.random() < 0.5 ? -1 : 1;
                const nextIdx = getIdx(nextX, nextY);
                if (nextIdx !== -1 && (grid[nextIdx] === MAT.EMPTY || grid[nextIdx] === MAT.GAS)) {
                    setter(idx, grid[nextIdx]); setter(nextIdx, MAT.FIRE);
                    moved[nextIdx] = 1; targetIdx = nextIdx;
                }
            }
            if (Math.random() < (nearbyFuel ? 0.0 : 0.15)) setter(targetIdx, MAT.GAS);
        }

        function updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter) {
            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                const nx = x + n.x, ny = y + n.y;
                const nIdx = getIdx(nx, ny);
                if (nIdx === -1) continue;
                if (grid[nIdx] === MAT.SAND && Math.random() < 0.08) setter(nIdx, MAT.GLASS);
                // tryIgniteAt is world-only, so we check the setter
                if (setter === setGrid) tryIgniteAt(nx, ny, 0.02);
            }
            if (Math.random() < 0.02) {
                const aboveIdx = getIdx(x, y - 1);
                if (aboveIdx !== -1 && grid[aboveIdx] === MAT.EMPTY) setter(aboveIdx, MAT.FIRE);
            }
            if (Math.random() < 0.003) setter(idx, MAT.GAS);
            if (grid[idx] === MAT.COAL_BURNING && setter === setGrid) activateChunkAt(x, y);
        }
        
        function updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter) {
            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0},{x:1,y:1},{x:-1,y:1},{x:1,y:-1},{x:-1,y:-1}]) {
                const nx = x + n.x, ny = y + n.y;
                const nIdx = getIdx(nx, ny);
                if (nIdx === -1) continue;
                if (grid[nIdx] === MAT.SAND && Math.random() < 0.1) setter(nIdx, MAT.GLASS);
                if (setter === setGrid) tryIgniteAt(nx, ny, 0.05);
            }
            if (Math.random() < 0.05) {
                const aboveIdx = getIdx(x, y - 1);
                if (aboveIdx !== -1 && grid[aboveIdx] === MAT.EMPTY) setter(aboveIdx, MAT.FIRE);
            }
            if (Math.random() < 0.008) setter(idx, MAT.GAS);
            if (grid[idx] === MAT.OIL_BURNING && setter === setGrid) activateChunkAt(x, y);
        }

        function updateSolid(x, y, idx, type, moved, grid, w, h, getIdx, setter) {
            const belowIdx = getIdx(x, y + 1);
            if (belowIdx === -1) return;
            if (type === MAT.COAL_BURNING) {updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter)}
            if (grid[belowIdx] === MAT.FIRE && type === MAT.COAL) {
                setter(idx, MAT.COAL_BURNING);
                return;
            }
            const below = grid[belowIdx];
            if ([MAT.EMPTY, MAT.GAS].includes(below)) {
                setter(idx, below); setter(belowIdx, type); moved[belowIdx] = 1; return;
            }
            if (isLiquid(below)) {
                setter(idx, below); setter(belowIdx, type); moved[belowIdx] = 1; return;
            }
            const dir = Math.random() < 0.5 ? -1 : 1;
            for (let dx of [dir, -dir]) {
                const dIdx = getIdx(x + dx, y + 1);
                if (dIdx !== -1 && [MAT.EMPTY, MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.GAS, MAT.FIRE, MAT.ACID].includes(grid[dIdx])) {
                    setter(idx, grid[dIdx]); setter(dIdx, type); moved[dIdx] = 1; return;
                }
            }
        }

        function isLiquid (type) {
            return LIQUIDS.has(type);
        }

        function updateLiquid(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const type = grid[idx];
            if (type === MAT.ACID) {
                let consumed = false;
                for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                    const nIdx = getIdx(x + n.x, y + n.y);
                    if (nIdx === -1) continue;
                    const nType = grid[nIdx];
                    const isImmune = [MAT.EMPTY, MAT.GLASS, MAT.GAS, MAT.GLASS_WALL, MAT.ADAMANTIUM].includes(nType);
                    if (!isImmune && !isLiquid(nType) && Math.random() < 0.25) {
                        setter(nIdx, MAT.EMPTY);
                        if (Math.random() < 0.1) { setter(idx, MAT.EMPTY); consumed = true; break; }
                    }
                }
                if (consumed) { moved[idx] = 1; return; }
            }
            const belowIdx = getIdx(x, y + 1);
            if (belowIdx === -1) return;
            if (grid[belowIdx] === MAT.FIRE) {
                if (grid[idx] === MAT.OIL) setter(idx, MAT.OIL_BURNING);
                else { setter(idx, MAT.GAS); setter(belowIdx, MAT.GAS); }
                return;
            }
            const below = grid[belowIdx];
            if ([MAT.EMPTY, MAT.GAS].includes(below)) {
                setter(idx, below); setter(belowIdx, type); moved[belowIdx] = 1; return;
            }
            if (LIQUID_DENSITY[type] > LIQUID_DENSITY[below]) {
                setter(idx, below); setter(belowIdx, type); moved[belowIdx] = 1; return;
            }
            tryMoveLiquidSide(x, y, idx, type, moved, Math.random() < 0.5 ? -1 : 1, 20, 1, grid, w, h, getIdx, setter);
            if (grid[idx] === MAT.OIL_BURNING) updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter);
        }

        function updateGas(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const aboveIdx = getIdx(x, y - 1);
            if (y === 0) { setter(idx, MAT.EMPTY); return; }
            const above = grid[aboveIdx];
            if ([MAT.EMPTY, MAT.WATER, MAT.SAND, MAT.SOIL, MAT.GUNPOWDER].includes(above)) {
                setter(idx, above); setter(aboveIdx, MAT.GAS); moved[aboveIdx] = 1;
                return;
            }
            tryMoveLiquidSide(x, y, idx, MAT.GAS, moved, Math.random() < 0.5 ? -1 : 1, 4, -1, grid, w, h, getIdx, setter);
        }

        function tryMoveLiquidSide(x, y, currentIdx, type, moved, dir, limit, vDir, grid, w, h, getIdx, setter) {
            let targetX = x;
            const movableMaterials = [MAT.EMPTY, MAT.GAS, MAT.FIRE];
            const allMovableMaterials = [...LIQUIDS, ...movableMaterials];
            for (let i = 1; i <= limit; i++) {
                const nextX = x + (dir * i);
                const nextIdx = getIdx(nextX, y);
                if (nextIdx === -1) break;
                const content = grid[nextIdx];
                const canMove = allMovableMaterials.includes(content) && type != content;
                if (canMove) {
                    targetX = nextX;
                    const vIdx = getIdx(nextX, y + vDir);
                    if (vIdx !== -1 && movableMaterials.includes(grid[vIdx])) break;
                } else break;
            }
            if (targetX !== x) {
                const tIdx = getIdx(targetX, y);
                setter(currentIdx, grid[tIdx]); setter(tIdx, type); moved[tIdx] = 1;
                return true;
            }
            return false;
        }

        function pushLiquidRowSideways(x, y, liquidType, grid, w, h, getIdx, maxPush = 10) {
            const dirs = Math.random() < 0.5 ? [-1, 1] : [1, -1];

            for (const dir of dirs) {
                // find empty space
                for (let i = 1; i <= maxPush; i++) {
                    const targetIdx = getIdx(x + dir * i, y);
                    if (targetIdx === -1) break;

                    if (grid[targetIdx] === MAT.EMPTY) {
                        // shift liquid toward empty space
                        for (let j = i; j > 0; j--) {
                            const fromIdx = getIdx(x + dir * (j - 1), y);
                            const toIdx   = getIdx(x + dir * j, y);

                            if (grid[fromIdx] !== liquidType) break;
                            setGrid(toIdx, grid[fromIdx]);
                            setGrid(fromIdx, MAT.EMPTY);
                            activateChunkAt(x + dir * (j - 1), y);
                            activateChunkAt(x + dir * j, y);
                        }
                        return true;
                    }

                    // stop if blocked by solid
                    if (![MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.ACID].includes(grid[targetIdx])) {
                        break;
                    }
                }
            }
            return false;
        }

        function findGroundBelow(x, startY) {
            for (let y = startY; y < worldHeight; y++) {
                const idx = getIdx(x, y);
                if (idx !== -1 && grid[idx] !== MAT.EMPTY) {
                    return y;
                }
            }
            return worldHeight - 1;
        }

        function createReservoir({
            x,
            y,
            width,
            height,
            fillType,
            wallType = MAT.WOOD
        }) {
            const groundY = findGroundBelow(x, y);
            const topY = Math.max(0, groundY - height);
            const leftX = Math.floor(x - width / 2);
            const rightX = Math.floor(x + width / 2);
            const wallWidth = 2;

            for (let iy = topY; iy <= groundY; iy++) {
                for (let ix = leftX; ix <= rightX; ix++) {
                    const idx = getIdx(ix, iy);
                    if (idx === -1) continue;

                    const isWall =
                        ix <= leftX + wallWidth ||
                        ix >= rightX - wallWidth ||
                        iy >= groundY - wallWidth;

                    setGrid(idx, isWall ? wallType : fillType);
                }
            }
        }

        function createCircle({
            x,
            y,
            radius,
            type
        }) {
            const r2 = radius * radius;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy > r2) continue;

                    const px = Math.floor(x + dx);
                    const py = Math.floor(y + dy);
                    const idx = getIdx(px, py);
                    if (idx === -1) continue;

                    setGrid(idx, type);
                }
            }
        }

        function createCircleOutline({ x, y, radius, thickness = 1, type }) {
            const r2 = radius * radius;
            const inner = (radius - thickness) ** 2;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const d2 = dx * dx + dy * dy;
                    if (d2 > r2 || d2 < inner) continue;

                    const idx = getIdx(x + dx, y + dy);
                    if (idx !== -1) setGrid(idx, type);
                }
            }
        }

        /**
         * Performs a fast, localized lighting update on a single chunk.
         * Crucially, it also detects if light has "spilled" over a border and returns
         * a Set of neighboring chunks that should now also be activated.
         * @param {object} chunk - The chunk object to process.
         * @returns {Set<object>} A set of neighboring chunk objects to activate next.
         */
        function updateLocalLightingAndFindNeighbors(chunk) {
            const neighborsToActivate = new Set();
            const chunkX_base = chunk.index % chunkWidth;
            const chunkY_base = Math.floor(chunk.index / chunkWidth);
            const startX = chunkX_base * CHUNK_SIZE;
            const startY = chunkY_base * CHUNK_SIZE;
            const endX = startX + CHUNK_SIZE;
            const endY = startY + CHUNK_SIZE;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = getIdx(x, y);
                    if (idx === -1) continue;

                    let maxNeighborLight = 0;
                    if (x > 0) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx - 1]);
                    if (x < worldWidth - 1) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx + 1]);
                    if (y > 0) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx - worldWidth]);
                    if (y < worldHeight - 1) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx + worldWidth]);

                    const isWall = grid[idx] === MAT.WALL;
                    const lightLoss = isWall ? 3 : 0;
                    const potentialLight = maxNeighborLight - lightLoss;
                    
                    let lightChanged = false;
                    if (potentialLight > lightGrid[idx]) {
                        lightGrid[idx] = potentialLight;
                        lightChanged = true;
                    }

                    if (grid[idx] === MAT.EMPTY && lightGrid[idx] < MAX_LIGHT_LEVEL) {
                        lightGrid[idx] = MAX_LIGHT_LEVEL;
                        lightChanged = true;
                    }

                    if (lightChanged) {
                        // Check neighbors if this pixel is on a chunk border
                        const dirs = [{dx:-1, dy:0}, {dx:1, dy:0}, {dx:0, dy:-1}, {dx:0, dy:1}];
                        for (const dir of dirs) {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;
                            
                            // Check if the neighbor is in a different chunk
                            if (Math.floor(nx / CHUNK_SIZE) !== chunkX_base || Math.floor(ny / CHUNK_SIZE) !== chunkY_base) {
                                const nIdx = getIdx(nx, ny);
                                // If the neighbor exists and isn't a wall, it can receive light.
                                if (nIdx !== -1 && grid[nIdx] !== MAT.WALL) {
                                    const nChunkX = Math.floor(nx / CHUNK_SIZE);
                                    const nChunkY = Math.floor(ny / CHUNK_SIZE);
                                    if (nChunkX >= 0 && nChunkX < chunkWidth && nChunkY >= 0 && nChunkY < chunkHeight) {
                                        neighborsToActivate.add(chunkGrid[nChunkY * chunkWidth + nChunkX]);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return neighborsToActivate;
        }

        /**
         * Calculates light levels using a Breadth-First Search with material-dependent dampening.
         * Light originates from EMPTY cells, travels freely through non-WALL materials,
         * and loses strength when penetrating WALLs.
         */
        function updateLighting() {
            lightGrid.fill(0);
            const queue = [];

            // 1. Seed the queue with all empty cells as the light sources.
            // const searchRadius = 25;
            // const startX = Math.max(0, Math.floor(camera.x) - searchRadius);
            // const endX = Math.min(worldWidth, Math.floor(camera.x) + viewWidth + searchRadius);
            // const startY = Math.max(0, Math.floor(camera.y) - searchRadius);
            // const endY = Math.min(worldHeight, Math.floor(camera.y) + viewHeight + searchRadius);

            const startX = 0;
            const endX = worldWidth;
            const startY = 0;
            const endY = worldHeight;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = getIdx(x, y);
                    if (idx !== -1 && grid[idx] === MAT.EMPTY) {
                        lightGrid[idx] = MAX_LIGHT_LEVEL;
                        queue.push(idx);
                    }
                }
            }

            // 2. Spread the light outwards layer by layer (BFS)
            let head = 0;
            const DIRS = [-1, 1, -worldWidth, worldWidth];

            while (head < queue.length) {
                const currentIdx = queue[head++];
                const currentLight = lightGrid[currentIdx];

                if (currentLight <= 1) continue;

                for (const dir of DIRS) {
                    const nextIdx = currentIdx + dir;

                    if (nextIdx < 0 || nextIdx >= grid.length || (dir === 1 && nextIdx % worldWidth === 0) || (dir === -1 && currentIdx % worldWidth === 0)) {
                        continue;
                    }
                    
                    // --- NEW LIGHTING LOGIC ---
                    // Determine the light loss based on the material we are *entering*.
                    const isNextMaterialWall = grid[nextIdx] === MAT.WALL;
                    
                    // Light passing into a WALL is heavily dampened.
                    // Light passing into ANY OTHER material is not dampened at all.
                    const lightLoss = isNextMaterialWall ? 3 : 0;
                    
                    const nextLight = currentLight - lightLoss;

                    // If our calculated light is brighter than the neighbor's current light, update it.
                    if (nextLight > lightGrid[nextIdx]) {
                        lightGrid[nextIdx] = nextLight;
                        // Always add the neighbor to the queue to continue spreading light.
                        queue.push(nextIdx); 
                    }
                }
            }
        }

        // --- RENDERING ---
        function setPixel(x, y, r, g, b, a = 255) {
            const i = (y * renderWidth + x) * 4;
            pixels[i]     = r;
            pixels[i + 1] = g;
            pixels[i + 2] = b;
            pixels[i + 3] = a;
        }

        function render() {
            // --- WORLD ---
            firePixelsCoords = [];
            
            const bgPixels = skyImageData.data;
            const bgStartY = Math.floor(camera.y);

            for (let screenY = 0; screenY < renderHeight; screenY++) {
                const worldY = screenY + bgStartY; // The Y-coordinate in the giant background image

                for (let screenX = 0; screenX < renderWidth; screenX++) {
                    const destI = (screenY * renderWidth + screenX) * 4; // Index for the canvas
                    const sourceI = (worldY * worldWidth + screenX) * 4; 

                    // Safety check to prevent reading out of bounds
                    if (sourceI >= 0 && sourceI < bgPixels.length) {
                        pixels[destI]     = bgPixels[sourceI];
                        pixels[destI + 1] = bgPixels[sourceI + 1];
                        pixels[destI + 2] = bgPixels[sourceI + 2];
                        pixels[destI + 3] = 255;
                    }
                }
            }

            const time = frameCount * 0.04;

            // Get the top-left corner of the camera in world coordinates
            const startX = Math.floor(camera.x);
            const startY = Math.floor(camera.y); // THE CRITICAL MISSING PIECE

            // Loop over every pixel on the SCREEN
            for (let screenY = 0; screenY < viewHeight; screenY++) {
                const worldY = screenY + startY;
                for (let screenX = 0; screenX < viewWidth; screenX++) {
                    const worldX = screenX + startX;

                    const idx = getIdx(worldX, worldY);
                    if (idx === -1) continue;

                    const type = grid[idx];
                    
                    if (type === MAT.EMPTY) continue;

                    // --- NEW: Gradient Lighting Logic ---
                    const lightLevel = lightGrid[idx];

                    if (lightLevel === 0 && !ALWAYS_VISIBLE_MATERIALS.has(type)) {
                        setPixel(screenX, screenY, 0, 0, 0); // Completely dark
                        continue;
                    }

                    // 1. Calculate the base color for the material.
                    let [r, g, b] = COLORS[type];

                    if (type === MAT.FIRE) {
                        r = 255; g = 80 + Math.random() * 80; b = 0;
                        firePixelsCoords.push({ x: screenX, y: screenY });
                    } else if (type === MAT.OIL_BURNING || type === MAT.COAL_BURNING) {
                         firePixelsCoords.push({ x: screenX, y: screenY });
                         [r, g, b] = animateLiquidColor(r, g, b, worldX, worldY, type, time);
                    } else if (LIQUIDS.has(type)) {
                        [r, g, b] = animateLiquidColor(r, g, b, worldX, worldY, type, time);
                    } else {
                        [r, g, b] = varyColor(r, g, b, worldX, worldY, type, 16);
                    }

                    // 2. NEW: Apply shimmer effect if the material is a metal.
                    if (SHIMMERING_METALS.has(type)) {
                        // This hash creates a pseudo-random value based on position and time.
                        // Dividing frameCount makes the shimmer slower and less frantic.
                        const shimmerHash = hashCell(worldX, worldY, Math.floor(frameCount / 4));
                        
                        // Only apply a shimmer on rare occasions (when the hash is a high value).
                        if (shimmerHash > 254) {
                            const shimmerBrightness = 35; // How much brighter to make the pixel.
                            r = Math.min(255, r + shimmerBrightness);
                            g = Math.min(255, g + shimmerBrightness);
                            b = Math.min(255, b + shimmerBrightness);
                        }
                    }

                    // 3. Apply brightness based on light level
                    if (!ALWAYS_VISIBLE_MATERIALS.has(type)) {
                        const brightness = lightLevel / MAX_LIGHT_LEVEL;
                        r *= brightness;
                        g *= brightness;
                        b *= brightness;
                    }

                    setPixel(screenX, screenY, r, g, b);
                }
            }

            ctx.putImageData(imageData, 0, 0);

            renderBloom();

            const aimDX = mouse.worldX - (player.x + player.width / 2);
            const aimDY = (player.y + 9) - mouse.worldY;
            const aimAngle = Math.atan2(aimDY, aimDX);
            const wandDir = angleToDir16(aimAngle);

            playerFacingRight = aimDX >= 0;

            // --- PLAYER (SNAPPED FOR SHARPNESS) ---
            const playerScreenX = Math.round(player.x - camera.x);
            const playerScreenY = Math.round(player.y - camera.y);

            // Noita-like sprite colors
            const cloakColor = '#4a2d5e';
            const faceColor = '#211e20';
            const handColor = '#9d81a2';
            let wandScreenX, wandScreenY;

            ctx.imageSmoothingEnabled = false; // Ensure sharp pixels

            // --- 2x SCALED SPRITE DRAWING ---
            if (playerFacingRight) {
                // --- Body & Cloak ---
                ctx.fillStyle = cloakColor;
                ctx.fillRect(playerScreenX + 2, playerScreenY, 6, 2);     // Hood top
                ctx.fillRect(playerScreenX, playerScreenY + 2, 8, 12);    // Main body
                ctx.fillRect(playerScreenX + 2, playerScreenY + 14, 4, 2);    // Feet area
                // --- Face ---
                ctx.fillStyle = faceColor;
                ctx.fillRect(playerScreenX + 4, playerScreenY + 2, 2, 4);
                // Set aim origin
                wandScreenX = playerScreenX + 11;
                wandScreenY = playerScreenY + 9;
            } else { // Facing Left
                // --- Body & Cloak ---
                ctx.fillStyle = cloakColor;
                ctx.fillRect(playerScreenX, playerScreenY, 6, 2);         // Hood top
                ctx.fillRect(playerScreenX, playerScreenY + 2, 8, 12);    // Main body
                ctx.fillRect(playerScreenX + 2, playerScreenY + 14, 4, 2);    // Feet area
                // --- Face ---
                ctx.fillStyle = faceColor;
                ctx.fillRect(playerScreenX + 2, playerScreenY + 2, 2, 4);
                // Set aim origin
                wandScreenX = playerScreenX - 3;
                wandScreenY = playerScreenY + 9;
            }

            // --- Wand ---
            const handX = playerFacingRight
                ? playerScreenX + 8
                : playerScreenX - 1;

            const handY = playerScreenY + 9;

            const wandLen = 3;

            const dx = wandDir.x;
            const dy = wandDir.y;
            const mag = Math.max(Math.abs(dx), Math.abs(dy));

            ctx.fillStyle = '#bfa76a';
            for (let i = 0; i < wandLen; i++) {
                ctx.fillRect(
                    handX + Math.round(dx * i / mag),
                    handY + Math.round(dy * i / mag),
                    1,
                    1
                );
            }

            // Tip
            ctx.fillStyle = '#ffcc66';
            ctx.fillRect(
                handX + Math.round(dx * wandLen / mag),
                handY + Math.round(dy * wandLen / mag),
                1,
                1
            );

            // --- RENDER POURED PARTICLES ---
            for (const p of pouredParticles) {
                const [r,g,b] = COLORS[p.type];
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1);
            }

            // --- RENDER MAGIC PARTICLES ---
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (p.active) {
                    ctx.fillStyle = `rgb(${p.color[0]}, ${p.color[1]}, ${p.color[2]})`;
                    ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1);
                }
            }

            // --- RENDER INTERACT HINT ---
            // Check if the player can interact and that a trigger is currently active
            if (player.canInteract && player.currentTrigger) {
                // Get the currently active trigger
                const trigger = player.currentTrigger;

                // 1. Calculate the base position: center-top of the trigger zone
                const hintX = Math.round(trigger.x - camera.x + trigger.width / 2);
                const hintY = Math.round(trigger.y - camera.y - 15); // 15 pixels above the slab

                // 2. Add the hover animation using a sine wave
                const hoverAmplitude = 3; // How many pixels to move up and down
                const hoverSpeed = 0.05;  // How fast to hover
                const animatedY = hintY + Math.sin(frameCount * hoverSpeed) * hoverAmplitude;

                // Draw a simple background for visibility
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(hintX - 8, animatedY - 12, 16, 16);
                
                // Draw the 'E'
                ctx.font = 'bold 12px monospace';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle'; // Center text vertically for smoother animation
                ctx.fillText('E', hintX, animatedY);
            }

            // --- AIM LINE ---
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(wandScreenX, wandScreenY);
            ctx.lineTo(mouse.x / scale, mouse.y / scale);
            ctx.stroke();

            renderPlayerStatsUI();
            renderAlchemyUI();
        }

        /**
         * Top-level function to draw both inventory containers on the screen.
         */
        function renderContainers() {
            const pouchX = renderWidth - pouchWidth - 12;
            const flaskX = pouchX - flaskWidth - 8;
            const commonY = 40;

            renderContainer(pouchGrid, pouchWidth, pouchHeight, pouchX, commonY, activeContainer === 'pouch');
            renderContainer(flaskGrid, flaskWidth, flaskHeight, flaskX, commonY, activeContainer === 'flask');
        }

        /**
         * Draws a single container's border and its contents.
         */
        function renderContainer(cGrid, cW, cH, screenX, screenY, isActive) {
            // Draw background and border
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(screenX - 2, screenY - 2, cW + 4, cH + 4);
            ctx.strokeStyle = isActive ? 'white' : '#888'; // Highlight if active
            ctx.lineWidth = 2;
            ctx.strokeRect(screenX - 2, screenY - 2, cW + 4, cH + 4);

            // Draw contents
            for (let y = 0; y < cH; y++) {
                for (let x = 0; x < cW; x++) {
                    const type = cGrid[getIdx(x, y, cW, cH)];
                    if (type !== MAT.EMPTY) {
                        const [r, g, b] = varyColor(...COLORS[type], x, y, type, 8);
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fillRect(screenX + x, screenY + y, 1, 1);
                    }
                }
            }
        }

        function renderBloom() {
            if (firePixelsCoords.length === 0) return;

            // --- Configuration ---
            const bloomRadius = 6; // How far the glow extends, in pixels
            const bloomIntensity = 0.01; // How bright the glow is (0.0 to 1.0)
            const bloomColor = [180, 100, 50]; // The color of the glow (R, G, B)
            
            // Get the current canvas content so we can blend with it
            const screenData = ctx.getImageData(0, 0, renderWidth, renderHeight);
            const screenPixels = screenData.data;
            
            const r2 = bloomRadius * bloomRadius;

            // Iterate ONLY through the fire pixels we found earlier
            for (const p of firePixelsCoords) {
                // For each fire pixel, draw a glow "stamp" around it
                for (let dy = -bloomRadius; dy <= bloomRadius; dy++) {
                    for (let dx = -bloomRadius; dx <= bloomRadius; dx++) {
                        const distSq = dx * dx + dy * dy;
                        if (distSq > r2) continue;

                        const px = p.x + dx;
                        const py = p.y + dy;

                        // Bounds check
                        if (px < 0 || px >= renderWidth || py < 0 || py >= renderHeight) continue;
                        
                        // Calculate falloff: glow is strongest at the center
                        const falloff = (1.0 - (distSq / r2)) * bloomIntensity;
                        if (falloff <= 0) continue;
                        
                        const i = (py * renderWidth + px) * 4;

                        // Additive blending
                        screenPixels[i]     = Math.min(255, screenPixels[i]     + bloomColor[0] * falloff);
                        screenPixels[i + 1] = Math.min(255, screenPixels[i + 1] + bloomColor[1] * falloff);
                        screenPixels[i + 2] = Math.min(255, screenPixels[i + 2] + bloomColor[2] * falloff);
                    }
                }
            }

            // Put the modified pixel data (with bloom) back onto the canvas
            ctx.putImageData(screenData, 0, 0);
        }

        function angleToDir16(a) {
            const step = Math.PI / 8;
            const i = Math.round(a / step) & 15;
            return WAND_DIRS_16[i];
        }


        const WAND_DIRS_16 = [
            { x: 1,  y: 0 },
            { x: 2,  y: -1 },
            { x: 1,  y: -1 },
            { x: 1,  y: -2 },
            { x: 0,  y: -1 },
            { x: -1, y: -2 },
            { x: -1, y: -1 },
            { x: -2, y: -1 },
            { x: -1, y: 0 },
            { x: -2, y: 1 },
            { x: -1, y: 1 },
            { x: -1, y: 2 },
            { x: 0,  y: 1 },
            { x: 1,  y: 2 },
            { x: 1,  y: 1 },
            { x: 2,  y: 1 },
        ];

        function animateLiquidColor(r, g, b, x, y, type, time) {
            // Static grain (same as solids)
            const baseNoise = (hashCell(x, y, type) / 255 - 0.5) * 12;

            // Animated wave
            const wave = liquidWave(x, y, time) * 10;

            const delta = baseNoise + wave;

            return [
                Math.max(0, Math.min(255, r + delta)),
                Math.max(0, Math.min(255, g + delta)),
                Math.max(0, Math.min(255, b + delta))
            ];
        }

        function liquidWave(x, y, t) {
            return Math.sin(x * 0.15 + t) * 0.5 +
                Math.sin(y * 0.1  + t * 1.3) * 0.5;
        }

        function hashCell(x, y, type) {
            // Fast, deterministic hash
            let h = x * 374761393 + y * 668265263 + type * 1442695041;
            h = (h ^ (h >> 13)) * 1274126177;
            return (h ^ (h >> 16)) & 0xff; // 0..255
        }

        function varyColor(r, g, b, x, y, type, strength = 18) {
            // strength = max brightness change (try 12–24)
            const n = hashCell(x, y, type) / 255; // 0..1
            const delta = (n - 0.5) * strength * 2;

            return [
                Math.max(0, Math.min(255, r + delta)),
                Math.max(0, Math.min(255, g + delta)),
                Math.max(0, Math.min(255, b + delta))
            ];
        }

        function updateHoverMaterial() {
            const idx = getIdx(mouse.worldX, mouse.worldY);
            if (idx === -1) {
                hudMaterial = '--';
            } else {
                const type = grid[idx];
                hudMaterial = MATERIAL_NAME[type] || 'Unknown';
            }
        }


        function findGroundSurfaceY(x) {
            for (let y = 0; y < worldHeight; y++) { if (grid[getIdx(x, y)] !== MAT.EMPTY) return y; }
            return worldHeight - 1;
        }
        function drawTree(baseX, baseY) {
            const trunkHeight = 40 + Math.floor(Math.random() * 12); // Scaled height
            for (let i = 0; i < trunkHeight; i++) {
                const y = baseY - i; if (y < 0) continue;
                setGrid(getIdx(baseX, y), MAT.WOOD);
                if(i < 30) { // Scaled thickness
					setGrid(getIdx(baseX - 1, y), MAT.WOOD);
					setGrid(getIdx(baseX + 1, y), MAT.WOOD);
				}
            }
        }


        /**
         * Generates a horizontal slab with a background, inscribed runes, and border lines.
         * @param {number} slabX - The top-left X coordinate of the slab.
         * @param {number} slabY - The top-left Y coordinate of the slab.
         * @param {number} slabWidth - The width of the slab.
         * @param {number} slabHeight - The height of the slab.
         * @param {material} backgroundMaterial - The material for the slab's base.
         * @param {material} runeMaterial - The material for the inscribed runes and borders.
         */
        function generateRunicSlab(slabX, slabY, slabWidth, slabHeight, backgroundMaterial, runeMaterial) {
            // 1. Fill the entire slab area with the background material.
            for (let y = slabY; y < slabY + slabHeight; y++) {
                for (let x = slabX; x < slabX + slabWidth; x++) {
                    const idx = getIdx(x, y);
                    if (idx !== -1) setGrid(idx, backgroundMaterial);
                }
            }

            // --- Calculate vertical positioning ---
            const verticalPadding = Math.floor((slabHeight - DWARVEN_RUNES.RUNE_HEIGHT) / 2);
            const runesTopY = slabY + verticalPadding;
            const runesBottomY = runesTopY + DWARVEN_RUNES.RUNE_HEIGHT - 1;

            // NEW: 2. Draw the horizontal border lines.
            const lineThickness = 1; // You can make this thicker if you like
            const linePadding = 3;   // Pixels of space between the line and the runes

            // Top line
            const topLineY = runesTopY - linePadding;
            for (let t = 0; t < lineThickness; t++) {
                for (let x = slabX; x < slabX + slabWidth; x++) {
                    const idx = getIdx(x, topLineY - t);
                    if (idx !== -1) setGrid(idx, runeMaterial);
                }
            }
            
            // Bottom line
            const bottomLineY = runesBottomY + linePadding;
            for (let t = 0; t < lineThickness; t++) {
                for (let x = slabX; x < slabX + slabWidth; x++) {
                    const idx = getIdx(x, bottomLineY + t);
                    if (idx !== -1) setGrid(idx, runeMaterial);
                }
            }
            
            // --- Inscribe the runes ---
            const runePadding = 5;
            let cursorX = slabX + runePadding;

            // 3. Loop and stamp the runes.
            while (cursorX + DWARVEN_RUNES.RUNE_WIDTH + runePadding < slabX + slabWidth) {
                // ... (The rest of the rune stamping logic is exactly the same) ...
                const pattern = DWARVEN_RUNES.PATTERNS[Math.floor(Math.random() * DWARVEN_RUNES.PATTERNS.length)];

                for (let y = 0; y < DWARVEN_RUNES.RUNE_HEIGHT; y++) {
                    for (let x = 0; x < DWARVEN_RUNES.RUNE_WIDTH; x++) {
                        if (pattern[y][x] === 1) {
                            const drawX = cursorX + x;
                            const drawY = runesTopY + y;
                            const idx = getIdx(drawX, drawY);
                            if (idx !== -1) {
                                setGrid(idx, runeMaterial);
                            }
                        }
                    }
                }

                cursorX += DWARVEN_RUNES.RUNE_WIDTH + runePadding;
            }
        }

        /**
         * Creates a persistent particle emitter that spawns particles over time.
         * Can spawn from an area or along a line.
         * @param {object} options - An object with configuration for the emitter.
         * @returns {number} The unique ID of the created emitter.
         */
        function createMagicEmitter(options) {
            const emitter = {
                id: nextEmitterId++,
                mainColor: options.mainColor || [255, 255, 255],
                spawnRate: options.spawnRate || 0.2,
                
                // --- NEW: Spawning type and coordinates ---
                spawnType: options.spawnType || 'area', // Can be 'area' or 'line'
                
                // Properties for 'area' type (the original behavior)
                x: options.x || 0,
                y: options.y || 0,
                spawnArea: options.spawnArea || { width: 10, height: 5 },
                
                // Properties for 'line' type
                x1: options.x1 || 0,
                y1: options.y1 || 0,
                x2: options.x2 || 0,
                y2: options.y2 || 0,

                // --- Particle-specific properties (remain the same) ---
                particleLifespan: options.particleLifespan || { min: 60, max: 150 },
                particleVelocity: options.particleVelocity || { 
                    vx: { min: -0.2, max: 0.2 },
                    vy: { min: -0.2, max: -0.6 }
                },
                colorVariance: options.colorVariance || 60
            };
            magicEmitters.push(emitter);
            return emitter.id;
        }

        /**
         * Removes a magic particle emitter by its unique ID.
         * @param {number} id - The ID of the emitter to remove.
         */
        function removeMagicEmitter(id) {
            magicEmitters = magicEmitters.filter(e => e.id !== id);
        }
        
        /**
         * Updates all active emitters, spawning new particles based on their configuration.
         * This function handles both 'area' and 'line' spawn types.
         */
        function updateMagicEmitters() {
            // Loop through every active emitter
            for (const emitter of magicEmitters) {
                // Use the spawnRate as a probability check for this frame
                if (Math.random() < emitter.spawnRate) {
                    
                    // Find an available (inactive) particle in the dedicated magic particle pool
                    for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                        const p = magicParticlePool[i];
                        if (!p.active) {
                            let spawnX, spawnY;

                            // --- Determine the particle's starting position based on emitter type ---
                            if (emitter.spawnType === 'line') {
                                // Pick a random point along the line using linear interpolation.
                                // A 't' value of 0 is the start of the line, 1 is the end.
                                const t = Math.random(); 
                                spawnX = emitter.x1 + t * (emitter.x2 - emitter.x1);
                                spawnY = emitter.y1 + t * (emitter.y2 - emitter.y1);
                            } else { // Default to 'area' if spawnType is not 'line'
                                spawnX = emitter.x + (Math.random() - 0.5) * emitter.spawnArea.width;
                                spawnY = emitter.y + (Math.random() - 0.5) * emitter.spawnArea.height;
                            }
                            
                            // --- Full Color Variance Logic ---
                            // Take the emitter's base color and add/subtract a random amount from each channel.
                            const r = Math.max(0, Math.min(255, emitter.mainColor[0] + (Math.random() - 0.5) * emitter.colorVariance));
                            const g = Math.max(0, Math.min(255, emitter.mainColor[1] + (Math.random() - 0.5) * emitter.colorVariance));
                            const b = Math.max(0, Math.min(255, emitter.mainColor[2] + (Math.random() - 0.5) * emitter.colorVariance));
                            
                            // --- Activate and configure the particle with all its properties ---
                            p.active = true;
                            p.x = spawnX;
                            p.y = spawnY;
                            p.vx = emitter.particleVelocity.vx.min + Math.random() * (emitter.particleVelocity.vx.max - emitter.particleVelocity.vx.min);
                            p.vy = emitter.particleVelocity.vy.min + Math.random() * (emitter.particleVelocity.vy.max - emitter.particleVelocity.vy.min);
                            p.lifespan = emitter.particleLifespan.min + Math.random() * (emitter.particleLifespan.max - emitter.particleLifespan.min);
                            p.color = [r, g, b];
                            
                            // We've successfully spawned a particle, so we can exit the inner loop.
                            break; 
                        }
                    }
                }
            }
        }

        /**
         * Spawns exhaust particles from the player's feet when levitating.
         * @param {number} count - The number of particles to attempt to spawn this frame.
         */
        function spawnLevitationParticles(count) {
            let spawnedCount = 0;
            // Base position is the center of the player's feet
            const baseX = player.x + player.width / 2;
            const baseY = player.y + player.height - 2; // Start the trail slightly inside the player model

            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) {
                    p.active = true;

                    // Position with slight horizontal randomness for a "cone" shape
                    p.x = baseX + (Math.random() - 0.5) * 4;
                    p.y = baseY + (Math.random() - 0.5) * 2;

                    // Velocity: Shoots downwards and spreads out.
                    // It's also slightly affected by the player's own upward speed to make it "lag behind".
                    p.vx = (Math.random() - 0.5) * 0.5;
                    p.vy = (Math.random() * 0.8) + 0.4 - (player.vy * 0.1);

                    // Color: A blueish-white "magic energy" color with some variance
                    const baseColor = [180, 200, 255];
                    const colorVariance = 40;
                    p.color = [
                        Math.max(0, Math.min(255, baseColor[0] + (Math.random() - 0.5) * colorVariance)),
                        Math.max(0, Math.min(255, baseColor[1] + (Math.random() - 0.5) * colorVariance)),
                        Math.max(0, Math.min(255, baseColor[2] + (Math.random() - 0.5) * colorVariance))
                    ];

                    // Lifespan: Particles last for less than a second
                    p.lifespan = 15 + Math.random() * 20;

                    spawnedCount++;
                    if (spawnedCount >= count) {
                        return; // We've spawned enough particles for this frame
                    }
                }
            }
        }

        /**
         * The main function to create a burst of magic particles at a specific location, using the object pool.
         * @param {number} count - The number of particles to create.
         * @param {number} x - The center X coordinate of the spawn area.
         * @param {number} y - The center Y coordinate of the spawn area.
         * @param {Array<number>} mainColor - The base color as an [R, G, B] array.
         */
        function spawnMagicParticles(count, x, y, mainColor) {
            let spawnedCount = 0;
            // Search the pool for an inactive particle to reuse
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) {
                    // --- Activate and configure the particle ---

                    p.active = true;

                    // 1. Create variance in the spawn position
                    p.x = x + (Math.random() - 0.5) * 20;
                    p.y = y + (Math.random() - 0.5) * 10;

                    // 2. Create the color with a random hue shift from the main color
                    const colorVariance = 60;
                    const r = Math.max(0, Math.min(255, mainColor[0] + (Math.random() - 0.5) * colorVariance));
                    const g = Math.max(0, Math.min(255, mainColor[1] + (Math.random() - 0.5) * colorVariance));
                    const b = Math.max(0, Math.min(255, mainColor[2] + (Math.random() - 0.5) * colorVariance));
                    p.color = [r, g, b];

                    // 3. Particles float upwards with a slight horizontal drift
                    p.vx = (Math.random() - 0.5) * 0.3;
                    p.vy = -0.2 + (Math.random() * -0.4);
                    
                    // 4. They last for about 1-2.5 seconds (at 60fps)
                    p.lifespan = 60 + Math.random() * 90;

                    spawnedCount++;
                    if (spawnedCount >= count) {
                        // We have spawned the requested number of particles, so we can stop searching.
                        return;
                    }
                }
            }
        }

        function updateMagicParticles() {
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) continue;

                p.x += p.vx;
                p.y += p.vy;
                p.lifespan--;

                if (p.lifespan <= 0) {
                    p.active = false;
                }
            }
        }

        /**
         * Helper function to find the most common storable material in a given area.
         * @returns {number|null} The material ID (e.g., MAT.SAND) or null if the area is empty.
         */
        function getDominantMaterialInArea(x, y, width, height) {
            const counts = {};
            let maxCount = 0;
            let dominantMaterial = null;

            for (let iy = y; iy < y + height; iy++) {
                for (let ix = x; ix < x + width; ix++) {
                    const idx = getIdx(ix, iy);
                    if (idx === -1) continue;
                    const type = grid[idx];
                    // Only count materials that can actually be stored/manipulated
                    if (STORABLE_SOLIDS.has(type) || STORABLE_LIQUIDS.has(type)) {
                        counts[type] = (counts[type] || 0) + 1;
                        if (counts[type] > maxCount) {
                            maxCount = counts[type];
                            dominantMaterial = type;
                        }
                    }
                }
            }
            return dominantMaterial;
        }

        /**
         * Manages alchemy jobs by teleporting materials from a manifest
         * to a location above the target cauldron.
         */
        function processAlchemyJobs() {
            if (alchemyJobs.length === 0) return;

            // How many particles to teleport per frame. Controls the stream's speed.
            const particlesToTeleportThisFrame = 5; 

            for (let i = alchemyJobs.length - 1; i >= 0; i--) {
                const job = alchemyJobs[i];

                for (let j = 0; j < particlesToTeleportThisFrame; j++) {
                    // If the manifest is empty, the job is complete.
                    if (job.manifest.length === 0) {
                        alchemyJobs.splice(i, 1);
                        break; 
                    }

                    // Pull one particle's info from the manifest.
                    const materialInfo = job.manifest.shift();

                    // --- THE FIX: The Teleportation ---
                    // 1. Define a spawn zone in the air above the target cauldron.
                    const spawnX = job.target.x + (job.target.w * 0.1) + (Math.random() * job.target.w * 0.5);
                    const spawnY = job.target.y - (5 + Math.random() * 10); // 5 to 15 pixels above the rim.

                    // 2. Find the grid index for this spawn point.
                    const spawnIdx = getIdx(spawnX, spawnY);

                    // 3. If the spot in the air is empty, place the material there.
                    if (spawnIdx !== -1 && grid[spawnIdx] === MAT.EMPTY) {
                        setGrid(spawnIdx, materialInfo.type);
                        
                        // 4. Activate the chunk to let the main physics engine take over.
                        activateChunkAt(spawnX, spawnY);
                    } else {
                        // If the air is somehow crowded, put the particle back in the job to try again next frame.
                        // This guarantees no material is ever lost.
                        job.manifest.unshift(materialInfo);
                    }
                }
            }
        }

        // --- THE ALCHEMY REACTION REGISTRY ---
        const ALCHEMY_REACTIONS = {
            'filter_material': {
                name: "Filter Material",
                description: "Moves materials from the left cauldron to the right, based on the sampler.",
                execute: function(station) {
                    console.log("Executing Filter Material reaction!");
                    
                    const filterMaterial = getDominantMaterialInArea(
                        station.sampler.x, station.sampler.y, station.sampler.w, station.sampler.h
                    );

                    if (filterMaterial === null) {
                        console.log("Sampler is empty. Nothing to filter.");
                        return;
                    }
                    console.log(`Filtering for: ${MATERIAL_NAME[filterMaterial]}`);

                    const source = station.cauldrons.left;
                    const target = station.cauldrons.right;
                    let translationManifest = [];

                    // 1. Create a simple manifest of the material to be moved.
                    for (let y = source.y; y < source.y + source.h; y++) {
                        for (let x = source.x; x < source.x + source.w; x++) {
                            const idx = getIdx(x, y);
                            if (idx !== -1 && grid[idx] === filterMaterial) {
                                // The manifest now only needs the type. The source location is irrelevant.
                                translationManifest.push({ type: grid[idx] });
                                setGrid(idx, MAT.EMPTY);
                                activateChunkAt(x, y);
                            }
                        }
                    }

                    if (translationManifest.length === 0) {
                        console.log("No matching materials found.");
                        return;
                    }

                    // 2. Create the job, providing the manifest and the target geometry.
                    alchemyJobs.push({
                        manifest: translationManifest,
                        target: target
                    });
                }
            },
            // --- START OF NEW CODE ---
            'heat_material': {
                name: "Heat Material",
                description: "Heats the material in the left cauldron, causing reactions.",
                execute: function(station) {
                    console.log("Executing Heat Material reaction!");
                    const source = station.cauldrons.left;

                    // Spawn some fire/heat particles for visual effect
                    spawnMagicParticles(50, source.x + source.w / 2, source.y + source.h / 2, [255, 100, 0]);

                    for (let y = source.y; y < source.y + source.h; y++) {
                        for (let x = source.x; x < source.x + source.w; x++) {
                            const idx = getIdx(x, y);
                            if (idx === -1) continue;

                            const type = grid[idx];
                            let changed = true;
                            switch (type) {
                                case MAT.SAND:
                                    setGrid(idx, MAT.GLASS);
                                    break;
                                case MAT.WOOD:
                                    setGrid(idx, MAT.FIRE);
                                    break;
                                case MAT.OIL:
                                    setGrid(idx, MAT.OIL_BURNING);
                                    break;
                                case MAT.COAL:
                                    setGrid(idx, MAT.COAL_BURNING);
                                    break;
                                case MAT.GUNPOWDER:
                                    setGrid(idx, MAT.GUNPOWDER_IGNITED);
                                    ignitionTimer[idx] = 8 + Math.floor(Math.random() * 6);
                                    break;
                                case MAT.WATER:
                                    setGrid(idx, MAT.GAS);
                                    break;
                                default:
                                    changed = false;
                                    break;
                            }
                            if (changed) {
                                activateChunkAt(x, y);
                            }
                        }
                    }
                }
            },
            'clear_cauldrons': {
                name: "Clear Cauldrons",
                description: "Clears all materials from both cauldrons and the sampler.",
                execute: function(station) {
                    console.log("Executing Clear Cauldrons reaction!");
                    const areasToClear = [
                        station.cauldrons.left,
                        station.cauldrons.right,
                        station.sampler
                    ];

                    for (const area of areasToClear) {
                        // Visual effect for clearing
                        spawnMagicParticles(30, area.x + area.w / 2, area.y, [200, 200, 255]);
                        for (let y = area.y; y < area.y + area.h; y++) {
                            for (let x = area.x; x < area.x + area.w; x++) {
                                const idx = getIdx(x, y);
                                if (idx !== -1 && grid[idx] !== MAT.ADAMANTIUM) {
                                    setGrid(idx, MAT.EMPTY);
                                    activateChunkAt(x, y);
                                }
                            }
                        }
                    }
                }
            }
            // ... more reactions can be added here ...
        };

        /**
         * Clears a large space and generates the fixed alchemy station with a solid floor.
         */
        function generateAlchemyStation() {
            const stationWidth = 600;
            const stationHeight = 200;
            const startX = 0; 
            const startY = 5;
            const floorY = startY + stationHeight - 20;

            // 1. Carve out a huge, clean room.
            for (let y = startY; y < startY + stationHeight; y++) {
                for (let x = startX; x < startX + stationWidth; x++) {
                    const idx = getIdx(x, y);
                    if (idx !== -1) setGrid(idx, MAT.EMPTY);
                }
            }
            
            // 2. Build the solid Adamantium floor.
            for (let y = floorY; y < startY + stationHeight; y++) {
                for (let x = startX; x < startX + stationWidth; x++) {
                    setGrid(getIdx(x, y), MAT.ADAMANTIUM);
                }
            }

            // NEW: 3. Generate the decorative Runic Slab backdrop.
            const slabHeight = 15;
            const slabWidth = 70;
            const slabY = floorY - slabHeight; // Place it right on top of the floor
            const slabX = startX + 130;
            // We use the Rune Wall material as the base and Adamantium for the inscription
            generateRunicSlab(slabX, slabY, slabWidth, slabHeight, MAT.ADAMANTIUM, MAT.RUNE_WALL);

            // 3. Define the positions for the cauldrons and sampler.
            const leftCauldronX = startX + 260;
            const rightCauldronX = startX + 390;
            const samplerX = startX + 325;
            
            // 4. Create the components.
            // The cauldron's rim will be a few pixels above the main floor, making it protrude.
            const rimHeightAboveFloor = 15;
            const cauldronRimY = floorY - rimHeightAboveFloor;

            // Use the new, correct function
            // Left Cauldron
            createCauldron(leftCauldronX, cauldronRimY, 32, 4, MAT.ADAMANTIUM);
            // Right Cauldron
            createCauldron(rightCauldronX, cauldronRimY, 32, 4, MAT.ADAMANTIUM);
            // Sampler in the middle
            createCauldron(samplerX, floorY - 5, 8, 2, MAT.ADAMANTIUM);

            const stationGeometry = {
                cauldrons: {
                    left: { x: leftCauldronX - 25, y: cauldronRimY, w: 64, h: 32 },
                    right: { x: rightCauldronX - 25, y: cauldronRimY, w: 64, h: 32 }
                },
                sampler: { x: samplerX - 8, y: floorY - 5, w: 16, h: 8 }
            };

            // Create the trigger with our custom onEnter and onLeave logic
            createTrigger({
                x: slabX,
                y: slabY,
                width: slabWidth,
                height: slabHeight,
                onEnter: function(trigger) {
                    // This function is called when the player steps ON the slab.
                    console.log("Player entered the sampler zone.");
                    
                    // Create a special gold-colored emitter on the slab
                    const emitterId = createMagicEmitter({
                        spawnType: 'line',
                        x1: slabX, y1: slabY,
                        x2: slabX + slabWidth, y2: slabY,
                        mainColor: [255, 230, 100], // Gold
                        spawnRate: 0.5 // Spawn a particle every 2 frames on average
                    });
                    
                    // IMPORTANT: Store the ID of the emitter we just created inside the trigger.
                    trigger.associatedData.emitterId = emitterId;
                },
                onLeave: function(trigger) {
                    // This function is called when the player steps OFF the slab.
                    console.log("Player left the sampler zone.");
                    
                    // Use the stored ID to find and remove the correct emitter.
                    if (trigger.associatedData.emitterId != null) {
                        removeMagicEmitter(trigger.associatedData.emitterId);
                        trigger.associatedData.emitterId = null; // Clear the stored ID
                    }
                },
                onInteract: function(trigger) {
                    // This function is called when the player presses "E" inside the zone.
                    console.log("Player INTERACTED with the sampler! Time for alchemy!");
                    isAlchemyUIVisible = true;
                },
                associatedData: {
                    stationGeometry: stationGeometry
                }
            });
        }

        /**
         * Creates a hollow, downward-facing cauldron bowl, set into a surface.
         * It draws a solid depression first, then carves the empty space inside.
         * @param {number} cx - The center X coordinate of the cauldron.
         * @param {number} rimY - The Y coordinate for the cauldron's rim (the surface level).
         * @param {number} radius - The outer radius of the cauldron.
         * @param {number} thickness - The thickness of the cauldron's wall and floor.
         * @param {material} material - The material to build the cauldron from.
         */
        function createCauldron(cx, rimY, radius, thickness, material) {
            const outerRadiusSq = radius * radius;
            const innerRadius = radius - thickness;
            const innerRadiusSq = innerRadius * innerRadius;

            // 1. Draw the SOLID outer shape of the cauldron's bowl, facing DOWN.
            // This carves a solid half-sphere depression into the floor.
            for (let dy = 0; dy <= radius; dy++) { // CHANGED: Loop from 0 to +radius
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy <= outerRadiusSq) {
                        const idx = getIdx(cx + dx, rimY + dy);
                        if (idx !== -1) {
                            setGrid(idx, material);
                        }
                    }
                }
            }

            // 2. Carve the EMPTY hollow interior, leaving the walls and bottom intact.
            for (let dy = 0; dy < innerRadius; dy++) { // CHANGED: Loop from 0 to +innerRadius
                for (let dx = -innerRadius; dx <= innerRadius; dx++) {
                     if (dx * dx + dy * dy <= innerRadiusSq) {
                        const idx = getIdx(cx + dx, rimY + dy);
                        if (idx !== -1) {
                            setGrid(idx, MAT.EMPTY);
                        }
                    }
                }
            }
        }

        /**
         * Generates terrain and ore veins using an additive Perlin noise process.
         * @param {number} width - The width of the world.
         * @param {number} height - The height of the world.
         * @param {Uint8Array} grid - The world grid to fill.
         */
        function generateCavesWithPerlinNoise(width, height, grid) {
            // --- Configuration ---
            const scale = 150;
            const depthBiasStrength = 0.3;

            // --- Tiers for Additive Generation ---
            // This array is ordered from MOST common to RAREST.
            // Each tier overwrites the one before it if the threshold is met.
            const GENERATION_TIERS = [
                { material: MAT.WALL,     threshold: 0.52 }, // Base rock
                { material: MAT.COPPER,   threshold: 0.70 },
                { material: MAT.SILVER,   threshold: 0.75 },
                { material: MAT.GOLD,     threshold: 0.85 },
                { material: MAT.PLATINUM, threshold: 0.99 }
            ];

            // --- Octave Configuration ---
            const octaves = 4;
            const persistence = 0.5;
            const lacunarity = 2;
            
            PerlinNoise.seed(12345 * Math.random() + 10000);

            for (let y = 0; y < height; y++) {
                const depthFactor = y / height;
                const currentDepthBias = depthFactor * depthBiasStrength;

                for (let x = 0; x < width; x++) {
                    let totalNoise = 0;
                    let frequency = 1;
                    let amplitude = 1;
                    let maxAmplitude = 0;

                    for (let i = 0; i < octaves; i++) {
                        const noiseValue = (PerlinNoise.noise(x * frequency / scale, y * frequency / scale) + 1) / 2;
                        totalNoise += noiseValue * amplitude;
                        maxAmplitude += amplitude;
                        amplitude *= persistence;
                        frequency *= lacunarity;
                    }
                    
                    const finalNoise = totalNoise / maxAmplitude;

                    // --- Additive Generation Logic ---
                    let materialToPlace = MAT.EMPTY;

                    // Loop through the tiers from rock up to platinum
                    for (const tier of GENERATION_TIERS) {
                        // Check if the noise is high enough for this tier
                        if (finalNoise >= tier.threshold - currentDepthBias) {
                            // If it is, this becomes the new candidate material.
                            // This will naturally overwrite less rare materials.
                            materialToPlace = tier.material;
                        }
                    }

                    // After checking all tiers, if a material was chosen, place it.
                    if (materialToPlace !== MAT.EMPTY) {
                        const idx = getIdx(x, y);
                        if (idx !== -1) {
                            setGrid(idx, materialToPlace);
                        }
                    }
                }
            }
        }

        /**
         * Takes all potentially active chunks, sorts them by priority (on-screen, then distance to player),
         * and limits the number of off-screen chunks to be processed in a single frame.
         * @returns {void} - This function directly modifies the global activeChunks and pendingActiveChunks variables.
         */
        function prioritizeAndLimitActiveChunks() {
            // 1. Combine newly activated chunks with any that were deferred from the last frame.
            const allChunksToConsider = new Set([...pendingActiveChunks, ...nextActiveChunks]);
            nextActiveChunks.clear(); // Clear for the next simulation step.

            // 2. Separate chunks into on-screen (high priority) and off-screen (lower priority).
            const priorityChunks = new Set();
            const otherChunks = [];
            const camChunkX1 = Math.floor(camera.x / CHUNK_SIZE);
            const camChunkX2 = Math.floor((camera.x + viewWidth) / CHUNK_SIZE);
            const camChunkY1 = Math.floor(camera.y / CHUNK_SIZE);
            const camChunkY2 = Math.floor((camera.y + viewHeight) / CHUNK_SIZE);

            for (const chunk of allChunksToConsider) {
                const cx = chunk.index % chunkWidth;
                const cy = Math.floor(chunk.index / chunkWidth);
                if (cx >= camChunkX1 && cx <= camChunkX2 && cy >= camChunkY1 && cy <= camChunkY2) {
                    priorityChunks.add(chunk);
                } else {
                    otherChunks.push(chunk);
                }
            }

            // 3. Sort the off-screen chunks by their distance to the player (closest first).
            const playerChunkX = Math.floor(player.x / CHUNK_SIZE);
            const playerChunkY = Math.floor(player.y / CHUNK_SIZE);
            otherChunks.sort((a, b) => {
                const aX = a.index % chunkWidth;
                const aY = Math.floor(a.index / chunkWidth);
                const bX = b.index % chunkWidth;
                const bY = Math.floor(b.index / chunkWidth);
                const distA = (aX - playerChunkX)**2 + (aY - playerChunkY)**2;
                const distB = (bX - playerChunkX)**2 + (bY - playerChunkY)**2;
                return distA - distB;
            });
            
            // 4. Create the final processing list for this frame.
            const processingOrder = [...priorityChunks, ...otherChunks];

            // 5. Apply the limit and update the global variables for the simulation.
            const chunksToProcess = processingOrder.slice(0, priorityChunks.size + MAX_CHUNKS_PER_FRAME);
            pendingActiveChunks = processingOrder.slice(priorityChunks.size + MAX_CHUNKS_PER_FRAME);
            activeChunks = new Set(chunksToProcess);
        }

        // --- GAME LOOP ---
        function gameLoop(now = performance.now()) {
            frameCount++;
            framesThisSecond++;
            if (now - lastFpsTime >= 1000) {
                hudFPS = framesThisSecond;
                framesThisSecond = 0;
                lastFpsTime = now;
            }

            prioritizeAndLimitActiveChunks();

            // --- UPDATE LOGIC ---
            updatePlayer();
            updatePouredParticles();
            processAlchemyJobs();
            updateMagicParticles();
            updateMagicEmitters(); 
            updateTriggers();

            // --- NEW PROPAGATING LOCAL LIGHTING ---
            // This BFS will process the initial active chunks and any others connected by visible materials.
            const lightingQueue = [...activeChunks];     // Seed the queue with physics-active chunks
            const processedChunks = new Set(activeChunks); // Keep track of what's been processed this frame

            let head = 0;
            while (head < lightingQueue.length) {
                const chunkToUpdate = lightingQueue[head++];
                const newlyActivatedNeighbors = updateLocalLightingAndFindNeighbors(chunkToUpdate);

                for (const neighbor of newlyActivatedNeighbors) {
                    if (!processedChunks.has(neighbor)) {
                        processedChunks.add(neighbor);
                        lightingQueue.push(neighbor);
                    }
                }
            }

            // if (frameCount % LIGHTING_UPDATE_INTERVAL === 0) {
            //     updateLighting();
            // }

            if (isPouring) {
                pourFromContainer();
            }

            // Add this block to continuously store
            if (isStoring) {
                storeMaterial(mouse.worldX, mouse.worldY);
            }

            // Activate the chunk the mouse is currently interacting with
            if (isDrawing || isPouring || isStoring) {
                activateChunkAt(mouse.worldX, mouse.worldY);
            }

            // --- SIMULATIONS ---
            for (let i = 0; i < SIMULATION_STEPS_PER_FRAME; i++) {
                // Run main world simulation
                runWorldSimulationWithChunks(movedWorld);
                
                // Run container simulations only once per frame to save performance
                if (i === 0) {
                   runSimulationOnSmallGrid(movedPouch, pouchGrid, pouchWidth, pouchHeight);
                   runSimulationOnSmallGrid(movedFlask, flaskGrid, flaskWidth, flaskHeight);
                }
            }
            
            updateCamera();
            mouse.worldX = Math.floor(camera.x + mouse.x / scale);
            mouse.worldY = Math.floor(camera.y + mouse.y / scale);

            // --- RENDER LOGIC ---
            render();
            renderContainers();
            drawHUD();
            
            if ((frameCount % 2) === 0) { // Update hover material at 30fps
                updateHoverMaterial();
            }

            requestAnimationFrame(gameLoop);
        }

        function updateUI()
        {
            if ((hudTimer++ & 1) === 0) { // ~30 Hz
                updateHoverMaterial();
            }
            hudFPS = fps;

        }

        function drawHUD() {
            const padding = 6;
            const x = renderWidth - 6;
            const y = 6;

            ctx.imageSmoothingEnabled = false;
            ctx.font = '12px monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(
                renderWidth - 150,
                4,
                146,
                34
            );

            // Text
            ctx.fillStyle = '#00ff90';
            ctx.fillText(`FPS: ${hudFPS}`, x, y);

            ctx.fillStyle = '#ffd966';
            ctx.fillText(`MAT: ${hudMaterial}`, x, y + 14);
        }

        /**
         * Creates a new trigger zone and adds it to the world.
         * @param {object} options - Configuration for the trigger.
         * @returns {number} The unique ID of the trigger.
         */
        function createTrigger(options) {
            const trigger = {
                id: nextTriggerId++,
                x: options.x,
                y: options.y,
                width: options.width,
                height: options.height,
                onEnter: options.onEnter || function() {}, // What to do when player enters
                onLeave: options.onLeave || function() {}, // What to do when player leaves
                onInteract: options.onInteract || function() {},
                isActive: false, // Tracks if the player is currently inside
                // A generic object to store any data this trigger needs to remember, like an emitter ID.
                associatedData: options.associatedData 
            };
            triggers.push(trigger);
            return trigger.id;
        }

        /**
         * Checks the player's position against all triggers and manages interaction state.
         */
        function updateTriggers() {
            const playerCheckX = player.x + player.width / 2;
            const playerCheckY = player.y + player.height;

            let canCurrentlyInteract = false;
            let activeTrigger = null;

            for (const trigger of triggers) {
                const isPlayerInside = (
                    playerCheckX >= trigger.x &&
                    playerCheckX <= trigger.x + trigger.width &&
                    playerCheckY >= trigger.y &&
                    playerCheckY <= trigger.y + trigger.height
                );

                if (isPlayerInside) {
                    // We found a trigger the player is inside.
                    canCurrentlyInteract = true;
                    activeTrigger = trigger;

                    if (!trigger.isActive) {
                        trigger.isActive = true;
                        trigger.onEnter(trigger);
                    }
                } else {
                    if (trigger.isActive) {
                        trigger.isActive = false;
                        trigger.onLeave(trigger);
                    }
                }
            }

            // After checking all triggers, update the player's global state.
            player.canInteract = canCurrentlyInteract;
            player.currentTrigger = activeTrigger;
        }

        /**
         * Renders the alchemy reaction selection UI when it's active.
         */
        function renderAlchemyUI() {
            if (!isAlchemyUIVisible) return;

            // Draw a semi-transparent background to dim the game
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, renderWidth, renderHeight);

            // Draw the main UI box
            const boxWidth = 300;
            const boxHeight = 150;
            const boxX = (renderWidth - boxWidth) / 2;
            const boxY = (renderHeight - boxHeight) / 2;
            ctx.fillStyle = '#222';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeStyle = '#888';
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

            // Draw text
            ctx.fillStyle = 'white';
            ctx.font = '16px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText("Select a Reaction:", boxX + 10, boxY + 10);

            // List all available reactions from our registry
            let yOffset = 40;
            let reactionIndex = 1;
            for (const key in ALCHEMY_REACTIONS) {
                const reaction = ALCHEMY_REACTIONS[key];
                ctx.fillText(`[${reactionIndex}] ${reaction.name}`, boxX + 20, boxY + yOffset);
                yOffset += 20;
                reactionIndex++;
            }

            ctx.fillStyle = '#aaa';
            ctx.fillText("Press [ESC] to close.", boxX + 10, boxY + boxHeight - 25);
        }

        /**
         * Updates the text content of the loading screen overlay.
         * @param {string} message - The message to display.
         */
        function updateLoadingStatus(message) {
            document.getElementById('loading-status').innerText = message;
        }

        /**
         * Asynchronously loads all game assets and world data, updating the UI between steps.
         */
        async function mainLoader() {
            const loadingOverlay = document.getElementById('loading-overlay');
            
            // A helper function to pause execution and allow the browser to render UI updates.
            const yieldToBrowser = () => new Promise(resolve => setTimeout(resolve, 20)); // 20ms pause

            updateLoadingStatus('Generating Background...');
            await yieldToBrowser();
            skyImageData = generateCaveBackground(worldWidth, worldHeight);

            updateLoadingStatus('Generating Perlin Caves...');
            await yieldToBrowser();
            generateCavesWithPerlinNoise(worldWidth, worldHeight, grid);

            updateLoadingStatus('Constructing Ancient Structures...');
            await yieldToBrowser();
            generateAlchemyStation();

            updateLoadingStatus('Securing World Borders...');
            await yieldToBrowser();
            for (let y = 0; y < worldHeight; y++) {
                setGrid(getIdx(0, y), MAT.ADAMANTIUM);
                setGrid(getIdx(1, y), MAT.ADAMANTIUM);
                setGrid(getIdx(worldWidth - 1, y), MAT.ADAMANTIUM);
                setGrid(getIdx(worldWidth - 2, y), MAT.ADAMANTIUM);
            }
             for (let x = 0; x < worldWidth; x++) {
                setGrid(getIdx(x, 0), MAT.ADAMANTIUM);
                setGrid(getIdx(x, 1), MAT.ADAMANTIUM);
                setGrid(getIdx(x, worldHeight - 1), MAT.ADAMANTIUM);
                setGrid(getIdx(x, worldHeight - 2), MAT.ADAMANTIUM);
            }

            updateLoadingStatus('Activating Dynamic Matter...');
            await yieldToBrowser();
            initializeChunks();

            updateLoadingStatus('Igniting the First Light...');
            await yieldToBrowser();
            updateLighting(true);

            updateLoadingStatus('Done!');
            await new Promise(resolve => setTimeout(resolve, 100)); // Brief pause to see "Done!"

            // Hide the overlay with a fade-out effect for a smooth transition
            loadingOverlay.style.transition = 'opacity 0.5s';
            loadingOverlay.style.opacity = '0';
            await new Promise(resolve => setTimeout(() => {
                loadingOverlay.style.display = 'none';
                resolve();
            }, 500));
            
            // The game is fully loaded, now we can start the main loop.
            gameLoop();
        }

        /**
         * Renders the player's HP and Hover Energy bars in the top-left corner of the canvas.
         */
        function renderPlayerStatsUI() {
            const barWidth = 150;
            const barHeight = 10;
            const x = 15;
            let y = 15; // Starting Y position

            ctx.imageSmoothingEnabled = false;

            // --- HP Bar ---
            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Fill
            const hpPercent = player.hp / player.maxHp;
            ctx.fillStyle = '#d14242'; // Red for health
            ctx.fillRect(x, y, barWidth * hpPercent, barHeight);

            // Text Label
            ctx.fillStyle = 'white';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${player.hp}/${player.maxHp}`, x + barWidth / 2, y + barHeight / 2);

            // --- Hover Energy Bar ---
            y += barHeight + 5; // Move down for the next bar

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barWidth, barHeight);

            // Fill
            const energyPercent = player.hoverEnergy / player.maxHoverEnergy;
            ctx.fillStyle = '#DDED64';
            ctx.fillRect(x, y, barWidth * energyPercent, barHeight);
            
            // Text Label
            ctx.fillStyle = 'white';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${Math.round(player.hoverEnergy)}/${player.maxHoverEnergy}`, x + barWidth / 2, y + barHeight / 2);
        }


        //loadInitialScene();
        //gameLoop();
        mainLoader();
    </script>
</body>
</html>