<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Sand Platformer</title>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            user-select: none;
            overflow: hidden;
        }
        h1 { margin-bottom: 10px; }
        .controls {
            margin-bottom: 10px;
            background: #333;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        .btn-sand { background-color: #f6d7b0; color: #333; }
        .btn-water { background-color: #4fa4f4; color: white; }
        .btn-soil { background-color: #5d4037; color: white; }
        .btn-wall { background-color: #888; color: white; }
        .btn-gas { background-color: #e0e0e0; color: #333; }
        .btn-fire { background-color: #ff4500; color: white; }
        .btn-oil {
            background-color: #5a4622;
            color: #fff;
        }
        .btn-coal {
            background-color: #111111;
            color: #fff;
        }
        .btn-wood { background-color: #8b4513; color: white; }
        .btn-gunpowder { background-color: #444; color: #fff; border: 1px solid #777; }
        .btn-acid { background-color: #00ff00; color: white; }
        .btn-glass { background-color: #e0e0ff; color: #333; }
        .btn-glass-wall { background-color: #b4b4e0; color: #333; }
        .btn-adamantium { background-color: #4d5257; color: white; border: 1px solid #aeb5be; }
        .btn-copper { background-color: #b87333; color: white; }
        .btn-silver { background-color: #c0c0c0; color: #333; }
        .btn-gold { background-color: #ffd700; color: #333; }
        .btn-platinum { background-color: #e5e4e2; color: #333; }
        .btn-rune-wall { background-color: #2a2a3a; color: #d0c0ff; border: 1px solid #5a4a7a; }
        .btn-eraser { background-color: #000; color: white; border: 1px solid #555; }
        button.active {
            outline: 2px solid white;
            box-shadow: 0 0 8px rgba(255,255,255,0.6);
        }
        .info-bar { font-size: 14px; color: #ccc; }
        .info-bar strong { color: white; }
        canvas {
            border: 2px solid #555;
            background-color: #000;
            cursor: crosshair;
            image-rendering: pixelated; 
        }
        #controls_ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 8px 10px;
            border-radius: 6px;
            pointer-events: none;
        }
    </style>
</head>
<body>
   <div id="loading-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a2a; color: #fff; z-index: 1000; display: flex; justify-content: center; align-items: center; flex-direction: column;">
        <h1 style="font-size: 2.5em; margin-bottom: 20px;">Falling Sand Platformer</h1>
        <p id="loading-status" style="font-size: 1.2em; font-family: monospace;">Initializing...</p>
    </div>

    <h1>Falling Sand Platformer</h1>
    <div class="info-bar">
        Use <strong>A/D</strong> to Move, <strong>W</strong> to Jump. Use the mouse to build and destroy.
    </div>

    <div class="controls">
        <button class="btn-sand active" onclick="setMaterial('sand')">Sand</button>
        <button class="btn-soil" onclick="setMaterial('soil')">Soil</button>
        <button class="btn-water" onclick="setMaterial('water')">Water</button>
        <button class="btn-gas" onclick="setMaterial('gas')">Gas</button>
        <button class="btn-wall" onclick="setMaterial('wall')">Wall</button>
        <button class="btn-wood" onclick="setMaterial('wood')">Wood</button>
        <button class="btn-fire" onclick="setMaterial('fire')">Fire</button>
        <button class="btn-gunpowder" onclick="setMaterial('gunpowder')">Gunpowder</button>
        <button class="btn-oil" onclick="setMaterial('oil')">Oil</button>
        <button class="btn-coal" onclick="setMaterial('coal')">Coal</button>
        <button class="btn-acid" onclick="setMaterial('acid')">Acid</button>
        <button class="btn-glass" onclick="setMaterial('glass')">Glass</button>
        <button class="btn-glass-wall" onclick="setMaterial('glass-wall')">Glass Wall</button>
        <button class="btn-adamantium" onclick="setMaterial('adamantium')">Adamantium</button>
        <button class="btn-copper" onclick="setMaterial('copper')">Copper</button>
        <button class="btn-silver" onclick="setMaterial('silver')">Silver</button>
        <button class="btn-gold" onclick="setMaterial('gold')">Gold</button>
        <button class="btn-platinum" onclick="setMaterial('platinum')">Platinum</button>
        <button class="btn-rune-wall" onclick="setMaterial('rune-wall')">Rune Wall</button>
        <button class="btn-eraser" onclick="setMaterial('empty')">Eraser</button>
    </div>

    <div id="controls_ui">
        <b>Controls</b><br>
        A / D – Move<br>
        W – Jump<br>
        Q – Switch Container<br>
        Left Click – Pour<br>
        Right Click – Store<br>
        Middle Click – Paint Brush
    </div>

    <div id="generation-status" style="position: fixed; bottom: 10px; left: 10px; color: white; font-family: monospace; font-size: 14px; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; pointer-events: none; display: none; z-index: 1001;">
        Generating...
    </div>

    <canvas id="canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/earcut@2.2.4/dist/earcut.min.js"></script>
    <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>


    <script>
        // --- CONFIGURATION ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const pl = planck;

        const generationWorker = new Worker('generation.worker.js'); // ADD THIS LINE
        let WORLD_SEED = 0; // Will be set in mainLoader

        const world = new pl.World({
            gravity: pl.Vec2(0, 10)
        });

        // --- Add this listener for SOLID splashes ---
        world.on('begin-contact', function(contact) {
            const now = performance.now();
            const SPLASH_COOLDOWN_MS = 200;
            const MIN_SPLASH_SPEED = 1.8;

            let dynamicBody;
            if (contact.getFixtureA().getBody().getType() === 'dynamic' && contact.getFixtureB().getBody().getType() === 'static') {
                dynamicBody = contact.getFixtureA().getBody();
            } else if (contact.getFixtureB().getBody().getType() === 'dynamic' && contact.getFixtureA().getBody().getType() === 'static') {
                dynamicBody = contact.getFixtureB().getBody();
            } else {
                return;
            }

            const bodyInstance = dynamicBody.getUserData();
            if (!bodyInstance) return;

            bodyInstance.lastSplashTime = bodyInstance.lastSplashTime ?? 0;
            if (now - bodyInstance.lastSplashTime < SPLASH_COOLDOWN_MS) return;

            const manifold = contact.getWorldManifold();
            if (!manifold.points[0]) return;
            const point = manifold.points[0];

            const impactSpeed = dynamicBody.getLinearVelocityFromWorldPoint(point).length();
            if (impactSpeed < MIN_SPLASH_SPEED) return;

            const worldX = Math.floor(point.x * B2_SCALE);
            const worldY = Math.floor(point.y * B2_SCALE);
            const materialType = getGrid(worldX, worldY);

            // THIS LISTENER ONLY CARES ABOUT SOLIDS
            if (SPLASHABLE_SOLIDS.has(materialType)) {
                createSplashEffect(worldX, worldY, materialType, impactSpeed);
                bodyInstance.lastSplashTime = now;
            }
        });

        const B2_SCALE = 30; // 30 pixels = 1 meter in the physics world
        let rigidBodies = [];
        let staticWorldBodies = []; // To hold temporary terrain colliders
        let activeStaticChunks = new Set();
        let bodiesToDestroy = [];   // NEW: A "kill list" for entire b2Bodies
        let tempVec1 = null;
        let tempVec2 = null;

        const CHUNK_SIZE = 16; // Chunks will be 16x16 pixels
        const CHUNK_SIZE_SQ = CHUNK_SIZE * CHUNK_SIZE;
        let chunkWidth, chunkHeight; // No longer used for world bounds
        
        // --- NEW: CHUNK-BASED WORLD DATA ---
        const chunkMap = new Map();       // Main material grid
        const lightChunkMap = new Map();    // Lighting data
        const etcChunkMap = new Map();      // For ignition timers, rigid body stubs, etc.
        const activeChunks = new Set();     // A set of active chunk KEYs for the current frame
        const nextActiveChunks = new Set(); // A set of chunk KEYs to activate for the *next* frame


        // NEW: Increased view area and reduced scale
        const viewWidth = 480;
        const viewHeight = 270;
        const scale = 3; // Smaller pixels

        const SIMULATION_STEPS_PER_FRAME = 2;

        // --- SECTOR STREAMING CONFIGURATION ---
        const SECTOR_SIZE = 512;
        const WORLD_LAYER_HEIGHT = 2000;
        let sectorGrid = new Map(); // Will store 'unloaded', 'queued', or 'ready' for each sector
        let lastPlayerSectorX = -1; // Used to track when the player crosses a sector boundary
        let lastPlayerSectorY = -1;

        canvas.width = viewWidth;
        canvas.height = viewHeight;

        canvas.style.width = viewWidth * scale + "px";
        canvas.style.height = viewHeight * scale + "px";

        canvas.style.imageRendering = "pixelated";
        
        // REMOVED worldWidth and worldHeight constants

        const renderWidth = viewWidth;
        const renderHeight = viewHeight;

        const imageData = ctx.createImageData(renderWidth, renderHeight);
        const pixels = imageData.data; // Uint8ClampedArray

        // --- MATERIAL DEFINITIONS ---
        const MAT = {
            EMPTY: 0, ROCK_WALL: 1, SAND: 2, WATER: 3, SOIL: 4, GAS: 5, 
            WOOD: 10, FIRE: 11, GUNPOWDER: 12, GUNPOWDER_IGNITED: 13,
            OIL: 14, OIL_BURNING: 15,
            COAL:16, COAL_BURNING:17,
            ACID:18, GLASS:19, GLASS_WALL: 20,
            ADAMANTIUM: 21, COPPER: 22, SILVER: 23, GOLD: 24, PLATINUM: 25, RUNE_WALL: 26,
            SANDSTONE_WALL: 27, VOLCANIC_WALL: 28, LABYRINTH_WALL: 29, MAGIC_WALL: 30,
            RIGID_BODY_STUB: 99
        };

        const COLORS = {
            [MAT.ROCK_WALL]: [100, 100, 100], [MAT.SAND]: [246, 215, 176],
            [MAT.WATER]: [79, 164, 244], [MAT.SOIL]: [93, 64, 55],
            [MAT.GAS]: [200, 200, 200], [MAT.WOOD]: [139, 69, 19],
            [MAT.FIRE]: [255, 69, 0], [MAT.GUNPOWDER]: [60, 60, 60],
            [MAT.GUNPOWDER_IGNITED]: [120, 80, 80], [MAT.OIL]: [90, 70, 30], [MAT.OIL_BURNING]: [255, 69, 0],
            [MAT.COAL]: [30, 30, 30], [MAT.COAL_BURNING]: [255, 69, 0],
            [MAT.ACID]: [0, 255, 0], [MAT.GLASS]: [200, 200, 255], [MAT.GLASS_WALL]: [180, 180, 235],
            [MAT.ADAMANTIUM]: [77, 82, 87], [MAT.COPPER]: [184, 115, 51],
            [MAT.SILVER]: [192, 192, 192], [MAT.GOLD]: [255, 215, 100],
            [MAT.PLATINUM]: [229, 228, 226], [MAT.RUNE_WALL]: [200, 200, 100],
            [MAT.SANDSTONE_WALL]: [130, 100, 70],
            [MAT.VOLCANIC_WALL]: [45, 20, 20],
            [MAT.LABYRINTH_WALL]: [70, 75, 80],
            [MAT.MAGIC_WALL]: [40, 25, 60]
        };

        const MATERIAL_NAME = {
            [MAT.EMPTY]: 'Empty',
            [MAT.ROCK_WALL]: 'Wall',
            [MAT.SAND]: 'Sand',
            [MAT.WATER]: 'Water',
            [MAT.SOIL]: 'Soil',
            [MAT.GAS]: 'Gas',
            [MAT.WOOD]: 'Wood',
            [MAT.FIRE]: 'Fire',
            [MAT.GUNPOWDER]: 'Gunpowder',
            [MAT.GUNPOWDER_IGNITED]: 'Gunpowder (Ignited)',
            [MAT.OIL]: 'Oil',
            [MAT.OIL_BURNING]: 'Burning Oil',
            [MAT.COAL]: 'Coal',
            [MAT.COAL_BURNING]: 'Burning Coal',
            [MAT.ACID]: 'Acid',
            [MAT.GLASS]: 'Glass',
            [MAT.GLASS_WALL]: 'Glass Wall',
            [MAT.ADAMANTIUM]: 'Adamantium', 
            [MAT.COPPER]: 'Copper',
            [MAT.SILVER]: 'Silver', 
            [MAT.GOLD]: 'Gold', 
            [MAT.PLATINUM]: 'Platinum',
            [MAT.RUNE_WALL]: 'Rune Wall',
            [MAT.SANDSTONE_WALL]: 'Sandstone Wall', 
            [MAT.VOLCANIC_WALL]: 'Volcanic Wall',
            [MAT.LABYRINTH_WALL]: 'Labyrinth Wall', 
            [MAT.MAGIC_WALL]: 'Magic Wall'
        };

        const WALL_TYPES = new Set([
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, 
            MAT.LABYRINTH_WALL, MAT.MAGIC_WALL
        ]);

        let lastColliderUpdateTime = 0;
        const COLLIDER_UPDATE_INTERVAL = 100;

        // --- RUNE DEFINITIONS ---
        // A library of rune patterns. 1 represents the rune material, 0 is empty.
        const DWARVEN_RUNES = {
            // A simple 7x9 pixel font for the runes
            RUNE_WIDTH: 7,
            RUNE_HEIGHT: 9,
            PATTERNS: [
                // "Axe"
                [
                    [0,1,1,1,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,0,1,1,0]
                ],
                // "Hammer"
                [
                    [1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0]
                ],
                // "Shield"
                [
                    [1,1,1,1,1,1,1],
                    [1,0,0,1,0,0,1],
                    [1,0,0,1,0,0,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1]
                ],
                // "Spear"
                [
                    [0,0,0,1,0,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,1,1,1,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ],
                // "Pickaxe"
                [
                    [1,1,0,0,0,1,1],
                    [0,1,1,0,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ]
            ]
        };


        const LIQUID_DENSITY = {
            [MAT.ACID]: 3,
            [MAT.WATER]: 2,
            [MAT.OIL]: 1,
            [MAT.OIL_BURNING]: 1
        };

        const ALWAYS_VISIBLE_MATERIALS = new Set([
            MAT.RUNE_WALL,
            MAT.ADAMANTIUM // Also used for the alchemy station and world borders
        ]);

        const SHIMMERING_METALS = new Set([
            MAT.ADAMANTIUM,
            MAT.COPPER,
            MAT.SILVER,
            MAT.GOLD,
            MAT.PLATINUM,
            MAT.RUNE_WALL
        ]);

        const SPLASHABLE_SOLIDS = new Set([
            MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS
        ]);

        const STATIC_MATERIALS = new Set([
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, MAT.LABYRINTH_WALL, MAT.MAGIC_WALL, // All walls added
            MAT.WOOD,
            MAT.GLASS_WALL,
            MAT.ADAMANTIUM,
            MAT.RUNE_WALL
        ]);


        const MAX_STEP_HEIGHT = 2;
        const GRAVITY = 0.1;
        const MAX_FALL_SPEED = 4;
        const MAX_HOVER_SPEED = 4;

        const PLAYER_DEFAULT_DAMPING = 0.5;
        const PLAYER_SUBMERGED_DAMPING = 5.0;
        const BUOYANCY_FORCE = 6.0;

        const MAX_CHUNKS_PER_FRAME = 250;
        const REGEN_COOLDOWN = 250;
        const REBUILD_COOLDOWN = 250;
        const MIN_ISLAND_PIXELS = 5;

        // --- Add these new variables ---
        const BLOOM_MATERIALS = {
            [MAT.FIRE]: { color: [255, 150, 50], intensity: 0.9, radius: 12 },
            [MAT.OIL_BURNING]: { color: [255, 165, 0], intensity: 0.8, radius: 10 },
            [MAT.COAL_BURNING]: { color: [255, 140, 20], intensity: 0.7, radius: 8 },
            [MAT.GUNPOWDER_IGNITED]: { color: [200, 100, 100], intensity: 0.5, radius: 4 },
            [MAT.RUNE_WALL]: { color: [200, 180, 255], intensity: 0.3, radius: 6 },
            [MAT.COPPER]: { color: [220, 200, 200], intensity: 0.01, radius: 3 },
            [MAT.SILVER]: { color: [200, 200, 220], intensity: 0.01, radius: 3 },
            [MAT.GOLD]: { color: [220, 220, 180], intensity: 0.01, radius: 3 },
        };

        // Off-screen canvas for the bloom effect
        let bloomCanvas;
        let bloomCtx;
        // --- End of new variables ---

        let pendingActiveChunks = []; // An array to hold active chunks that were deferred from the previous frame.
        
        // REMOVED old grid definitions
        let currentMaterial = MAT.SAND;
        let isDrawing = false;
        let isStoring = false;
        let frameCount = 0;
        let playerFacingRight = true;
		let projectiles = [];
        let alchemyJobs = [];

        let tSimMs = 0, tRenderMs = 0, tOtherMs = 0, tOtherMs2 = 0, tOtherMs3 = 0;
        const movedInFrame = new Set();

        const MAX_LIGHT_LEVEL = 30;
        const LIGHTING_UPDATE_INTERVAL = 30;
        const VISIBLE_LIQUID_SCAN_INTERVAL = 5; // Update lighting every 30 frames

        // --- Magic Particle System ---
        const MAX_MAGIC_PARTICLES = 5000;
        const magicParticlePool = [];
        for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
            magicParticlePool.push({ x: 0, y: 0, vx: 0, vy: 0, lifespan: 0, color: [0,0,0], gravity: 0, active: false });
        }

        let magicEmitters = [];
        let nextEmitterId = 0;
        let firePixelsCoords = [];
        let triggers = [];
        let nextTriggerId = 0;
        let isAlchemyUIVisible = false;

        let lastFpsTime = performance.now();
        let framesThisSecond = 0;
        let fps = 0;
        let leftToRight = true;

        let hudFPS = 0;
        let hudMaterial = '--';
        let hudTimer = 0;
        
        // --- NEW: TILEABLE BACKGROUND ---
        let backgroundPattern = null;
        const BACKGROUND_TILE_SIZE = 512;

        // --- INVENTORY AND CONTAINERS ---
        const pouchWidth = 32;
        const pouchHeight = 32;
        const flaskWidth = 24;
        const flaskHeight = 40;

        let pouchGrid = new Array(pouchWidth * pouchHeight).fill(MAT.EMPTY);
        let flaskGrid = new Array(flaskWidth * flaskHeight).fill(MAT.EMPTY);

        let activeContainer = 'pouch'; // 'pouch' or 'flask'
        let isPouring = false;
        let pourCooldown = 0;
        let pouredParticles = []; // For the pouring stream effect
        let activeStubs = [];

        const STORABLE_SOLIDS = new Set([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM]);
        const STORABLE_LIQUIDS = new Set([MAT.WATER, MAT.OIL, MAT.ACID]);

        let fluidsCanvas = null;
        let fluidsCtx = null;
        let fluidsImageData = null;
        let fluidsPixels = null;

        // Tune per material/category
        function fluidAlpha(type) {
            if (type === MAT.GAS) return 80;     // ~30%
            if (LIQUIDS.has(type)) return 140;   // ~55%
            return 255;
        }

        function isFluid(type) {
            return type === MAT.GAS || LIQUIDS.has(type);
        }

        // --- START: NEW CHUNK-BASED DATA HELPERS ---
        
        /**
         * Calculates the local 1D index from local 2D coordinates within a chunk.
         */
        const getLocalIndex = (lx, ly) => ly * CHUNK_SIZE + lx;

        function getChunk(map, key, fillValue = 0) {
            if (!map.has(key)) {
                // This part is rarely called, so we can calculate cx, cy here if needed for the object.
                // However, it's better to pass them in if we can.
                const newChunk = {
                    key: key,
                    // cx, cy will be added by the functions that call this
                    data: new Uint8Array(CHUNK_SIZE_SQ).fill(fillValue),
                    staticBody: null,
                    dirty: true,
                    lastRegenTime: 0
                };
                map.set(key, newChunk);
                return newChunk;
            }
            return map.get(key);
        }

        function getGrid(x, y) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cy = Math.floor(y / CHUNK_SIZE);
            const key = coordToKey(cx, cy); // USE NUMERIC KEY

            const chunk = chunkMap.get(key);
            if (!chunk) {
                return MAT.EMPTY;
            }

            const lx = x - cx * CHUNK_SIZE;
            const ly = y - cy * CHUNK_SIZE;
            return chunk.data[getLocalIndex(lx, ly)];
        }

        function setGrid(x, y, type) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cy = Math.floor(y / CHUNK_SIZE);
            const key = coordToKey(cx, cy); // USE NUMERIC KEY
            const chunk = getChunk(chunkMap, key, MAT.EMPTY);
            
            // Store coordinates in chunk if they don't exist
            if (chunk.cx === undefined) {
                chunk.cx = cx;
                chunk.cy = cy;
            }

            const lx = x - cx * CHUNK_SIZE;
            const ly = y - cy * CHUNK_SIZE;
            const lIdx = getLocalIndex(lx, ly);

            const oldType = chunk.data[lIdx];
            if (type === oldType) return;

            const wasSolid = isSolidForPlayer(oldType);
            const isSolid = isSolidForPlayer(type);

            if (wasSolid !== isSolid) {
                chunk.dirty = true;
            }
            
            chunk.data[lIdx] = type;
            activateChunkAt(x, y);
        }

        function getAuxData(map, x, y, defaultValue = 0) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cy = Math.floor(y / CHUNK_SIZE);
            const key = coordToKey(cx, cy); // USE NUMERIC KEY

            const chunk = map.get(key);
            if (!chunk) return defaultValue;
            
            const lx = x - cx * CHUNK_SIZE;
            const ly = y - cy * CHUNK_SIZE;
            return chunk.data[getLocalIndex(lx, ly)];
        }
        
        function setAuxData(map, x, y, value) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cy = Math.floor(y / CHUNK_SIZE);
            const key = coordToKey(cx, cy); // USE NUMERIC KEY
            const chunk = getChunk(map, key, 0);

            if (chunk.cx === undefined) {
                chunk.cx = cx;
                chunk.cy = cy;
            }
            
            const lx = x - cx * CHUNK_SIZE;
            const ly = y - cy * CHUNK_SIZE;
            chunk.data[getLocalIndex(lx, ly)] = value;
        }

        /**
         * Combines two 32-bit integers (x, y coordinates) into a single unique 64-bit-safe number.
         * This is extremely fast and avoids creating new strings for keys.
         */
        function coordToKey(x, y) {
            // Using multiplication with a large prime is a simple and effective way to create a unique hash.
            // This works reliably for both positive and negative coordinates in JavaScript.
            return x * 374761393 + y * 668265263;
        }

        // --- END: NEW CHUNK-BASED DATA HELPERS ---


        function validatePolygon(points) {
            // This function can be kept for debugging physics shapes, no changes needed.
            return;
        }

        /**
         * An empty, "bare-bones" version of the settling function for testing.
         */
        async function preSettleSector(sectorX, sectorY) {
            return Promise.resolve();
        }

        // --- ASYNCHRONOUS GENERATION WORKER & QUEUE ---
        let generationQueue = [];

        // In index.html

        generationWorker.onmessage = (event) => {
            const { type, sx, sy, chunks, lightChunks } = event.data; // Now receives lightChunks

            if (type === 'result') {
                // Integrate terrain chunks
                for (const [key, payload] of chunks) {
                    const chunk = getChunk(chunkMap, key);
                    chunk.data = payload.data;
                    chunk.cx = payload.cx;
                    chunk.cy = payload.cy;
                }

                // --- THIS IS THE CHANGE ---
                // Integrate light chunks
                for (const [key, payload] of lightChunks) {
                    const chunk = getChunk(lightChunkMap, key);
                    chunk.data = payload.data;
                    chunk.cx = payload.cx;
                    chunk.cy = payload.cy;
                }
                // --- END OF CHANGE ---

                // The bake is now done in the worker, so we REMOVE the call from here.
                // bakeLightingForSector(sx, sy); // <-- DELETE THIS LINE

                sectorGrid.set(coordToKey(sx, sy), 'ready');
                isGenerating = false;
                isRenderCacheInvalid = true; // Invalidate cache now that all data is ready
            }
        };

        // In index.html

        function gatherBorderContext(sectorX, sectorY) {
            const context = {}; // Use a plain object, not a Map
            const startX = sectorX * SECTOR_SIZE;
            const startY = sectorY * SECTOR_SIZE;
            const endX = startX + SECTOR_SIZE;
            const endY = startY + SECTOR_SIZE;

            for (let y = startY - 1; y <= endY; y++) {
                for (let x = startX - 1; x <= endX; x++) {
                    if (x >= startX && x < endX && y >= startY && y < endY) continue;

                    const neighborSectorX = Math.floor(x / SECTOR_SIZE);
                    const neighborSectorY = Math.floor(y / SECTOR_SIZE);
                    if (sectorGrid.get(coordToKey(neighborSectorX, neighborSectorY)) === 'ready') {
                        const key = coordToKey(x, y);
                        // Assign to object property
                        context[key] = {
                            terrain: getGrid(x, y),
                            light: getAuxData(lightChunkMap, x, y)
                        };
                    }
                }
            }
            return context;
        }

        // This function will be called from our game loop to feed tasks to the worker.
        let isGenerating = false; // This now acts as a simple lock
        
        function checkGenerationQueue() {
            if (isGenerating || generationQueue.length === 0) {
                return;
            }

            isGenerating = true;
            const statusElement = document.getElementById('generation-status');
            statusElement.innerText = `Generating... (${generationQueue.length} sectors left)`;
            statusElement.style.display = 'block';

            const sector = generationQueue.shift();
            
            // --- THIS IS THE CHANGE ---
            // Gather border context before sending the request
            const borderContext = gatherBorderContext(sector.sx, sector.sy);
            
            generationWorker.postMessage({ 
                type: 'generate-and-bake', 
                sx: sector.sx, 
                sy: sector.sy,
                borderContext: borderContext
            });
            // --- END OF CHANGE ---
        }

        function updateSectors() {
            const playerSectorX = Math.floor(player.x / SECTOR_SIZE);
            const playerSectorY = Math.floor(player.y / SECTOR_SIZE);

            if (playerSectorX === lastPlayerSectorX && playerSectorY === lastPlayerSectorY) return;
            
            lastPlayerSectorX = playerSectorX;
            lastPlayerSectorY = playerSectorY;

            for (let sy = playerSectorY - 1; sy <= playerSectorY + 1; sy++) {
                for (let sx = playerSectorX - 1; sx <= playerSectorX + 1; sx++) {
                    const key = coordToKey(sx, sy); // USE NUMERIC KEY
                    const sectorState = sectorGrid.get(key);

                    if (!sectorState || sectorState === 'unloaded') {
                        sectorGrid.set(key, 'queued');
                        generationQueue.push({ sx, sy });
                    }
                }
            }
        }

        class RigidBody {
            constructor(x, y, width, height, material) {
                this.width = width;
                this.height = height;
                this.pixels = new Uint8Array(width * height);
                this.moved = new Uint8Array(width * height);
                this.materialType = material;
                this.fixtureCount = 0;
                
                this.isDestroyed = false;
                this.needsShapeUpdate = false;
                this.lastRebuildTime = 0;
                this.isSplit = false;

                this.pixels.fill(this.materialType);

                this.body = world.createBody({
                    type: 'dynamic',
                    position: pl.Vec2(x / B2_SCALE, y / B2_SCALE)
                });
                this.body.setUserData(this);
                
                this._createFixturesFromPixels(); 
            }

            rebuildFixtures() {
                let f = this.body.getFixtureList();
                while (f) {
                    const next = f.getNext();
                    this.body.destroyFixture(f);
                    f = next;
                }
                this._createFixturesFromPixels();
                this.needsShapeUpdate = false;
            }

            getBinaryMask() {
                const mask = new Uint8Array(this.width * this.height);
                for (let i = 0; i < mask.length; i++) {
                    const t = this.pixels[i];
                    mask[i] = (t !== MAT.EMPTY && t !== MAT.GAS) ? 1 : 0;
                }
                return mask;
            }

            _createFixturesFromPixels() {
                this.fixtureCount = 0;
                const w = this.width;
                const h = this.height;
                const mask = new Uint8Array(w * h);

                for (let i = 0; i < mask.length; i++) {
                    const t = this.pixels[i];
                    mask[i] = (t !== MAT.EMPTY && t !== MAT.GAS) ? 1 : 0;
                }

                if (!mask.some(v => v === 1)) {
                    this.isDestroyed = true;
                    return;
                }

                const islands = extractIslands(mask, w, h);

                for (const island of islands) {
                    const outline = marchingSquares(island, w, h);
                    if (outline.length < 3) continue;
                    const preSimplified = simplifyDouglasPeucker(outline, 1.0);
                    if (preSimplified.length < 3) continue;
                    const simplified = removeCollinear(preSimplified, 0.01);
                    if (simplified.length < 3) continue;

                    validatePolygon(simplified);

                    const flat = [];
                    for (const p of simplified) flat.push(p.x, p.y);
                    const indices = earcut(flat);

                    for (let i = 0; i < indices.length; i += 3) {
                        const p0 = simplified[indices[i]];
                        const p1 = simplified[indices[i + 1]];
                        const p2 = simplified[indices[i + 2]];

                        const ax = (p0.x - w / 2) / B2_SCALE, ay = (p0.y - h / 2) / B2_SCALE;
                        const bx = (p1.x - w / 2) / B2_SCALE, by = (p1.y - h / 2) / B2_SCALE;
                        const cx = (p2.x - w / 2) / B2_SCALE, cy = (p2.y - h / 2) / B2_SCALE;

                        const area = Math.abs(ax*(by-cy) + bx*(cy-ay) + cx*(ay-by)) * 0.5;
                        if (area < 0.00001) continue;

                        const cross = (bx-ax)*(cy-ay) - (by-ay)*(cx-ax);
                        let verts = (cross < 0)
                            ? [pl.Vec2(ax,ay), pl.Vec2(cx,cy), pl.Vec2(bx,by)]
                            : [pl.Vec2(ax,ay), pl.Vec2(bx,by), pl.Vec2(cx,cy)];

                        try {
                            this.body.createFixture(pl.Polygon(verts), { density: 1.0, friction: 0.6, restitution: 0.1 });
                            this.fixtureCount++;
                        } catch (e) { continue; }
                    }
                }
                this.body.resetMassData();
            }
        }

        function extractIslands(mask, w, h) {
            const visited = new Uint8Array(mask.length);
            const islands = [];
            const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y*w+x;
                    if (!mask[idx] || visited[idx]) continue;
                    const stack = [[x,y]];
                    const island = new Set();
                    visited[idx] = 1;
                    while (stack.length) {
                        const [cx, cy] = stack.pop();
                        island.add(cy*w+cx);
                        for (const [dx,dy] of dirs) {
                            const nx = cx+dx, ny = cy+dy;
                            if (nx<0||ny<0||nx>=w||ny>=h) continue;
                            const nIdx = ny*w+nx;
                            if (mask[nIdx] && !visited[nIdx]) {
                                visited[nIdx]=1;
                                stack.push([nx,ny]);
                            }
                        }
                    }
                    islands.push(island);
                }
            }
            return islands;
        }

        function marchingSquares(island, w, h) {
            const isSolid = (x, y) => (x >= 0 && y >= 0 && x < w && y < h) ? island.has(y * w + x) : false;
            let start = null;
            for (const idx of island) {
                const x = idx % w, y = Math.floor(idx / w);
                if (!isSolid(x - 1, y)) { start = { x, y }; break; }
            }
            if (!start) return [];
            const outline = [];
            let x = start.x, y = start.y, dir = 0;
            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            do {
                outline.push({ x: x + 0.5, y: y + 0.5 });
                for (let i = 0; i < 4; i++) {
                    const ndir = (dir + 3 + i) % 4;
                    const nx = x + dirs[ndir][0], ny = y + dirs[ndir][1];
                    if (isSolid(nx, ny)) {
                        x = nx; y = ny; dir = ndir;
                        break;
                    }
                }
            } while (!(x === start.x && y === start.y));
            return outline;
        }

        function simplifyDouglasPeucker(points, epsilon) {
            if (points.length < 3) return points;
            const sqDist = (p, a, b) => {
                const dx = b.x - a.x, dy = b.y - a.y;
                const t = ((p.x-a.x)*dx + (p.y-a.y)*dy)/(dx*dx+dy*dy);
                const proj = {x:a.x+t*dx,y:a.y+t*dy};
                return (p.x-proj.x)**2 + (p.y-proj.y)**2;
            };
            const simplify = (pts) => {
                let maxDist = 0, index = 0;
                for (let i=1;i<pts.length-1;i++){
                    const d = sqDist(pts[i], pts[0], pts[pts.length-1]);
                    if (d>maxDist){maxDist=d;index=i;}
                }
                if (Math.sqrt(maxDist) > epsilon){
                    const left = simplify(pts.slice(0,index+1));
                    const right = simplify(pts.slice(index));
                    return left.slice(0,-1).concat(right);
                }
                return [pts[0], pts[pts.length-1]];
            };
            return simplify(points);
        }

        function removeCollinear(points, epsilon = 0.001) {
            const result = [];
            for (let i = 0; i < points.length; i++) {
                const prev = points[(i-1+points.length)%points.length], curr = points[i], next = points[(i+1)%points.length];
                const ax = curr.x-prev.x, ay = curr.y-prev.y, bx = next.x-curr.x, by = next.y-curr.y;
                if (Math.abs(ax*by-ay*bx) > epsilon) result.push(curr);
            }
            return result;
        }

        function isPixelSolidForConnectivity(type) {
            return type !== MAT.EMPTY && type !== MAT.GAS;
        }

        function findPixelIslands(pixels, width, height) {
            const islands = [], visited = new Uint8Array(width * height);
            const getIdx = (x, y) => y*width+x;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = getIdx(x, y);
                    if (isPixelSolidForConnectivity(pixels[idx]) && !visited[idx]) {
                        const newIsland = [], queue = [{x, y}];
                        visited[idx] = 1;
                        while (queue.length > 0) {
                            const current = queue.shift();
                            newIsland.push(current);
                            const neighbors = [{dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:0},{dx:-1,dy:0},{dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}];
                            for (const n of neighbors) {
                                const nx = current.x+n.dx, ny = current.y+n.dy;
                                if (nx>=0 && nx<width && ny>=0 && ny<height) {
                                    const nIdx = getIdx(nx, ny);
                                    if (isPixelSolidForConnectivity(pixels[nIdx]) && !visited[nIdx]) {
                                        visited[nIdx] = 1;
                                        queue.push({x:nx, y:ny});
                                    }
                                }
                            }
                        }
                        islands.push(newIsland);
                    }
                }
            }
            return islands;
        }

        function checkForSplits(body) {
            const islands = findPixelIslands(body.pixels, body.width, body.height);
            if (islands.length <= 1) return null;

            const MIN_ISLAND_PIXELS = 6;
            const validIslands = [], smallIslands = [];
            for (const island of islands) {
                if (island.length >= MIN_ISLAND_PIXELS) validIslands.push(island);
                else smallIslands.push(island);
            }
            if (validIslands.length <= 1) return null;

            for (const island of smallIslands) {
                for (const p of island) body.pixels[p.y*body.width+p.x] = MAT.EMPTY;
            }

            const oldBody = body.body, oldAngle = oldBody.getAngle(), oldLinVel = oldBody.getLinearVelocity(), oldAngVel = oldBody.getAngularVelocity();
            const newBodies = [];

            for (const island of validIslands) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of island) {
                    if (p.x<minX) minX=p.x; if (p.y<minY) minY=p.y;
                    if (p.x>maxX) maxX=p.x; if (p.y>maxY) maxY=p.y;
                }
                const newWidth = maxX - minX + 1, newHeight = maxY - minY + 1;
                const localOriginX = (minX+newWidth/2)-(body.width/2), localOriginY = (minY+newHeight/2)-(body.height/2);
                const worldOrigin = oldBody.getWorldPoint(pl.Vec2(localOriginX/B2_SCALE, localOriginY/B2_SCALE));
                const worldX = worldOrigin.x*B2_SCALE, worldY = worldOrigin.y*B2_SCALE;
                const newPixels = new Uint8Array(newWidth*newHeight).fill(MAT.EMPTY);
                for (const p of island) {
                    const nx = p.x-minX, ny = p.y-minY;
                    newPixels[ny*newWidth+nx] = body.pixels[p.y*body.width+p.x];
                }
                const nb = new RigidBody(worldX, worldY, newWidth, newHeight, body.materialType);
                nb.pixels = newPixels;
                nb.rebuildFixtures();
                nb.body.setAngle(oldAngle);
                nb.body.setLinearVelocity(pl.Vec2(oldLinVel.x, oldLinVel.y));
                nb.body.setAngularVelocity(oldAngVel);
                nb.body.setAwake(false);
                newBodies.push(nb);
            }

            world.destroyBody(oldBody);
            body.body = null;
            body.isDestroyed = true;
            return newBodies;
        }

        /**
         * Scans the initial spawn area and activates any chunks containing dynamic materials.
         */
        function activateInitialChunks() {
            const startX = Math.floor(player.x - viewWidth);
            const endX = Math.floor(player.x + viewWidth);
            const startY = Math.floor(player.y - viewHeight);
            const endY = Math.floor(player.y + viewHeight);

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const type = getGrid(x, y);
                    if (type !== MAT.EMPTY && !STATIC_MATERIALS.has(type)) {
                        activateChunkAt(x, y);
                    }
                }
            }
        }

        function findAndActivateVisibleLiquidSurfaces() {
            const surfaceChunks = new Set();
            const startX = Math.floor(camera.x);
            const startY = Math.floor(camera.y);
            const endX = startX + viewWidth;
            const endY = startY + viewHeight;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const type = getGrid(x, y);
                    if (isLiquid(type)) {
                        const aboveType = getGrid(x, y - 1);
                        if (aboveType === MAT.EMPTY) {
                            const chunkX = Math.floor(x / CHUNK_SIZE);
                            const chunkY = Math.floor(y / CHUNK_SIZE);
                            surfaceChunks.add(coordToKey(chunkX, chunkY)); // USE NUMERIC KEY
                        }
                    }
                }
            }
            for (const key of surfaceChunks) {
                nextActiveChunks.add(key);
            }
        }

        function activateChunkAt(worldX, worldY) {
            const chunkX = Math.floor(worldX / CHUNK_SIZE);
            const chunkY = Math.floor(worldY / CHUNK_SIZE);
            for (let cy = chunkY - 1; cy <= chunkY + 1; cy++) {
                for (let cx = chunkX - 1; cx <= chunkX + 1; cx++) {
                    nextActiveChunks.add(coordToKey(cx, cy)); // USE NUMERIC KEY
                }
            }
        }

        /**
         * A self-contained Perlin Noise generator object.
         */
        const PerlinNoise = {
            p: [],
            seed: function(s) {
                let random = (() => { let sd=s; return () => (sd=(sd*9301+49297)%233280)/233280; })();
                this.p = new Uint8Array(512); let perm = [];
                for (let i=0;i<256;i++) perm.push(i);
                for (let i=perm.length-1;i>0;i--) { const j=Math.floor(random()*(i+1)); [perm[i],perm[j]]=[perm[j],perm[i]]; }
                for (let i=0;i<256;i++) this.p[i] = this.p[i+256] = perm[i];
            },
            fade: t => t*t*t*(t*(t*6-15)+10), lerp: (t,a,b) => a+t*(b-a),
            grad: function(h,x,y,z) { let u=h<8?x:y, v=h<4?y:h===12||h===14?x:z; return ((h&1)===0?u:-u)+((h&2)===0?v:-v); },
            noise: function(x,y,z=0) {
                let X=Math.floor(x)&255, Y=Math.floor(y)&255, Z=Math.floor(z)&255;
                x-=Math.floor(x); y-=Math.floor(y); z-=Math.floor(z);
                let u=this.fade(x),v=this.fade(y),w=this.fade(z);
                let A=this.p[X]+Y,AA=this.p[A]+Z,AB=this.p[A+1]+Z,B=this.p[X+1]+Y,BA=this.p[B]+Z,BB=this.p[B+1]+Z;
                return this.lerp(w,this.lerp(v,this.lerp(u,this.grad(this.p[AA],x,y,z),this.grad(this.p[BA],x-1,y,z)),this.lerp(u,this.grad(this.p[AB],x,y-1,z),this.grad(this.p[BB],x-1,y-1,z))),this.lerp(v,this.lerp(u,this.grad(this.p[AA+1],x,y,z-1),this.grad(this.p[BA+1],x-1,y,z-1)),this.lerp(u,this.grad(this.p[AB+1],x,y-1,z-1),this.grad(this.p[BB+1],x-1,y-1,z-1))));
            }
        };

        /**
         * Generates a single, tileable cave background image.
         */
        function generateCaveBackgroundTile(width, height) {
            const img = ctx.createImageData(width, height);
            const d = img.data;
            const layerHeight = WORLD_LAYER_HEIGHT;
            const transitionSize = 40;

            PerlinNoise.seed(WORLD_SEED);

            const hash = (x,y,s=0) => { let h=x*374761393+y*668265263+s*1442695041; h=(h^(h>>13))*1274126177; return (h^(h>>16))&255; };
            const lerp = (a,b,t) => a+(b-a)*t;
            const lerpColor = (c1,c2,t) => [lerp(c1[0],c2[0],t),lerp(c1[1],c2[1],t),lerp(c1[2],c2[2],t)];

            const getSandCaveColor = (x,y)=>{ const px=x>>1,py=y>>1,n=(PerlinNoise.noise(px*0.04,py*0.1)+1)/2; if(n>0.6)return[60,45,30];if(n>0.4)return[50,38,25];return[40,30,20]; };
            const getCoalMineColor = (x,y)=>{ const px=x>>1,py=y>>1,r=(PerlinNoise.noise(px*0.1,py*0.1)+1)/2,s=PerlinNoise.noise(px*0.02,py*0.15); if(s*s>0.3)return[5,3,3];if(r>0.6)return[28,25,25];if(r>0.45)return[20,18,18];return[12,10,10]; };
            const getVolcanicColor = (x,y)=>{ const px=x>>1,py=y>>1,c=Math.abs(PerlinNoise.noise(px*0.06,py*0.06)*2.5); if(c>0.98)return[255,170,0];if(c>0.95)return[255,90,0];const r=hash(px>>1,py>>1)/255;if(r>0.5)return[25,10,10];return[15,5,5]; };
            const getLabyrinthColor = (x,y)=>{ const px=x>>2,py=y>>2;if(x%4<1||y%4<1)return[20,22,25];return hash(px,py)>128?[55,60,65]:[45,50,55]; };
            const getMagicDungeonColor = (x,y)=>{ const px=x>>1,py=y>>1,e=(PerlinNoise.noise(px*0.03,py*0.03)+1)/2,c=Math.abs(PerlinNoise.noise(px*0.16,py*0.16)); if(c*c*c>0.2)return[180,150,255];if(c*c>0.25)return[100,80,140];if(hash(x,y)>254)return[200,200,255];if(e>0.55)return[40,15,60];return[20,5,40]; };
            
            const layerFunctions = [getSandCaveColor, getCoalMineColor, getVolcanicColor, getLabyrinthColor, getMagicDungeonColor];

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const layerIndex = Math.min(layerFunctions.length - 1, Math.floor(Math.max(0, y) / layerHeight));
                    const yInLayer = y % layerHeight;
                    let color;
                    if (layerIndex > 0 && yInLayer < transitionSize) {
                        const t = yInLayer / transitionSize;
                        const color1 = layerFunctions[layerIndex - 1](x, y);
                        const color2 = layerFunctions[layerIndex](x, y);
                        color = lerpColor(color1, color2, t * t);
                    } else {
                        color = layerFunctions[layerIndex](x, y);
                    }
                    const i = (y * width + x) * 4;
                    d[i]=color[0]; d[i+1]=color[1]; d[i+2]=color[2]; d[i+3]=255;
                }
            }
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width; tempCanvas.height = height;
            tempCanvas.getContext('2d').putImageData(img, 0, 0);
            return tempCanvas;
        }

        // --- PLAYER AND CAMERA ---
        const player = {
            x: 30, y: -150, vx: 0, vy: 0,
            width: 8, height: 16, speed: 1, onGround: false,
            body: null,
            canInteract: false,
            currentTrigger: null,
            maxHoverEnergy: 100,
            hoverEnergy: 100,
            hoverForce: 0.25,
            hoverDrainRate: 0.5,
            hoverRechargeRate: 1,
            maxHp: 100,
            hp: 100
        };
        const camera = { x: player.x - viewWidth / 2, y: player.y - viewHeight / 2 };
		const mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };
        
        // --- INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', (e) => {
            if (isAlchemyUIVisible) {
                if (e.code === 'Escape') isAlchemyUIVisible = false;
                if (e.code.startsWith('Digit')) {
                    const index = parseInt(e.code.replace('Digit', ''), 10) - 1;
                    const reactionKeys = Object.keys(ALCHEMY_REACTIONS);
                    if (index >= 0 && index < reactionKeys.length) {
                        const reactionKey = reactionKeys[index];
                        ALCHEMY_REACTIONS[reactionKey].execute(player.currentTrigger.associatedData.stationGeometry);
                        isAlchemyUIVisible = false;
                    }
                }
                return;
            }

            if (e.code === 'KeyP') {
                saveMapToImage(); // This function needs to be re-thought for an infinite world
                return;
            }

            keys[e.code] = true;
            if (e.code === 'KeyQ') activeContainer = activeContainer === 'pouch' ? 'flask' : 'pouch';
            if (e.code === 'KeyE' && player.canInteract && player.currentTrigger) {
                player.currentTrigger.onInteract(player.currentTrigger);
            }
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        /**
         * getPlayerSubmersionRatio - unchanged.
         */
        function getPlayerSubmersionRatio() {
            if (!player.body) return 0;
            const samplePoints = [0.1, 0.3, 0.5, 0.7, 0.9];
            let submergedPointCount = 0;
            const totalPoints = samplePoints.length;
            for (const heightPercent of samplePoints) {
                const localX = player.width / 2, localY = player.height * heightPercent;
                const worldPos = player.body.getWorldPoint(pl.Vec2((localX - player.width / 2)/B2_SCALE, (localY - player.height / 2)/B2_SCALE));
                const gridMaterial = getGrid(Math.floor(worldPos.x * B2_SCALE), Math.floor(worldPos.y * B2_SCALE));
                if (isLiquid(gridMaterial)) submergedPointCount++;
            }
            return submergedPointCount / totalPoints;
        }

        /**
         * Scans all generated sectors, renders the entire known world to a new canvas,
         * and triggers a download of the result as a PNG image. Includes size validation.
         */
        async function saveMapToImage() {
            const loadingOverlay = document.getElementById('loading-overlay');
            const statusElement = document.getElementById('loading-status');
            const MAX_SAVE_DIMENSION = 16384; // A safe upper limit for most browsers (16k pixels)

            statusElement.innerText = 'Analyzing world bounds...';
            loadingOverlay.style.transition = 'opacity 0.2s';
            loadingOverlay.style.opacity = '1';
            loadingOverlay.style.display = 'flex';
            await new Promise(resolve => setTimeout(resolve, 50));

            // --- Step 1: Determine the bounds of the generated world ---
            let minCX = Infinity, minCY = Infinity, maxCX = -Infinity, maxCY = -Infinity;
            let hasSectors = false;
            for (const chunk of chunkMap.values()) {
                if(chunk.cx === undefined) continue; // Skip incomplete chunks
                minCX = Math.min(minCX, chunk.cx);
                minCY = Math.min(minCY, chunk.cy);
                maxCX = Math.max(maxCX, chunk.cx);
                maxCY = Math.max(maxCY, chunk.cy);
                hasSectors = true;
            }

            if (!hasSectors) {
                statusElement.innerText = 'No world generated to save!';
                await new Promise(resolve => setTimeout(resolve, 1500));
                loadingOverlay.style.opacity = '0';
                await new Promise(resolve => setTimeout(() => { loadingOverlay.style.display = 'none'; resolve(); }, 200));
                return;
            }

            const startX = minCX * CHUNK_SIZE;
            const startY = minCY * CHUNK_SIZE;
            const endX = (maxCX + 1) * CHUNK_SIZE;
            const endY = (maxCY + 1) * CHUNK_SIZE;

            const totalWidth = endX - startX;
            const totalHeight = endY - startY;

            // --- START OF THE FIX: VALIDATION ---
            if (totalWidth > MAX_SAVE_DIMENSION || totalHeight > MAX_SAVE_DIMENSION || totalWidth <= 0 || totalHeight <= 0) {
                statusElement.innerText = `Error: Map is too large to save (${totalWidth}x${totalHeight}). Max is ~${MAX_SAVE_DIMENSION}px.`;
                console.error(`Save failed: Requested map size ${totalWidth}x${totalHeight} exceeds the limit of ${MAX_SAVE_DIMENSION}.`);
                await new Promise(resolve => setTimeout(resolve, 4000)); // Show error for 4 seconds
                loadingOverlay.style.opacity = '0';
                await new Promise(resolve => setTimeout(() => { loadingOverlay.style.display = 'none'; resolve(); }, 200));
                return; // Abort the save operation
            }
            // --- END OF THE FIX ---
            
            statusElement.innerText = `Creating ${totalWidth}x${totalHeight} map...`;
            await new Promise(resolve => setTimeout(resolve, 50));

            // --- Step 2: Create the large canvas ---
            const saveCanvas = document.createElement('canvas');
            saveCanvas.width = totalWidth;
            saveCanvas.height = totalHeight;
            const saveCtx = saveCanvas.getContext('2d');

            // ... (The rest of the drawing logic is correct and remains the same) ...
            
            // --- Step 3: Draw world data ---
            const bgData = backgroundTileData.data;
            const bgWidth = backgroundTileData.width;
            const bgHeight = backgroundTileData.height;
            for (let y = 0; y < totalHeight; y++) {
                if (y % 256 === 0) {
                     statusElement.innerText = `Rendering row ${y} / ${totalHeight}...`;
                     await new Promise(resolve => setTimeout(resolve, 0));
                }
                for (let x = 0; x < totalWidth; x++) {
                    const worldX = startX + x;
                    const worldY = startY + y;
                    const bgX = (worldX % bgWidth + bgWidth) % bgWidth;
                    const bgY = (worldY % bgHeight + bgHeight) % bgHeight;
                    const bgI = (bgY * bgWidth + bgX) * 4;
                    saveCtx.fillStyle = `rgb(${bgData[bgI]}, ${bgData[bgI+1]}, ${bgData[bgI+2]})`;
                    saveCtx.fillRect(x, y, 1, 1);
                    const type = getGrid(worldX, worldY);
                    if (type !== MAT.EMPTY) {
                        const color = COLORS[type];
                        if (color) {
                            saveCtx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                            saveCtx.fillRect(x, y, 1, 1);
                        }
                    }
                }
            }

            statusElement.innerText = 'Rendering dynamic objects...';
            await new Promise(resolve => setTimeout(resolve, 50));

            // --- Step 4: Draw all rigid bodies ---
            for (const body of rigidBodies) {
                if (!body.body || body.isDestroyed) continue;
                const pos = body.body.getPosition();
                const angle = body.body.getAngle();
                const canvasX = pos.x * B2_SCALE - startX;
                const canvasY = pos.y * B2_SCALE - startY;
                saveCtx.save();
                saveCtx.translate(canvasX, canvasY);
                saveCtx.rotate(angle);
                const offsetX = -body.width / 2;
                const offsetY = -body.height / 2;
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const type = body.pixels[y * body.width + x];
                        if (type !== MAT.EMPTY) {
                            const color = COLORS[type];
                            if (color) {
                                saveCtx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                                saveCtx.fillRect(offsetX + x, offsetY + y, 1, 1);
                            }
                        }
                    }
                }
                saveCtx.restore();
            }

            // --- Step 5: Trigger download ---
            statusElement.innerText = 'Compressing image... (this may take a moment)';
            await new Promise(resolve => setTimeout(resolve, 50)); // Allow UI to update before blocking call

            try {
                const link = document.createElement('a');
                link.download = `falling-sand-map-${Date.now()}.png`;
                link.href = saveCanvas.toDataURL('image/png'); // This is the slow operation
                link.click();
            } catch (e) {
                statusElement.innerText = `Error: Could not generate image data. The map may be too large.`;
                console.error("Error during toDataURL:", e);
                await new Promise(resolve => setTimeout(resolve, 4000));
                loadingOverlay.style.opacity = '0';
                await new Promise(resolve => setTimeout(() => { loadingOverlay.style.display = 'none'; resolve(); }, 200));
                return;
            }

            // --- Step 6: Hide overlay ---
            statusElement.innerText = 'Done!';
            await new Promise(resolve => setTimeout(resolve, 500));
            loadingOverlay.style.opacity = '0';
            await new Promise(resolve => setTimeout(() => {
                loadingOverlay.style.display = 'none';
                resolve();
            }, 200));
        }
        
        /**
         * Creates the player's physics body. Unchanged.
         */
        function createPlayerBody() {
            player.body = world.createBody({type:'dynamic', position:pl.Vec2(player.x/B2_SCALE,player.y/B2_SCALE), fixedRotation:true, linearDamping:PLAYER_DEFAULT_DAMPING});
            player.body.setUserData(player);
            const halfWidth=(player.width/2-1)/B2_SCALE, halfHeight=(player.height/2-2)/B2_SCALE;
            player.body.createFixture(pl.Box(halfWidth,halfHeight,pl.Vec2(0,-2/B2_SCALE),0),{density:1.0,friction:0.3});
            const footRadius=(player.width/2-1)/B2_SCALE;
            player.body.createFixture(pl.Circle(pl.Vec2(0,(player.height/2-2)/B2_SCALE),footRadius),{friction:0.05});
        }


        function setMaterial(name) {
            const map = {
                sand: MAT.SAND, water: MAT.WATER, oil: MAT.OIL, coal: MAT.COAL,
                soil: MAT.SOIL, wall: MAT.ROCK_WALL, gas: MAT.GAS, wood: MAT.WOOD,
                fire: MAT.FIRE, gunpowder: MAT.GUNPOWDER, acid: MAT.ACID,
                glass: MAT.GLASS, 'glass-wall': MAT.GLASS_WALL, empty: MAT.EMPTY,
                adamantium: MAT.ADAMANTIUM, copper: MAT.COPPER, silver: MAT.SILVER,
                gold: MAT.GOLD, platinum: MAT.PLATINUM,
                'rune-wall': MAT.RUNE_WALL
            };
            if (map[name] === undefined) { console.warn('Unknown material:', name); return; }
            currentMaterial = map[name];
            document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
            const btn = document.querySelector(`.btn-${name}`);
            if (btn) btn.classList.add('active');
        }

        function isFlammable(type) {
            return (type === MAT.WOOD || type === MAT.GUNPOWDER || type === MAT.OIL || type === MAT.COAL);
        }

        const LIQUIDS = new Set([MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.ACID]);

        function tryIgniteAt(x, y, probability = 1.0) {
            const type = getGrid(x, y);
            if (!isFlammable(type) || Math.random() > probability) return;

            switch (type) {
                case MAT.GUNPOWDER:
                    setGrid(x, y, MAT.GUNPOWDER_IGNITED);
                    setAuxData(etcChunkMap, x, y, 3 + Math.floor(Math.random() * 5)); // Ignition timer
                    break;
                case MAT.OIL: setGrid(x, y, MAT.OIL_BURNING); break;
                case MAT.COAL: setGrid(x, y, MAT.COAL_BURNING); break;
                case MAT.WOOD: setGrid(x, y, MAT.FIRE); break;
            }
        }


        const getMousePos = (evt) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = evt.clientX - rect.left;
            mouse.y = evt.clientY - rect.top;
        };

        function draw(x, y) {
            const brushSize = 10;
            const r = Math.floor(brushSize / 2);
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (dx*dx + dy*dy <= r*r) {
                        const px = x + dx, py = y + dy;
                        setGrid(px, py, currentMaterial);
                        activateChunkAt(px, py);
                    }
                }
            }
        }
        canvas.addEventListener('mousemove', getMousePos);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) isPouring = true;
            else if (e.button === 1) { isDrawing = true; draw(mouse.worldX, mouse.worldY); e.preventDefault(); }
            else if (e.button === 2) { isStoring = true; storeMaterial(mouse.worldX, mouse.worldY); } 
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) isPouring = false;
            if (e.button === 1) isDrawing = false;
            if (e.button === 2) isStoring = false;
        });

        canvas.addEventListener('mousemove', (e) => { if (isDrawing) draw(mouse.worldX, mouse.worldY); });
        
        // This helper is only used for the small inventory grids now.
        const getIdx = (x, y, w, h) => {
            x = Math.floor(x); y = Math.floor(y);
            if (x < 0 || x >= w || y < 0 || y >= h) return -1;
            return y * w + x;
        };

        const isSolidForPlayer = (type) => [
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, MAT.LABYRINTH_WALL, MAT.MAGIC_WALL,
            MAT.SOIL, MAT.WOOD, MAT.SAND, 
            MAT.GUNPOWDER, MAT.COAL, MAT.COAL_BURNING, MAT.GLASS, 
            MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.COPPER, MAT.SILVER, 
            MAT.GOLD, MAT.PLATINUM, MAT.RUNE_WALL
        ].includes(type);
        
        function updateRigidBodyGrid() {
            // Clear previous frame data in relevant chunks
            const chunksToClear = new Set();
            for (const body of rigidBodies) {
                if(body.isDestroyed) continue;
                const pos = body.body.getPosition();
                const cx = Math.floor(pos.x * B2_SCALE / CHUNK_SIZE);
                const cy = Math.floor(pos.y * B2_SCALE / CHUNK_SIZE);
                for(let dy = -2; dy <= 2; dy++) for(let dx = -2; dx <= 2; dx++) chunksToClear.add(`${cx+dx},${cy+dy}`);
            }
            for(const key of chunksToClear){
                if(etcChunkMap.has(key)) etcChunkMap.get(key).data.fill(0);
            }

            const buffer = 1;
            for (const body of rigidBodies) {
                if (body.isDestroyed) continue;
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        if (body.pixels[y*body.width+x] === MAT.EMPTY) continue;
                        const localPos = pl.Vec2((x-body.width/2+0.5)/B2_SCALE, (y-body.height/2+0.5)/B2_SCALE);
                        const worldPos = body.body.getWorldPoint(localPos);
                        const worldX = Math.floor(worldPos.x*B2_SCALE), worldY = Math.floor(worldPos.y*B2_SCALE);
                        for (let dy = -buffer; dy <= buffer; dy++) {
                            for (let dx = -buffer; dx <= buffer; dx++) {
                                setAuxData(etcChunkMap, worldX+dx, worldY+dy, 1); // 1 for rigid body stub
                            }
                        }
                    }
                }
            }
        }
        
        function updatePlayer() {
            if (isAlchemyUIVisible) {
                player.body.setLinearVelocity(pl.Vec2(0, 0));
                return;
            }

            const submersionRatio = getPlayerSubmersionRatio();
            const isInLiquid = submersionRatio > 0;

            if (isInLiquid) {
                const upwardForce = BUOYANCY_FORCE * submersionRatio * player.body.getMass();
                player.body.applyForceToCenter(pl.Vec2(0, -upwardForce), true);
                player.body.setLinearDamping(PLAYER_SUBMERGED_DAMPING);
            } else {
                player.body.setLinearDamping(PLAYER_DEFAULT_DAMPING);
            }

            const currentVel = player.body.getLinearVelocity();
            let targetVelX = 0;

            if (keys['KeyA']) { targetVelX = -player.speed * 2.5; playerFacingRight = false; }
            else if (keys['KeyD']) { targetVelX = player.speed * 2.5; playerFacingRight = true; }

            player.onGround = Math.abs(currentVel.y) < 0.1;
            let newVelY = currentVel.y;

            if (keys['KeyW'] && player.hoverEnergy > 0) {
                const jumpForce = isInLiquid ? MAX_HOVER_SPEED * 1.5 : MAX_HOVER_SPEED;
                newVelY = -jumpForce;
                player.hoverEnergy = Math.max(0, player.hoverEnergy - player.hoverDrainRate);
                if (!isInLiquid) spawnLevitationParticles(2);
            }

            if ((player.onGround || isInLiquid) && !keys['KeyW']) {
                player.hoverEnergy = Math.min(player.maxHoverEnergy, player.hoverEnergy + player.hoverRechargeRate);
            }

            player.body.setLinearVelocity(pl.Vec2(targetVelX, newVelY));
        }
        
        function syncPlayerWithBody() {
            const pos = player.body.getPosition();
            player.x = (pos.x * B2_SCALE) - (player.width / 2);
            player.y = (pos.y * B2_SCALE) - (player.height / 2);
        }

        function storeMaterial(worldX, worldY) {
            const storeRadius = 1;
            for (let dy = -storeRadius; dy <= storeRadius; dy++) {
                for (let dx = -storeRadius; dx <= storeRadius; dx++) {
                    const wx = worldX + dx;
                    const wy = worldY + dy;
                    const type = getGrid(wx, wy);

                    let targetGrid, targetW, targetH;
                    if (STORABLE_SOLIDS.has(type)) {
                        targetGrid = pouchGrid; targetW = pouchWidth; targetH = pouchHeight;
                    } else if (STORABLE_LIQUIDS.has(type)) {
                        targetGrid = flaskGrid; targetW = flaskWidth; targetH = flaskHeight;
                    } else continue;

                    let spotFound = false;
                    for (let y=0;y<targetH;y++) {
                        const xOffset = Math.floor(Math.random() * targetW);
                        for (let i=0;i<targetW;i++) {
                            const x = (i+xOffset)%targetW;
                            const containerIdx = getIdx(x,y,targetW,targetH);
                            if (containerIdx !== -1 && targetGrid[containerIdx] === MAT.EMPTY) {
                                targetGrid[containerIdx] = type;
                                setGrid(wx, wy, MAT.EMPTY);
                                spotFound = true; break;
                            }
                        }
                        if (spotFound) break;
                    }
                }
            }
        }
        
        function pourFromContainer() {
            const [containerGrid, cW, cH] = activeContainer === 'pouch' ? [pouchGrid, pouchWidth, pouchHeight] : [flaskGrid, flaskWidth, flaskHeight];
            const maxPourPerFrame = 3;
            let pouredCount = 0;

            for (let y = cH - 1; y >= 0; y--) {
                for (let i = 0; i < cW; i++) {
                    const x = Math.floor(cW/2)+(i%2===0?1:-1)*Math.floor(i/2);
                    const idx = getIdx(x,y,cW,cH);
                    const type = containerGrid[idx];

                    if (type !== MAT.EMPTY && type !== MAT.GAS) {
                        containerGrid[idx] = MAT.EMPTY;
                        const baseSpawnX = player.x + (playerFacingRight?player.width:0), baseSpawnY = player.y+9;
                        const spawnOffsetX = (Math.random()-0.5)*2, spawnOffsetY = (Math.random()-0.5)*2;
                        const finalSpawnX = baseSpawnX+spawnOffsetX, finalSpawnY = baseSpawnY+spawnOffsetY;
                        const baseAngle = Math.atan2(mouse.worldY-finalSpawnY, mouse.worldX-finalSpawnX);
                        const finalAngle = baseAngle+(Math.random()-0.5)*0.05;
                        const finalVelocity = 4.0+(Math.random()-0.5)*0.5;

                        pouredParticles.push({
                            x:finalSpawnX, y:finalSpawnY,
                            vx:Math.cos(finalAngle)*finalVelocity, vy:Math.sin(finalAngle)*finalVelocity,
                            type:type
                        });
                        
                        pouredCount++;
                        if (pouredCount >= maxPourPerFrame) return;
                    }
                }
            }
        }

        function isRigidBodyAtPixel(worldX, worldY) {
            const pMin = pl.Vec2((worldX-0.5)/B2_SCALE, (worldY-0.5)/B2_SCALE);
            const pMax = pl.Vec2((worldX+0.5)/B2_SCALE, (worldY+0.5)/B2_SCALE);
            const aabb = new pl.AABB(pMin, pMax);
            let hit = false;
            world.queryAABB(aabb, (fixture) => {
                const ud = fixture.getBody().getUserData();
                if (ud && ud.pixels && ud.width && ud.height) { hit=true; return false; }
                return true;
            });
            return hit;
        }
        
        function updatePouredParticles() {
            pouredParticles = pouredParticles.filter(p => {
                p.vy += GRAVITY * 0.5;
                const nextX = p.x + p.vx, nextY = p.y + p.vy;
                const nextIX = Math.floor(nextX), nextIY = Math.floor(nextY);

                const gridBlocked = getGrid(nextIX, nextIY) !== MAT.EMPTY && getGrid(nextIX, nextIY) !== MAT.GAS;
                const rigidBlocked = getAuxData(etcChunkMap, nextIX, nextIY) === 1; // 1 means rigid body
                const isObstructed = gridBlocked || rigidBlocked;
                const hasStopped = (p.vx*p.vx + p.vy*p.vy < 1.0);

                if (isObstructed || hasStopped) {
                    let placeX = Math.floor(p.x), placeY = Math.floor(p.y);
                    while (true) {
                        if (getGrid(placeX, placeY) === MAT.EMPTY || getGrid(placeX, placeY) === MAT.GAS) {
                            setGrid(placeX, placeY, p.type);
                            activateChunkAt(placeX, placeY);
                            break;
                        }
                        placeY--;
                        if (placeY < camera.y - 100) break; // Safety break
                    }
                    return false;
                } else {
                    p.x = nextX; p.y = nextY;
                    return true;
                }
            });
        }
        
        // This group of functions can remain mostly as-is
		function shootFire(){/*...no changes needed...*/};
		function updateProjectiles(){/*...no changes needed...*/};
        const movedPouch = new Uint8Array(pouchWidth*pouchHeight);
        const movedFlask = new Uint8Array(flaskWidth*flaskHeight);
        
        

        function updateCamera() {
            const targetCamX = player.x - viewWidth/2;
            camera.x += (targetCamX - camera.x) * 0.1;
            const targetCamY = player.y - viewHeight/2;
            camera.y += (targetCamY - camera.y) * 0.1;
            // No more clamping
        }

        
        function isLiquid (type) {
            return LIQUIDS.has(type);
        }
        
        function runWorldSimulationWithChunks() {
            movedInFrame.clear(); // Clear the set once per frame
            const scanDir = (frameCount % 2 === 0);

            for (const key of activeChunks) {
                const chunk = chunkMap.get(key);
                if (!chunk) continue;

                const startX = chunk.cx * CHUNK_SIZE;
                const startY = chunk.cy * CHUNK_SIZE;

                // PASS 1: solids, gas, fire
                for (let ly = CHUNK_SIZE - 1; ly >= 0; ly--) {
                    for (let lx = (scanDir ? 0 : CHUNK_SIZE - 1);
                        (scanDir ? lx < CHUNK_SIZE : lx >= 0); lx += (scanDir ? 1 : -1)) {
                        stepNonLiquid(startX + lx, startY + ly);
                    }
                }

                // PASS 2: liquids
                for (let ly = CHUNK_SIZE - 1; ly >= 0; ly--) {
                    for (let lx = (scanDir ? 0 : CHUNK_SIZE - 1);
                        (scanDir ? lx < CHUNK_SIZE : lx >= 0); lx += (scanDir ? 1 : -1)) {
                        stepLiquid(startX + lx, startY + ly);
                    }
                }
            }
        }

        // This function is now ONLY for small inventory grids
        function runSimulationOnSmallGrid(moved, currentGrid, gridWidth, gridHeight, setter) {
             moved.fill(0);
             const localGetIdx = (x, y) => getIdx(x, y, gridWidth, gridHeight);
             const scanDir = (frameCount % 2 === 0);
             for(let y=gridHeight-1;y>=0;y--) for(let x=(scanDir?0:gridWidth-1);(scanDir?x<gridWidth:x>=0);x+=(scanDir?1:-1)) stepNonLiquid(x,y,moved,currentGrid,gridWidth,gridHeight,localGetIdx,setter);
             for(let y=gridHeight-1;y>=0;y--) for(let x=(scanDir?0:gridWidth-1);(scanDir?x<gridWidth:x>=0);x+=(scanDir?1:-1)) stepLiquid(x,y,moved,currentGrid,gridWidth,gridHeight,localGetIdx,setter);
        }

        function stepNonLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const type = isWorldSim ? getGrid(x, y) : grid[getIdx(x, y)];
            const idx = isWorldSim ? -1 : getIdx(x, y);

            if(isWorldSim && movedInFrame.has(coordToKey(x,y))) return;
            if(!isWorldSim && moved[idx]) return;

            if (WALL_TYPES.has(type) || [MAT.EMPTY, MAT.WOOD, MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.RUNE_WALL, MAT.RIGID_BODY_STUB].includes(type) || LIQUIDS.has(type)) return;
            
            if (type === MAT.FIRE) updateFire(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if ([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM].includes(type)) updateSolid(x, y, type, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.COAL_BURNING) updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.GAS) updateGas(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.GUNPOWDER_IGNITED) updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter);
        }

        function stepLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const type = isWorldSim ? getGrid(x, y) : grid[getIdx(x, y)];
            const idx = isWorldSim ? -1 : getIdx(x, y);

            if(isWorldSim && movedInFrame.has(coordToKey(x,y))) return;
            if(!isWorldSim && moved[idx]) return;

            if (![MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.ACID].includes(type)) return;
            
            updateLiquid(x, y, type, idx, moved, grid, w, h, getIdx, setter);
        }

        function updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            if (isWorldSim) {
                let timer = getAuxData(etcChunkMap, x, y);
                timer--;
                setAuxData(etcChunkMap, x, y, timer);
                for (let n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                    const nx = x + n.x, ny = y + n.y;
                    if (Math.random() < 0.35 && getGrid(nx, ny) === MAT.GUNPOWDER) {
                        setGrid(nx, ny, MAT.GUNPOWDER_IGNITED);
                        setAuxData(etcChunkMap, nx, ny, 8 + Math.floor(Math.random() * 6));
                    }
                }
                if (timer <= 0) {
                    setGrid(x, y, MAT.EMPTY);
                    triggerExplosion(x, y, 6);
                }
            } else {
                // No timer or explosion in small grids, just burns out
                if (Math.random() < 0.2) {
                    setter(idx, MAT.FIRE);
                    moved[idx] = 1;
                }
            }
        }
        
        function updateFire(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };

            let nearbyFuel = false;
            for (let n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0},{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}]) {
                const nx = x + n.x, ny = y + n.y;
                const nType = _get(nx, ny);
                if (nType === MAT.SAND && Math.random() < 0.05) _set(nx, ny, MAT.GLASS);
                if (nType === MAT.GUNPOWDER && Math.random() < 0.5) {
                    if (isWorldSim) { setGrid(nx, ny, MAT.GUNPOWDER_IGNITED); setAuxData(etcChunkMap, nx, ny, 8 + Math.floor(Math.random() * 6)); } 
                    else { _set(nx, ny, MAT.FIRE); }
                    return;
                }
                if (nType === MAT.OIL) { _set(nx, ny, MAT.OIL_BURNING); return; }
                if (nType === MAT.COAL) { _set(nx, ny, MAT.COAL_BURNING); return; }
                if (nType === MAT.WOOD) { nearbyFuel = true; if (Math.random() < 0.02) _set(nx, ny, MAT.FIRE); }
                if (nType === MAT.WATER) { _set(nx, ny, MAT.GAS); _set(x, y, MAT.GAS); return; }
            }
            let targetX = x, targetY = y;
            if (!nearbyFuel && y > 0) {
                let nextX = x, nextY = y - 1;
                if (Math.random() < 0.5) nextX += Math.random() < 0.5 ? -1 : 1;
                const nextType = _get(nextX, nextY);
                if (nextType === MAT.EMPTY || nextType === MAT.GAS) {
                    _set(x, y, nextType);
                    _set(nextX, nextY, MAT.FIRE);
                    targetX = nextX; targetY = nextY;
                }
            }
            if (Math.random() < (nearbyFuel ? 0.01 : 0.15)) {
                _set(targetX, targetY, Math.random() < 0.15 ? MAT.GAS : MAT.EMPTY);
            }
        }

        function updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
             const _tryIgniteAt = (gx, gy, prob) => {
                if (isWorldSim) tryIgniteAt(gx, gy, prob);
                // No complex ignition in small grids for now
            };

            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                const nx = x + n.x, ny = y + n.y;
                if (_get(nx, ny) === MAT.SAND && Math.random() < 0.08) _set(nx, ny, MAT.GLASS);
                _tryIgniteAt(nx, ny, 0.02);
            }
            if (Math.random() < 0.02 && _get(x, y - 1) === MAT.EMPTY) _set(x, y - 1, MAT.FIRE);
            if (Math.random() < 0.003) _set(x, y, Math.random() < 0.15 ? MAT.GAS : MAT.EMPTY);
            if (isWorldSim && getGrid(x, y) === MAT.COAL_BURNING) activateChunkAt(x, y);
        }

        function updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
            const _tryIgniteAt = (gx, gy, prob) => {
                 if (isWorldSim) tryIgniteAt(gx, gy, prob);
            };

            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0},{x:1,y:1},{x:-1,y:1},{x:1,y:-1},{x:-1,y:-1}]) {
                const nx = x + n.x, ny = y + n.y;
                if (_get(nx, ny) === MAT.SAND && Math.random() < 0.1) _set(nx, ny, MAT.GLASS);
                _tryIgniteAt(nx, ny, 0.05);
            }
            if (Math.random() < 0.05 && _get(x, y - 1) === MAT.EMPTY) _set(x, y - 1, MAT.FIRE);
            if (Math.random() < 0.008) _set(x, y, Math.random() < 0.15 ? MAT.GAS : MAT.EMPTY);
            if (isWorldSim && getGrid(x, y) === MAT.OIL_BURNING) activateChunkAt(x, y);
        }

        function updateSolid(x, y, type, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
             const _getAux = (gx, gy) => isWorldSim ? getAuxData(etcChunkMap, gx, gy) : 0;

            if (_get(x, y + 1) === MAT.FIRE && type === MAT.COAL) { _set(x, y, MAT.COAL_BURNING); if(!isWorldSim && idx!==-1) moved[idx] = 1; return; }
            if (_getAux(x, y + 1) !== 1) {
                const belowType = _get(x, y + 1);
                if ([MAT.EMPTY, MAT.GAS].includes(belowType) || isLiquid(belowType)) {
                    _set(x, y, belowType);
                    _set(x, y + 1, type);
                    if(!isWorldSim && idx!==-1) moved[idx] = 1;
                    return;
                }
            }
            const dir = Math.random() < 0.5 ? -1 : 1;
            for (let dx of [dir, -dir]) {
                if (_getAux(x + dx, y + 1) !== 1) {
                    const diagType = _get(x + dx, y + 1);
                    if ([MAT.EMPTY, MAT.GAS].includes(diagType) || isLiquid(diagType)) {
                        _set(x, y, diagType);
                        _set(x + dx, y + 1, type);
                        if(!isWorldSim && idx!==-1) moved[idx] = 1;
                        return;
                    }
                }
            }
        }
        
        function updateLiquid(x, y, type, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
             const _getAux = (gx, gy) => isWorldSim ? getAuxData(etcChunkMap, gx, gy) : 0;

            if (type === MAT.ACID) {
                let consumed = false;
                for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                    const nx = x + n.x, ny = y + n.y;
                    const nType = _get(nx, ny);
                    const isImmune = [MAT.EMPTY,MAT.GLASS,MAT.GAS,MAT.GLASS_WALL,MAT.ADAMANTIUM,MAT.RUNE_WALL].includes(nType);
                    if (!isImmune && !isLiquid(nType) && Math.random() < 0.25) {
                        _set(nx, ny, MAT.EMPTY);
                        if (Math.random() < 0.2) { _set(x, y, MAT.EMPTY); consumed = true; break; }
                    }
                }
                if (consumed) { if(!isWorldSim && idx!==-1) moved[idx] = 1; return; }
            }
            if (_getAux(x, y + 1) === 1) {
                tryMoveLiquidSide(x, y, type, Math.random() < 0.5 ? -1 : 1, 20, 1, idx, moved, grid, w, h, getIdx, setter);
                if (_get(x, y) === MAT.OIL_BURNING) updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter);
                return;
            }
            const belowType = _get(x, y + 1);
            if (belowType === MAT.FIRE) {
                if (type === MAT.OIL) _set(x, y, MAT.OIL_BURNING);
                else { _set(x, y, MAT.GAS); _set(x, y + 1, MAT.GAS); }
                if(!isWorldSim && idx!==-1) moved[idx] = 1;
                return;
            }
            if ([MAT.EMPTY, MAT.GAS].includes(belowType)) { _set(x, y, belowType); _set(x, y + 1, type); if(!isWorldSim && idx!==-1) moved[idx] = 1; return; }
            if (LIQUID_DENSITY[type] > LIQUID_DENSITY[belowType]) { _set(x, y, belowType); _set(x, y + 1, type); if(!isWorldSim && idx!==-1) moved[idx] = 1; return; }
            tryMoveLiquidSide(x, y, type, Math.random() < 0.5 ? -1 : 1, 20, 1, idx, moved, grid, w, h, getIdx, setter);
            if (_get(x, y) === MAT.OIL_BURNING) updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter);
        }

        function updateGas(x, y, idx, moved, grid, w, h, getIdx, setter) {
             const isWorldSim = !grid;
             const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
             const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
            const aboveType = _get(x, y - 1);
            if ([MAT.EMPTY, MAT.WATER, MAT.SAND, MAT.SOIL, MAT.GUNPOWDER].includes(aboveType)) {
                _set(x, y, aboveType);
                _set(x, y - 1, MAT.GAS);
                 if(!isWorldSim && idx!==-1) moved[idx] = 1;
                return;
            }
            tryMoveLiquidSide(x, y, MAT.GAS, Math.random() < 0.5 ? -1 : 1, 4, -1, idx, moved, grid, w, h, getIdx, setter);
        }

        function tryMoveLiquidSide(x, y, type, dir, limit, vDir, idx, moved, grid, w, h, getIdx, setter) {
            const isWorldSim = !grid;
            const _get = (gx, gy) => isWorldSim ? getGrid(gx, gy) : (getIdx(gx, gy) !== -1 ? grid[getIdx(gx, gy)] : MAT.ROCK_WALL);
            const _set = (gx, gy, gtype) => {
                if (isWorldSim) {
                    setGrid(gx, gy, gtype);
                    movedInFrame.add(coordToKey(gx, gy));
                } else {
                    const gidx = getIdx(gx, gy);
                    if (gidx !== -1) { setter(gidx, gtype); moved[gidx] = 1; }
                }
            };
            const _getAux = (gx, gy) => isWorldSim ? getAuxData(etcChunkMap, gx, gy) : 0;
            
            let targetX = x;
            const movable = [MAT.EMPTY, MAT.GAS, MAT.FIRE];
            const allMovable = [...LIQUIDS, ...movable];
            for (let i = 1; i <= limit; i++) {
                const nextX = x + (dir * i);
                if (_getAux(nextX, y) === 1) break;
                const content = _get(nextX, y);
                if (allMovable.includes(content) && type != content) {
                    targetX = nextX;
                    const vType = _get(nextX, y + vDir);
                    if (movable.includes(vType)) break;
                } else break;
            }
            if (targetX !== x) {
                const tType = _get(targetX, y);
                _set(x, y, tType);
                _set(targetX, y, type);
                if(!isWorldSim && idx!==-1) moved[idx] = 1;
                return true;
            }
            return false;
        }


        function findGroundBelow(x, startY) {
            for (let y = startY; y < startY + 500; y++) {
                if (getGrid(x, y) !== MAT.EMPTY) return y;
            }
            return startY + 500;
        }

        function createReservoir({x,y,width,height,fillType,wallType=MAT.WOOD}) {
            const groundY = findGroundBelow(x, y);
            const topY = Math.max(y - 200, groundY - height);
            const leftX = Math.floor(x - width / 2), rightX = Math.floor(x + width / 2);
            const wallWidth = 2;
            for (let iy = topY; iy <= groundY; iy++) {
                for (let ix = leftX; ix <= rightX; ix++) {
                    const isWall = ix <= leftX + wallWidth || ix >= rightX - wallWidth || iy >= groundY - wallWidth;
                    setGrid(ix, iy, isWall ? wallType : fillType);
                }
            }
        }

        function createCircle({x,y,radius,type}) {
            const r2=radius*radius; for(let dy=-radius;dy<=radius;dy++) for(let dx=-radius;dx<=radius;dx++) if(dx*dx+dy*dy<=r2) setGrid(Math.floor(x+dx),Math.floor(y+dy),type);
        }
        function createCircleOutline({x,y,radius,thickness=1,type}) {
            const r2=radius*radius, inner=(radius-thickness)**2; for(let dy=-radius;dy<=radius;dy++) for(let dx=-radius;dx<=radius;dx++) {const d2=dx*dx+dy*dy; if(d2<=r2&&d2>=inner) setGrid(x+dx,y+dy,type);}
        }

        /**
         * A unified, high-performance light propagation function.
         * Takes a queue of initial light source coordinates and spreads light outwards.
         * Returns a Set of neighboring chunk keys that were affected.
         */
        function propagateLightFromQueue(queue) {
            const neighborsToActivate = new Set();
            let head = 0;
            const DIRS_4 = [{ x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: -1 }, { x: 0, y: 1 }];

            while (head < queue.length) {
                const current = queue[head++];
                const currentLight = getAuxData(lightChunkMap, current.x, current.y);
                if (currentLight <= 1) continue;

                const currentChunkX = Math.floor(current.x / CHUNK_SIZE);
                const currentChunkY = Math.floor(current.y / CHUNK_SIZE);

                for (const dir of DIRS_4) {
                    const nextX = current.x + dir.x;
                    const nextY = current.y + dir.y;

                    const nextSectorX = Math.floor(nextX / SECTOR_SIZE);
                    const nextSectorY = Math.floor(nextY / SECTOR_SIZE);
                    if (sectorGrid.get(coordToKey(nextSectorX, nextSectorY)) !== 'ready') continue;

                    const lightLoss = WALL_TYPES.has(getGrid(nextX, nextY)) ? 3 : 0;
                    const nextLight = currentLight - lightLoss;

                    if (nextLight > getAuxData(lightChunkMap, nextX, nextY)) {
                        setAuxData(lightChunkMap, nextX, nextY, nextLight);
                        queue.push({ x: nextX, y: nextY });

                        const nextChunkX = Math.floor(nextX / CHUNK_SIZE);
                        const nextChunkY = Math.floor(nextY / CHUNK_SIZE);

                        if (nextChunkX !== currentChunkX || nextChunkY !== currentChunkY) {
                            neighborsToActivate.add(coordToKey(nextChunkX, nextChunkY));
                        }
                    }
                }
            }
            return neighborsToActivate;
        }

        
        /**
         * Performs an ADDITIVE lighting update on a "dirty" chunk.
         * It re-evaluates the light level of all pixels in the chunk based on their neighbors,
         * ensuring that both newly created empty spaces and existing walls are updated correctly.
         */
        function updateLocalLightingAndFindNeighbors(chunkKey) {
            const chunk = chunkMap.get(chunkKey);
            if (!chunk) return new Set();

            const startX = chunk.cx * CHUNK_SIZE;
            const startY = chunk.cy * CHUNK_SIZE;
            const endX = startX + CHUNK_SIZE;
            const endY = startY + CHUNK_SIZE;
            const queue = [];

            // Seeding Pass: Re-evaluate ALL pixels in the chunk
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    let newLight = 0;
                    
                    if (getGrid(x, y) === MAT.EMPTY) {
                        // For empty space, start with max light
                        newLight = MAX_LIGHT_LEVEL;
                    }

                    // --- THIS IS THE FIX ---
                    // For ALL pixels (empty or solid), check neighbors and pull in brighter light.
                    const DIRS_4 = [{ x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: -1 }, { x: 0, y: 1 }];
                    for (const dir of DIRS_4) {
                        const nX = x + dir.x;
                        const nY = y + dir.y;

                        // Calculate how much light would be lost moving from the neighbor to the current pixel
                        const lightLoss = WALL_TYPES.has(getGrid(x, y)) ? 3 : 1;
                        
                        // Find the brightest possible light level from any neighbor
                        newLight = Math.max(newLight, getAuxData(lightChunkMap, nX, nY) - lightLoss);
                    }
                    // --- END OF FIX ---

                    // If the newly calculated light is brighter than what's currently stored,
                    // update it and add this pixel to the queue to propagate its new light outwards.
                    if (newLight > getAuxData(lightChunkMap, x, y)) {
                        setAuxData(lightChunkMap, x, y, newLight);
                        queue.push({ x, y });
                    }
                }
            }

            // Propagation Pass: Use the unified function to spread the newly seeded light.
            return propagateLightFromQueue(queue);
        }


        // --- RENDERING ---
        function setPixel(x,y,r,g,b,a=255){ const i=(y*renderWidth+x)*4; pixels[i]=r; pixels[i+1]=g; pixels[i+2]=b; pixels[i+3]=a; }

        function render() {
            firePixelsCoords = [];

            const startX = Math.floor(camera.x);
            const startY = Math.floor(camera.y);

            // --- NEW: Optimized Background Rendering ---
            const bgData = backgroundTileData.data;
            const bgWidth = backgroundTileData.width;
            const bgHeight = backgroundTileData.height;

            // Pass 1: Manually draw background AND world materials in one loop
            for (let screenY = 0; screenY < viewHeight; screenY++) {
                for (let screenX = 0; screenX < viewWidth; screenX++) {
                    const worldX = screenX + startX;
                    const worldY = screenY + startY;
                    const destI = (screenY * renderWidth + screenX) * 4;

                    // --- Step 1: Calculate and draw the background pixel ---
                    // Use modulo to wrap coordinates for the repeating tile
                    const bgX = (worldX % bgWidth + bgWidth) % bgWidth; 
                    const bgY = (worldY % bgHeight + bgHeight) % bgHeight;
                    const bgI = (bgY * bgWidth + bgX) * 4;

                    pixels[destI]     = bgData[bgI];
                    pixels[destI + 1] = bgData[bgI + 1];
                    pixels[destI + 2] = bgData[bgI + 2];
                    pixels[destI + 3] = 255;

                    // --- Step 2: Draw the world material on top (if it exists) ---
                    const type = getGrid(worldX, worldY);
                    if (type === MAT.EMPTY || type === MAT.RIGID_BODY_STUB) continue;
                    
                    const lightLevel = getAuxData(lightChunkMap, worldX, worldY);

                    if (lightLevel === 0 && !ALWAYS_VISIBLE_MATERIALS.has(type)) {
                        pixels[destI] = 0; pixels[destI + 1] = 0; pixels[destI + 2] = 0;
                        continue;
                    }
                    
                    let r, g, b;
                    [r, g, b] = COLORS[type];

                    // Color variations (fire, shimmer, etc.) - no changes here
                    if (type === MAT.FIRE) { r = 255; g = 80 + Math.random() * 80; b = 0; firePixelsCoords.push({ x: screenX, y: screenY }); } 
                    else if (type === MAT.OIL_BURNING || type === MAT.COAL_BURNING) { firePixelsCoords.push({ x: screenX, y: screenY });[r, g, b] = varyColor(...COLORS[type], worldX, worldY, type, 4); } 
                    else if (LIQUIDS.has(type)) { [r, g, b] = varyColor(...COLORS[type], worldX, worldY, type, 4); } 
                    else { if (SHIMMERING_METALS.has(type)) { [r, g, b] = metallicColor(worldX, worldY, COLORS[type]); } else { [r, g, b] = varyColor(...COLORS[type], worldX, worldY, type, 16); } }
                    
                    if (SHIMMERING_METALS.has(type)) { const h = hashCell(worldX, worldY, Math.floor(frameCount / 4)); if (h > 254) { const br = 35; r = Math.min(255, r + br); g = Math.min(255, g + br); b = Math.min(255, b + br); } }
                    
                    // Lighting
                    if (!ALWAYS_VISIBLE_MATERIALS.has(type)) { const br = lightLevel / MAX_LIGHT_LEVEL; r = (r * br) | 0; g = (g * br) | 0; b = (b * br) | 0; }
                    
                    // Blend or draw opaque
                    if (isFluid(type)) {
                        blendPixel(pixels, destI, r | 0, g | 0, b | 0, fluidAlpha(type));
                    } else {
                        pixels[destI] = r | 0; pixels[destI + 1] = g | 0; pixels[destI + 2] = b | 0; pixels[destI + 3] = 255;
                    }
                }
            }

            // --- The rest of the function remains the same ---
            ctx.putImageData(imageData, 0, 0);
            //renderBloom();

            // Render Rigid Bodies
            for (const body of rigidBodies) {
                if (!body.body) continue;
                const pos = body.body.getPosition(), angle = body.body.getAngle();
                ctx.save();
                ctx.translate(pos.x * B2_SCALE - camera.x, pos.y * B2_SCALE - camera.y);
                ctx.rotate(angle);
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const type = body.pixels[y * body.width + x];
                        if (type === MAT.EMPTY) continue;
                        let r, g, b;
                        if (SHIMMERING_METALS.has(type)) { [r, g, b] = metallicColor(x, y, COLORS[type]); } else { [r, g, b] = varyColor(...COLORS[type], x, y, type, 8); }
                        ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
                        ctx.fillRect(x - body.width / 2, y - body.height / 2, 1, 1);
                    }
                }
                ctx.restore();
            }

            // Player and Particles
            const aim = computePlayerAim();
            const anim = getPlayerAnimFrame();
            const playerDraw = renderPlayer(aim, anim);
            wandScreenX = playerDraw.wandOriginX;
            wandScreenY = playerDraw.wandOriginY;

            for (const p of pouredParticles) { const [r, g, b] = COLORS[p.type]; ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1); }
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) { const p = magicParticlePool[i]; if (p.active) { ctx.fillStyle = `rgb(${p.color[0]},${p.color[1]},${p.color[2]})`; ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1); } }

            // UI elements
            if (player.canInteract && player.currentTrigger) {
                const trigger = player.currentTrigger, hintX = Math.round(trigger.x - camera.x + trigger.width / 2), hintY = Math.round(trigger.y - camera.y - 15);
                const animatedY = hintY + Math.sin(frameCount * 0.05) * 3;
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(hintX - 8, animatedY - 12, 16, 16);
                ctx.font = 'bold 12px monospace'; ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('E', hintX, animatedY);
            }
            ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.moveTo(wandScreenX, wandScreenY); ctx.lineTo(mouse.x / scale, mouse.y / scale); ctx.stroke();

            renderPlayerStatsUI();
            renderAlchemyUI();
        }
        
        // This group of functions can remain as-is
		const PLAYER_SPRITE = [["....##..","...####.","..######","..##F##.","..##F##.","..######",".#######",".#######",".#######",".#######","..######","..######","...####.","..######",".######.","########"],["....##..","...####.","..######","..##F##.","..##F##.","..######",".#######",".#######",".#######",".#######","..######","...#####","..#####.","..######",".######.","########"]];
		function drawPlayerBodyScreen(baseScreenX,baseScreenY,facingRight,bob,frameIdx){const cloak=[0x4a,0x2d,0x5e],face=[0x21,0x1e,0x20],sprite=PLAYER_SPRITE[frameIdx&1];for(let y=0;y<16;y++){const row=sprite[y];for(let x=0;x<8;x++){const ch=row[x];if(ch==='.')continue;const fx=facingRight?x:(7-x),sx=baseScreenX+fx,sy=baseScreenY+y+bob;if(ch==='F')drawPlayerPx(sx,sy,face[0],face[1],face[2]);else drawPlayerPx(sx,sy,cloak[0],cloak[1],cloak[2]);}}}
		function blendPixel(pixels,destI,r,g,b,a){if(a>=255){pixels[destI]=r;pixels[destI+1]=g;pixels[destI+2]=b;pixels[destI+3]=255;return;}if(a<=0)return;const invA=255-a;pixels[destI]=((r*a+pixels[destI]*invA)/255)|0;pixels[destI+1]=((g*a+pixels[destI+1]*invA)/255)|0;pixels[destI+2]=((b*a+pixels[destI+2]*invA)/255)|0;pixels[destI+3]=255;}
        function getWorldTypeAtScreen(screenX,screenY){ const worldX=(screenX+camera.x)|0, worldY=(screenY+camera.y)|0; return getGrid(worldX, worldY); }
		function playerAlphaAtScreen(screenX,screenY){const t=getWorldTypeAtScreen(screenX,screenY);if(!isFluid(t))return 1;const a=fluidAlpha(t)/255,minAlpha=0.20,strength=0.85,out=1-a*strength;return out<minAlpha?minAlpha:out;}
		function drawPlayerPx(screenX,screenY,r,g,b){const a=playerAlphaAtScreen(screenX,screenY);if(a>=0.999){ctx.fillStyle=`rgb(${r|0},${g|0},${b|0})`;ctx.fillRect(screenX,screenY,1,1);return;}ctx.save();ctx.globalAlpha=a;ctx.fillStyle=`rgb(${r|0},${g|0},${b|0})`;ctx.fillRect(screenX,screenY,1,1);ctx.restore();}
		const PLAYER_SPRITE_SCALE=1.0;
		function computePlayerAim(){const aimDX=mouse.worldX-(player.x+player.width/2),aimDY=(player.y+9)-mouse.worldY,aimAngle=Math.atan2(aimDY,aimDX),wandDir=angleToDir16(aimAngle);playerFacingRight=aimDX>=0;return{facingRight:playerFacingRight,wandDir,aimAngle};}
		function getPlayerAnimFrame(){const moving=keys['KeyA']||keys['KeyD']||keys['KeyW']||Math.abs(player.vx)>0.05||Math.abs(player.vy)>0.05,rate=moving?6:14,frameIdx=((frameCount/rate)|0)&1;return{bob:frameIdx?1:0,armBob:frameIdx?1:0,frameIdx};}
		function drawWand(ctx,baseScreenX,baseScreenY,facingRight,wandDir,bob,armBob){const handLocalX=facingRight?8:-1,handLocalY=9+bob-armBob,handX=baseScreenX+handLocalX,handY=baseScreenY+handLocalY,wandLen=3,dx=wandDir.x,dy=wandDir.y,mag=Math.max(Math.abs(dx),Math.abs(dy))||1;ctx.fillStyle='#bfa76a';for(let i=0;i<wandLen;i++)ctx.fillRect(handX+Math.round(dx*i/mag),handY+Math.round(dy*i/mag),1,1);ctx.fillStyle='#ffcc66';ctx.fillRect(handX+Math.round(dx*wandLen/mag),handY+Math.round(dy*wandLen/mag),1,1);return{wandOriginX:handX,wandOriginY:handY};}
		function renderPlayer(aim,anim){const baseW=8,baseH=16,playerScreenX=Math.round(player.x-camera.x),playerScreenY=Math.round(player.y-camera.y);ctx.imageSmoothingEnabled=false;const anchorX=playerScreenX+(baseW/2),anchorY=playerScreenY+baseH;ctx.save();ctx.translate(anchorX,anchorY);ctx.scale(PLAYER_SPRITE_SCALE,PLAYER_SPRITE_SCALE);const localX=-baseW/2,localY=-baseH;ctx.translate(localX,localY);ctx.restore();const scaledBaseX=Math.round(anchorX+localX*PLAYER_SPRITE_SCALE),scaledBaseY=Math.round(anchorY+localY*PLAYER_SPRITE_SCALE);drawPlayerBodyScreen(scaledBaseX,scaledBaseY,aim.facingRight,anim.bob,anim.frameIdx);return drawWand(ctx,scaledBaseX,scaledBaseY,aim.facingRight,aim.wandDir,anim.bob,anim.armBob);}
		function createWoodenBox(x,y,width=16,height=16){const box=new RigidBody(x,y,width,height,MAT.WOOD);rigidBodies.push(box);}
        
        function updateRigidBodyInteractions() {
            const now = performance.now();
            const SPLIT_COOLDOWN_MS = 250, SPLIT_DELTA_THRESHOLD = 25;
            const RB_GAS_BUDGET_PER_BODY = 10, RB_GAS_CHANCE = 0.25;
            const isStructural = (t)=>(t!==MAT.EMPTY&&t!==MAT.GAS);

            for (const body of rigidBodies) {
                if (body.isDestroyed) continue;
                body.lastSplitTime=body.lastSplitTime??0; body.pendingStructuralDelta=body.pendingStructuralDelta??0;
                let pixelsChanged=false, structuralEditsThisTick=0;
                
                body_pixel_loop: for(let y=0;y<body.height;y++){ for(let x=0;x<body.width;x++){
                    const lIdx=y*body.width+x, type=body.pixels[lIdx]; if(type===MAT.EMPTY)continue;
                    const lPos=pl.Vec2((x-body.width/2+0.5)/B2_SCALE,(y-body.height/2+0.5)/B2_SCALE), wPos=body.body.getWorldPoint(lPos);
                    const wX=Math.floor(wPos.x*B2_SCALE), wY=Math.floor(wPos.y*B2_SCALE);
                    if (type===MAT.WOOD){ for(let dy=-2;dy<=2;dy++){ for(let dx=-2;dx<=2;dx++){
                        const worldMaterial = getGrid(wX+dx, wY+dy);
                        if(worldMaterial===MAT.ACID){ const oldT=body.pixels[lIdx],newT=MAT.EMPTY;if(oldT!==newT){body.pixels[lIdx]=newT;setGrid(wX+dx,wY+dy,MAT.EMPTY);pixelsChanged=true;if(isStructural(oldT)!==isStructural(newT))structuralEditsThisTick++;} continue body_pixel_loop; }
                        if((worldMaterial===MAT.FIRE||worldMaterial===MAT.OIL_BURNING||worldMaterial===MAT.COAL_BURNING)&&Math.random()<0.25){ const oldT=body.pixels[lIdx],newT=MAT.FIRE;if(oldT!==newT){body.pixels[lIdx]=newT;pixelsChanged=true;if(isStructural(oldT)!==isStructural(newT))structuralEditsThisTick++;} continue body_pixel_loop; }
                    }}}
                }}

                let rbGasBudget=RB_GAS_BUDGET_PER_BODY;
                function emitGas(lIdx){ const lx=lIdx%body.width,ly=(lIdx/body.width)|0,lPos=pl.Vec2((lx-body.width/2+0.5)/B2_SCALE,(ly-body.height/2+0.5)/B2_SCALE),wPos=body.body.getWorldPoint(lPos),wx=Math.floor(wPos.x*B2_SCALE),wy=Math.floor(wPos.y*B2_SCALE); if(getGrid(wx,wy)===MAT.EMPTY||getGrid(wx,wy)===MAT.GAS)setGrid(wx,wy,MAT.GAS); }
                const localSetter=(idx,type)=>{ if(idx===-1)return; const oldT=body.pixels[idx]; if(type===MAT.GAS){ if(rbGasBudget>0&&Math.random()<RB_GAS_CHANCE){emitGas(idx);rbGasBudget--;} const newT=MAT.EMPTY;if(oldT!==newT){body.pixels[idx]=newT;pixelsChanged=true;if(isStructural(oldT)!==isStructural(newT))structuralEditsThisTick++;} return; } if(oldT!==type){body.pixels[idx]=type;pixelsChanged=true;if(isStructural(oldT)!==isStructural(type))structuralEditsThisTick++;} };
                runSimulationOnSmallGrid(body.moved,body.pixels,body.width,body.height,localSetter);
                if (pixelsChanged){ let leaks=0; for(let y=0;y<body.height&&leaks<3;y++){ for(let x=0;x<body.width&&leaks<3;x++){ if(body.pixels[y*body.width+x]!==MAT.FIRE)continue; const lPos=pl.Vec2((x-body.width/2+0.5)/B2_SCALE,(y-body.height/2+0.5)/B2_SCALE),wPos=body.body.getWorldPoint(lPos),wX=Math.floor(wPos.x*B2_SCALE),wY=Math.floor(wPos.y*B2_SCALE); const dirs=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}],d=dirs[(Math.random()*dirs.length)|0]; const checkType=getGrid(wX+d.dx,wY+d.dy); if(checkType===MAT.EMPTY||checkType===MAT.GAS){setGrid(wX+d.dx,wY+d.dy,MAT.FIRE);leaks++;} }}}
                if(structuralEditsThisTick>0)body.pendingStructuralDelta+=structuralEditsThisTick;
                if(body.pendingStructuralDelta>=SPLIT_DELTA_THRESHOLD&&(now-body.lastSplitTime)>SPLIT_COOLDOWN_MS){body.needsShapeUpdate=true;body.pendingStructuralDelta=0;body.lastSplitTime=now;}
            }
        }

        function renderContainers() {
            const pouchX = renderWidth - pouchWidth - 12;
            const flaskX = pouchX - flaskWidth - 8;
            const commonY = 40;
            renderContainer(pouchGrid,pouchWidth,pouchHeight,pouchX,commonY,activeContainer==='pouch');
            renderContainer(flaskGrid,flaskWidth,flaskHeight,flaskX,commonY,activeContainer==='flask');
        }
        function renderContainer(cGrid,cW,cH,screenX,screenY,isActive) {
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(screenX-2,screenY-2,cW+4,cH+4);
            ctx.strokeStyle=isActive?'white':'#888'; ctx.lineWidth=2; ctx.strokeRect(screenX-2,screenY-2,cW+4,cH+4);
            for(let y=0;y<cH;y++)for(let x=0;x<cW;x++){
                const type=cGrid[getIdx(x,y,cW,cH)];
                if(type!==MAT.EMPTY){ let r,g,b; if(SHIMMERING_METALS.has(type)){[r,g,b]=metallicColor(x,y,COLORS[type]);}else{[r,g,b]=varyColor(...COLORS[type],x,y,type,8);} ctx.fillStyle=`rgb(${r},${g},${b})`;ctx.fillRect(screenX+x,screenY+y,1,1); }
            }
        }

        function renderBloom() {
            const bloomResolution = 4, blurPasses = 3;
            bloomCtx.clearRect(0, 0, bloomCanvas.width, bloomCanvas.height);
            bloomCtx.globalCompositeOperation = 'source-over';
            const camX = Math.floor(camera.x), camY = Math.floor(camera.y);

            for (let y = 0; y < viewHeight; y++) {
                for (let x = 0; x < viewWidth; x++) {
                    const type = getGrid(x + camX, y + camY);
                    const bloomConfig = BLOOM_MATERIALS[type];
                    if (bloomConfig) {
                        const [r, g, b] = bloomConfig.color;
                        bloomCtx.fillStyle = `rgba(${r},${g},${b},${bloomConfig.intensity})`;
                        bloomCtx.fillRect(x/bloomResolution,y/bloomResolution,1,1);
                    }
                }
            }
            bloomCtx.globalCompositeOperation = 'copy';
            for (let i = 0; i < blurPasses; i++) {
                bloomCtx.filter = `blur(${1 << i}px)`;
                bloomCtx.drawImage(bloomCanvas, 0, 0);
            }
            bloomCtx.filter = 'none';
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 1.0;
            ctx.drawImage(bloomCanvas, 0, 0, renderWidth, renderHeight);
            ctx.restore();
        }

        const WAND_DIRS_16=[{x:1,y:0},{x:2,y:-1},{x:1,y:-1},{x:1,y:-2},{x:0,y:-1},{x:-1,y:-2},{x:-1,y:-1},{x:-2,y:-1},{x:-1,y:0},{x:-2,y:1},{x:-1,y:1},{x:-1,y:2},{x:0,y:1},{x:1,y:2},{x:1,y:1},{x:2,y:1}];
        function angleToDir16(a){ const step=Math.PI/8; const i=Math.round(a/step)&15; return WAND_DIRS_16[i]; }
        function hashCell(x,y,type){ let h=x*374761393+y*668265263+type*1442695041; h=(h^(h>>13))*1274126177; return(h^(h>>16))&0xff; }
        function metallicColor(x,y,baseRGB){const[br,bg,bb]=baseRGB,s1=0.5+0.5*Math.sin((x*0.35)+(y*0.18)),s2=0.5+0.5*Math.sin((x*0.08)-(y*0.12)),t=0.65*s1+0.35*s2,glint=(Math.sin(x*0.9+y*0.25)>0.985)?0.25:0.0,m=0.85+0.35*t+glint,r=Math.min(255,Math.max(0,br*m)),g=Math.min(255,Math.max(0,bg*(m*0.98))),b=Math.min(255,Math.max(0,bb*(m*1.05)));return[r|0,g|0,b|0];}
        function varyColor(r,g,b,x,y,type,strength=18){ const n=hashCell(x,y,type)/255, delta=(n-0.5)*strength*2; return[Math.max(0,Math.min(255,r+delta)),Math.max(0,Math.min(255,g+delta)),Math.max(0,Math.min(255,b+delta))]; }
        function updateHoverMaterial(){ hudMaterial = MATERIAL_NAME[getGrid(mouse.worldX, mouse.worldY)] || 'Unknown'; }
        
        function generateRunicSlab(slabX,slabY,slabWidth,slabHeight,bgMat,runeMat) {
            for(let y=slabY;y<slabY+slabHeight;y++)for(let x=slabX;x<slabX+slabWidth;x++) setGrid(x,y,bgMat);
            const vPad=Math.floor((slabHeight-DWARVEN_RUNES.RUNE_HEIGHT)/2),runesTopY=slabY+vPad,runesBottomY=runesTopY+DWARVEN_RUNES.RUNE_HEIGHT-1;
            const linePad=3,topLineY=runesTopY-linePad,bottomLineY=runesBottomY+linePad;
            for(let x=slabX;x<slabX+slabWidth;x++){ setGrid(x,topLineY,runeMat); setGrid(x,bottomLineY,runeMat); }
            let cursorX = slabX + 5;
            while(cursorX+DWARVEN_RUNES.RUNE_WIDTH+5<slabX+slabWidth){
                const pattern=DWARVEN_RUNES.PATTERNS[Math.floor(Math.random()*DWARVEN_RUNES.PATTERNS.length)];
                for(let y=0;y<DWARVEN_RUNES.RUNE_HEIGHT;y++)for(let x=0;x<DWARVEN_RUNES.RUNE_WIDTH;x++) if(pattern[y][x]===1) setGrid(cursorX+x,runesTopY+y,runeMat);
                cursorX+=DWARVEN_RUNES.RUNE_WIDTH+5;
            }
        }
        
        // This group of functions can remain as-is
		function createMagicEmitter(options){const emitter={id:nextEmitterId++,mainColor:options.mainColor||[255,255,255],spawnRate:options.spawnRate||0.2,spawnType:options.spawnType||'area',x:options.x||0,y:options.y||0,spawnArea:options.spawnArea||{width:10,height:5},x1:options.x1||0,y1:options.y1||0,x2:options.x2||0,y2:options.y2||0,particleLifespan:options.particleLifespan||{min:60,max:150},particleVelocity:options.particleVelocity||{vx:{min:-0.2,max:0.2},vy:{min:-0.2,max:-0.6}},colorVariance:options.colorVariance||60};magicEmitters.push(emitter);return emitter.id;}
		function removeMagicEmitter(id){magicEmitters=magicEmitters.filter(e=>e.id!==id);}
		function updateMagicEmitters(){for(const emitter of magicEmitters){if(Math.random()<emitter.spawnRate){for(let i=0;i<MAX_MAGIC_PARTICLES;i++){const p=magicParticlePool[i];if(!p.active){let spawnX,spawnY;if(emitter.spawnType==='line'){const t=Math.random();spawnX=emitter.x1+t*(emitter.x2-emitter.x1);spawnY=emitter.y1+t*(emitter.y2-emitter.y1);}else{spawnX=emitter.x+(Math.random()-0.5)*emitter.spawnArea.width;spawnY=emitter.y+(Math.random()-0.5)*emitter.spawnArea.height;}const r=Math.max(0,Math.min(255,emitter.mainColor[0]+(Math.random()-0.5)*emitter.colorVariance)),g=Math.max(0,Math.min(255,emitter.mainColor[1]+(Math.random()-0.5)*emitter.colorVariance)),b=Math.max(0,Math.min(255,emitter.mainColor[2]+(Math.random()-0.5)*emitter.colorVariance));p.active=true;p.gravity=0;p.x=spawnX;p.y=spawnY;p.vx=emitter.particleVelocity.vx.min+Math.random()*(emitter.particleVelocity.vx.max-emitter.particleVelocity.vx.min);p.vy=emitter.particleVelocity.vy.min+Math.random()*(emitter.particleVelocity.vy.max-emitter.particleVelocity.vy.min);p.lifespan=emitter.particleLifespan.min+Math.random()*(emitter.particleLifespan.max-emitter.particleLifespan.min);p.color=[r,g,b];break;}}}}}
		function spawnLevitationParticles(count){let spawnedCount=0;const baseX=player.x+player.width/2,baseY=player.y+player.height-2;for(let i=0;i<MAX_MAGIC_PARTICLES;i++){const p=magicParticlePool[i];if(!p.active){p.active=true;p.x=baseX+(Math.random()-0.5)*4;p.y=baseY+(Math.random()-0.5)*2;p.vx=(Math.random()-0.5)*0.5;p.vy=(Math.random()*0.8)+0.4-(player.vy*0.1);const baseColor=[180,200,255],colorVariance=40;p.color=[Math.max(0,Math.min(255,baseColor[0]+(Math.random()-0.5)*colorVariance)),Math.max(0,Math.min(255,baseColor[1]+(Math.random()-0.5)*colorVariance)),Math.max(0,Math.min(255,baseColor[2]+(Math.random()-0.5)*colorVariance))];p.lifespan=15+Math.random()*20;spawnedCount++;if(spawnedCount>=count)return;}}}
		function spawnMagicParticles(count,x,y,mainColor){let spawnedCount=0;for(let i=0;i<MAX_MAGIC_PARTICLES;i++){const p=magicParticlePool[i];if(!p.active){p.active=true;p.x=x+(Math.random()-0.5)*20;p.y=y+(Math.random()-0.5)*10;const colorVariance=60,r=Math.max(0,Math.min(255,mainColor[0]+(Math.random()-0.5)*colorVariance)),g=Math.max(0,Math.min(255,mainColor[1]+(Math.random()-0.5)*colorVariance)),b=Math.max(0,Math.min(255,mainColor[2]+(Math.random()-0.5)*colorVariance));p.color=[r,g,b];p.vx=(Math.random()-0.5)*0.3;p.vy=-0.2+(Math.random()*-0.4);p.lifespan=60+Math.random()*90;spawnedCount++;if(spawnedCount>=count)return;}}}
		function updateMagicParticles(){for(let i=0;i<MAX_MAGIC_PARTICLES;i++){const p=magicParticlePool[i];if(!p.active)continue;p.x+=p.vx;p.y+=p.vy;if(p.gravity)p.vy+=p.gravity;p.lifespan--;if(p.lifespan<=0)p.active=false;}}
        
        function checkForLiquidSplashes(now) {
            const MIN_SPLASH_SPEED = 2.0;
            const allBodies = [...rigidBodies, player];
            for (const bodyInst of allBodies) {
                if (!bodyInst.body || bodyInst.isDestroyed) continue;
                bodyInst.wasInLiquid = bodyInst.wasInLiquid ?? false;
                let isInLiquid=false, splashX=0, splashY=0, splashMat=0;
                const samplePointsX=[bodyInst.width*0.25,bodyInst.width*0.5,bodyInst.width*0.75], localY=bodyInst.height-1;
                for(const localX of samplePointsX){
                    const wPos=bodyInst.body.getWorldPoint(pl.Vec2((localX-bodyInst.width/2)/B2_SCALE,(localY-bodyInst.height/2)/B2_SCALE));
                    const wX=Math.floor(wPos.x*B2_SCALE),wY=Math.floor(wPos.y*B2_SCALE);
                    const matType=getGrid(wX,wY);
                    if(isLiquid(matType)){isInLiquid=true;splashX=wX;splashY=wY;splashMat=matType;break;}
                }
                if(isInLiquid&&!bodyInst.wasInLiquid){ const speed=bodyInst.body.getLinearVelocity().length(); if(speed>MIN_SPLASH_SPEED)createSplashEffect(splashX,splashY,splashMat,speed); }
                bodyInst.wasInLiquid = isInLiquid;
            }
        }
        function createSplashEffect(x,y,matType,vel){
            const isLiq=LIQUIDS.has(matType),baseColor=COLORS[matType]||[255,255,255],pCount=Math.min(10,Math.ceil(vel*3)),velMult=0.5+vel*0.2;
            let spawned=0;
            for(let i=0;i<MAX_MAGIC_PARTICLES&&spawned<pCount;i++){
                const p=magicParticlePool[i]; if(p.active)continue; p.active=true; p.x=x+(Math.random()-0.5)*4; p.y=y;
                const v=30; p.color=[Math.max(0,Math.min(255,baseColor[0]+(Math.random()-0.5)*v)),Math.max(0,Math.min(255,baseColor[1]+(Math.random()-0.5)*v)),Math.max(0,Math.min(255,baseColor[2]+(Math.random()-0.5)*v))];
                const angle=(Math.random()*Math.PI)+Math.PI,speed=Math.random()*1.5*velMult;
                if(isLiq){p.vx=Math.cos(angle)*speed;p.vy=Math.sin(angle)*speed*1.5;p.gravity=0.05;p.lifespan=15+Math.random()*15;}
                else{p.vx=Math.cos(angle)*speed*1.2;p.vy=Math.sin(angle)*speed*0.5;p.gravity=0;p.lifespan=10+Math.random()*10;}
                spawned++;
            }
        }
        
        // This group of functions can remain as-is
		function getDominantMaterialInArea(x,y,width,height){const counts={};let maxCount=0,domMat=null;for(let iy=y;iy<y+height;iy++){for(let ix=x;ix<x+width;ix++){const type=getGrid(ix,iy);if(STORABLE_SOLIDS.has(type)||STORABLE_LIQUIDS.has(type)){counts[type]=(counts[type]||0)+1;if(counts[type]>maxCount){maxCount=counts[type];domMat=type;}}}}return domMat;}
		function processAlchemyJobs(){if(alchemyJobs.length===0)return;const particlesToTeleport=5;for(let i=alchemyJobs.length-1;i>=0;i--){const job=alchemyJobs[i],target=job.target;for(let j=0;j<particlesToTeleport;j++){if(job.manifest.length===0){alchemyJobs.splice(i,1);break;}const matInfo=job.manifest.shift();const rimX=target.cx,rimY=target.cy,span=target.r*0.6,spawnX=Math.floor(rimX+(Math.random()*2-1)*span),spawnY=Math.floor(rimY-(30+Math.random()*10));const spawnType=getGrid(spawnX,spawnY);if(spawnType===MAT.EMPTY){setGrid(spawnX,spawnY,matInfo.type);activateChunkAt(spawnX,spawnY);}else{job.manifest.unshift(matInfo);}}}}
		const ALCHEMY_REACTIONS={'filter_material':{name:"Filter Material",execute:function(station){const filterMat=getDominantMaterialInSemicircle(station.sampler);if(filterMat===null)return;const source=station.cauldrons.left,target=station.cauldrons.right,manifest=[];forEachInDownwardSemicircle(source,(x,y)=>{if(getGrid(x,y)===filterMat){manifest.push({type:filterMat});setGrid(x,y,MAT.EMPTY);activateChunkAt(x,y);}});if(manifest.length===0)return;alchemyJobs.push({manifest:manifest,target:target});}},'heat_material':{name:"Heat Material",execute:function(station){const source=station.cauldrons.left;spawnMagicParticles(50,source.cx,source.cy+source.r*0.5,[255,100,0]);forEachInDownwardSemicircle(source,(x,y)=>{let changed=true;switch(getGrid(x,y)){case MAT.SAND:setGrid(x,y,MAT.GLASS);break;case MAT.WOOD:setGrid(x,y,MAT.FIRE);break;case MAT.OIL:setGrid(x,y,MAT.OIL_BURNING);break;case MAT.COAL:setGrid(x,y,MAT.COAL_BURNING);break;case MAT.GUNPOWDER:setGrid(x,y,MAT.GUNPOWDER_IGNITED);setAuxData(etcChunkMap,x,y,8+Math.floor(Math.random()*6));break;case MAT.WATER:setGrid(x,y,MAT.GAS);break;default:changed=false;break;}if(changed)activateChunkAt(x,y);});}},'clear_cauldrons':{name:"Clear Cauldrons",execute:function(station){const areas=[station.cauldrons.left,station.cauldrons.right,station.sampler];for(const area of areas){spawnMagicParticles(30,area.cx,area.cy,[200,200,255]);forEachInDownwardSemicircle(area,(x,y)=>{const type=getGrid(x,y);if(type!==MAT.ADAMANTIUM&&type!==MAT.RUNE_WALL){setGrid(x,y,MAT.EMPTY);activateChunkAt(x,y);}});}}}};
		function forEachInDownwardSemicircle(area,fn){const cx=area.cx,cy=area.cy,r=area.r,r2=r*r,minX=Math.floor(cx-r),maxX=Math.ceil(cx+r),minY=Math.floor(cy),maxY=Math.ceil(cy+r);for(let y=minY;y<=maxY;y++){const dy=y-cy,dy2=dy*dy;for(let x=minX;x<=maxX;x++){const dx=x-cx;if(dx*dx+dy2<=r2)fn(x,y);}}}
		function getDominantMaterialInSemicircle(area){const counts=new Map();forEachInDownwardSemicircle(area,(x,y)=>{const t=getGrid(x,y);if(t===MAT.EMPTY||t===MAT.ADAMANTIUM||t===MAT.RUNE_WALL)return;counts.set(t,(counts.get(t)||0)+1);});let bestType=null,bestCount=0;for(const[t,c]of counts)if(c>bestCount){bestType=t;bestCount=c;}return bestType;}
        
        function generateAlchemyStation() {
            const width=600,height=200,startX=0,startY=-200,floorY=startY+height-20;
            for(let y=startY;y<startY+height;y++)for(let x=startX;x<startX+width;x++)setGrid(x,y,MAT.EMPTY);
            for(let y=floorY;y<startY+height;y++)for(let x=startX;x<startX+width;x++)setGrid(x,y,MAT.ADAMANTIUM);
            const slabH=15,slabW=70,slabY=floorY-slabH,slabX=startX+130;
            generateRunicSlab(slabX,slabY,slabW,slabH,MAT.ADAMANTIUM,MAT.RUNE_WALL);
            const leftX=startX+260,rightX=startX+390,samplerX=startX+325,rimY=floorY-15,cauldronR=32,cauldronT=4,cauldronInnerR=cauldronR-cauldronT,samplerR=16,samplerT=4,samplerInnerR=samplerR-samplerT;
            createCauldron(leftX,rimY,cauldronR,cauldronT,MAT.ADAMANTIUM,MAT.RUNE_WALL);
            createCauldron(rightX,rimY,cauldronR,cauldronT,MAT.ADAMANTIUM,MAT.RUNE_WALL);
            createCauldron(samplerX,floorY-10,samplerR,samplerT,MAT.ADAMANTIUM,MAT.RUNE_WALL);
            const stationGeo={cauldrons:{left:{cx:leftX,cy:rimY,r:cauldronInnerR},right:{cx:rightX,cy:rimY,r:cauldronInnerR}},sampler:{cx:samplerX,cy:floorY-10,r:samplerInnerR}};
            createTrigger({x:slabX,y:slabY,width:slabW,height:slabH,onEnter:function(t){const eId=createMagicEmitter({spawnType:'line',x1:slabX,y1:slabY,x2:slabX+slabW,y2:slabY,mainColor:[255,230,100],spawnRate:0.5});t.associatedData.emitterId=eId;},onLeave:function(t){if(t.associatedData.emitterId!=null){removeMagicEmitter(t.associatedData.emitterId);t.associatedData.emitterId=null;}},onInteract:function(){isAlchemyUIVisible=true;},associatedData:{stationGeometry:stationGeo}});
        }
        function createCauldron(cx,rimY,radius,thickness,material,edgeMaterial){const r2=radius*radius,orInner=radius-1,orInner2=orInner*orInner,ir=radius-thickness,ir2=ir*ir;for(let dy=0;dy<=radius;dy++)for(let dx=-radius;dx<=radius;dx++){const d2=dx*dx+dy*dy;if(d2<=r2)setGrid(cx+dx,rimY+dy,d2>orInner2?edgeMaterial:material);}for(let dy=0;dy<ir;dy++)for(let dx=-ir;dx<=ir;dx++)if(dx*dx+dy*dy<=ir2)setGrid(cx+dx,rimY+dy,MAT.EMPTY);}

        function prioritizeAndLimitActiveChunks() {
            const allChunksToConsider = new Set([...pendingActiveChunks, ...nextActiveChunks]);
            nextActiveChunks.clear();

            const priorityChunks = new Set();
            const otherChunks = [];
            const camChunkX1 = Math.floor(camera.x / CHUNK_SIZE), camChunkX2 = Math.floor((camera.x + viewWidth) / CHUNK_SIZE);
            const camChunkY1 = Math.floor(camera.y / CHUNK_SIZE), camChunkY2 = Math.floor((camera.y + viewHeight) / CHUNK_SIZE);

            for (const key of allChunksToConsider) {
                const chunk = chunkMap.get(key);
                if (!chunk) continue; // Should not happen, but a good safeguard

                const cx = chunk.cx;
                const cy = chunk.cy;
                if (cx >= camChunkX1 && cx <= camChunkX2 && cy >= camChunkY1 && cy <= camChunkY2) {
                    priorityChunks.add(key);
                } else {
                    otherChunks.push(key);
                }
            }
            const pChunkX = Math.floor(player.x / CHUNK_SIZE), pChunkY = Math.floor(player.y / CHUNK_SIZE);
            otherChunks.sort((a, b) => {
                const chunkA = chunkMap.get(a);
                const chunkB = chunkMap.get(b);
                if (!chunkA || !chunkB) return 0;
                
                const distA = (chunkA.cx - pChunkX) ** 2 + (chunkA.cy - pChunkY) ** 2;
                const distB = (chunkB.cx - pChunkX) ** 2 + (chunkB.cy - pChunkY) ** 2;
                return distA - distB;
            });
            const processingOrder = [...priorityChunks, ...otherChunks];
            const chunksToProcess = processingOrder.slice(0, priorityChunks.size + MAX_CHUNKS_PER_FRAME);
            pendingActiveChunks = processingOrder.slice(priorityChunks.size + MAX_CHUNKS_PER_FRAME);
            activeChunks.clear();
            for (const key of chunksToProcess) activeChunks.add(key);
        }

        // --- GAME LOOP ---
        function gameLoop(now = performance.now()) {
            frameCount++;
            framesThisSecond++;
            if (now - lastFpsTime >= 1000) {
                hudFPS = framesThisSecond;
                framesThisSecond = 0;
                lastFpsTime = now;
            }

            checkGenerationQueue() 

            updateSectors();
            const t0 = performance.now();
            if (frameCount % VISIBLE_LIQUID_SCAN_INTERVAL === 0) {
                findAndActivateVisibleLiquidSurfaces();
            }
            prioritizeAndLimitActiveChunks();
            
            // --- UPDATE LOGIC ---
            updatePlayer();
            updateRigidBodyInteractions();
            // --- THIS IS THE FIX ---
            // This call advances the PlanckJS physics simulation, applying gravity and forces.
            tOtherMs2 = performance.now() - t0;
            updateRigidBodies(now);
            // --- END OF FIX ---
            
            syncPlayerWithBody();
            checkForLiquidSplashes(now);
            updateRigidBodyGrid();

            //x

            const newBodiesFromSplits = [];
            for (let i = rigidBodies.length - 1; i >= 0; i--) {
                const body = rigidBodies[i];
                if (body.isDestroyed) continue;

                if (body.needsShapeUpdate && (now - body.lastRebuildTime > REBUILD_COOLDOWN)) {
                    const newBodies = checkForSplits(body);
                    if (newBodies && newBodies.length) {
                        newBodiesFromSplits.push(...newBodies);
                        body.needsShapeUpdate = false;
                        body.lastRebuildTime = now;
                    } else {
                        body.rebuildFixtures();
                        body.lastRebuildTime = now;
                    }
                }
            }
            if (newBodiesFromSplits.length > 0) rigidBodies.push(...newBodiesFromSplits);
            
            cleanupDestroyedBodies();

            updatePouredParticles();
            processAlchemyJobs();
            updateMagicParticles();
            updateMagicEmitters();
            updateTriggers();

            const lightingQueue = [...activeChunks];
            const processedChunks = new Set(activeChunks);
            let head = 0;
            while (head < lightingQueue.length) {
                const chunkToUpdate = lightingQueue[head++];
                const newNeighbors = updateLocalLightingAndFindNeighbors(chunkToUpdate);
                for (const neighbor of newNeighbors) {
                    if (!processedChunks.has(neighbor)) {
                        processedChunks.add(neighbor);
                        lightingQueue.push(neighbor);
                    }
                }
            }

            if (isPouring) pourFromContainer();
            if (isStoring) storeMaterial(mouse.worldX, mouse.worldY);
            if (isDrawing || isPouring || isStoring) activateChunkAt(mouse.worldX, mouse.worldY);

            tOtherMs3 = performance.now() - t0 - tOtherMs2;

            const t1 = performance.now();
            // --- SIMULATIONS ---
            for (let i = 0; i < SIMULATION_STEPS_PER_FRAME; i++) {
                runWorldSimulationWithChunks();
                if (i === 0) {
                    const pouchSetter = (idx, type) => { if (idx !== -1) pouchGrid[idx] = type; };
                    runSimulationOnSmallGrid(movedPouch, pouchGrid, pouchWidth, pouchHeight, pouchSetter);
                    const flaskSetter = (idx, type) => { if (idx !== -1) flaskGrid[idx] = type; };
                    runSimulationOnSmallGrid(movedFlask, flaskGrid, flaskWidth, flaskHeight, flaskSetter);
                }
            }
            tSimMs = performance.now() - t1;

            updateCamera();
            mouse.worldX = Math.floor(camera.x + mouse.x / scale);
            mouse.worldY = Math.floor(camera.y + mouse.y / scale);

            const t2 = performance.now();
            // --- RENDER LOGIC ---
            render();
            renderContainers();
            drawHUD();
            tRenderMs = performance.now() - t2;

            if ((frameCount % 2) === 0) updateHoverMaterial();

            requestAnimationFrame(gameLoop);

            tOtherMs = performance.now() - t0 - tSimMs - tRenderMs;
            ctx.fillStyle = "white";
            ctx.font = "8px monospace";
            ctx.textAlign = "right";
            ctx.fillText(`sim: ${tSimMs.toFixed(2)}ms`, renderWidth - 6, renderHeight - 10);
            ctx.fillText(`render: ${tRenderMs.toFixed(2)}ms`, renderWidth - 6, renderHeight - 20);
            ctx.fillText(`other: ${tOtherMs.toFixed(2)}ms`, renderWidth - 6, renderHeight - 30);
            ctx.fillText(`other a: ${tOtherMs2.toFixed(2)}ms`, renderWidth - 6, renderHeight - 40);
            ctx.fillText(`other b: ${tOtherMs3.toFixed(2)}ms`, renderWidth - 6, renderHeight - 50);
            ctx.textAlign = "left";
        }
        
        function cleanupDestroyedBodies(){
            const kept=[];
            for(const rb of rigidBodies){
                if(!rb.isDestroyed){kept.push(rb);continue;}
                if(rb.body){rb.body.setUserData(null);rb.body.setActive(false);world.destroyBody(rb.body);rb.body=null;}
            }
            rigidBodies=kept;
        }

        function drawHUD(){
            ctx.imageSmoothingEnabled=false;ctx.font='8px monospace';ctx.textAlign='right';ctx.textBaseline='top';
            ctx.fillStyle='#00ff90';ctx.fillText(`FPS: ${hudFPS}`,renderWidth-6,6);
            ctx.fillStyle='#ffd966';ctx.fillText(`MAT: ${hudMaterial}`,renderWidth-6,6+10);
        }

        function createTrigger(options){
            const trigger={id:nextTriggerId++,x:options.x,y:options.y,width:options.width,height:options.height,onEnter:options.onEnter||function(){},onLeave:options.onLeave||function(){},onInteract:options.onInteract||function(){},isActive:false,associatedData:options.associatedData};
            triggers.push(trigger);return trigger.id;
        }
        function updateTriggers(){
            const playerCheckX=player.x+player.width/2, playerCheckY=player.y+player.height, leeway=2;
            let canInteract=false, activeTrig=null;
            for(const trigger of triggers){
                const isInside=(playerCheckX>=trigger.x&&playerCheckX<=trigger.x+trigger.width&&playerCheckY>=trigger.y-leeway&&playerCheckY<=trigger.y+trigger.height);
                if(isInside){canInteract=true;activeTrig=trigger;if(!trigger.isActive){trigger.isActive=true;trigger.onEnter(trigger);}}
                else{if(trigger.isActive){trigger.isActive=false;trigger.onLeave(trigger);}}
            }
            player.canInteract=canInteract; player.currentTrigger=activeTrig;
        }

        function renderAlchemyUI() {
            if(!isAlchemyUIVisible)return;
            ctx.fillStyle='rgba(0,0,0,0.6)';ctx.fillRect(0,0,renderWidth,renderHeight);
            const boxW=300,boxH=150,boxX=(renderWidth-boxW)/2,boxY=(renderHeight-boxH)/2;
            ctx.fillStyle='#222';ctx.fillRect(boxX,boxY,boxW,boxH);ctx.strokeStyle='#888';ctx.strokeRect(boxX,boxY,boxW,boxH);
            ctx.fillStyle='white';ctx.font='16px monospace';ctx.textAlign='left';ctx.textBaseline='top';ctx.fillText("Select a Reaction:",boxX+10,boxY+10);
            let yOff=40,idx=1;
            for(const key in ALCHEMY_REACTIONS){const r=ALCHEMY_REACTIONS[key];ctx.fillText(`[${idx}] ${r.name}`,boxX+20,boxY+yOff);yOff+=20;idx++;}
            ctx.fillStyle='#aaa';ctx.fillText("Press [ESC] to close.",boxX+10,boxY+boxH-25);
        }

        function updateLoadingStatus(message) { document.getElementById('loading-status').innerText=message; }

        async function mainLoader() {
            const loadingOverlay = document.getElementById('loading-overlay');
            const yieldToBrowser = () => new Promise(resolve => setTimeout(resolve, 20));
            
            WORLD_SEED = Math.floor(Math.random() * 1000000);
            generationWorker.postMessage({ type: 'init', seed: WORLD_SEED });

            PerlinNoise.seed(WORLD_SEED);
            
            staticPixelBuffer = new Uint8ClampedArray(renderWidth * renderHeight * 4);
            isRenderCacheInvalid = true;
            lastCameraX = -1;
            lastCameraY = -1;

            updateLoadingStatus('Carving Background Strata...');
            await yieldToBrowser();
            const bgTileCanvas = generateCaveBackgroundTile(BACKGROUND_TILE_SIZE, BACKGROUND_TILE_SIZE * 5);
            const bgTileCtx = bgTileCanvas.getContext('2d');
            backgroundTileData = bgTileCtx.getImageData(0, 0, bgTileCanvas.width, bgTileCanvas.height);

            updateLoadingStatus('Preparing Spawn Area...');
            await yieldToBrowser();
            
            const spawnSX = Math.floor(player.x / SECTOR_SIZE);
            const spawnSY = Math.floor(player.y / SECTOR_SIZE);

            // --- START OF THE FIX ---
            // We now use a more robust promise-based approach to guarantee initialization order.
            const firstSectorPromise = new Promise(resolve => {
                const tempLocalGenerator = new Worker('generation.worker.js');
                
                // This handler will receive messages from the temp worker
                tempLocalGenerator.onmessage = event => {
                    const { type, chunks } = event.data;

                    if (type === 'init-ack') {
                        console.log("Received");
                        // The worker has confirmed it is initialized. NOW we can ask it to generate.

                        const borderContext = gatherBorderContext(spawnSX, spawnSY);
                        tempLocalGenerator.postMessage({ type: 'generate-and-bake', sx: spawnSX, sy: spawnSY, borderContext: borderContext });
                    } 
                    else if (type === 'result') {
                        console.log("Received 2");
                        // The worker has sent back the terrain data.
                        for (const [key, payload] of chunks) {
                            const chunk = getChunk(chunkMap, key);
                            chunk.data = payload.data;
                            chunk.cx = payload.cx;
                            chunk.cy = payload.cy;
                        }
                        tempLocalGenerator.terminate(); // Clean up the temporary worker
                        resolve(); // Resolve the promise to continue loading
                    }
                };

                // Start the process by sending the init message.
                tempLocalGenerator.postMessage({ type: 'init', seed: WORLD_SEED });
            });

            await firstSectorPromise; // Wait until the entire init->generate->result cycle is complete.
            // --- END OF THE FIX ---

            //bakeLightingForSector(spawnSX, spawnSY);
            sectorGrid.set(coordToKey(spawnSX, spawnSY), 'ready');
            
            updateLoadingStatus('Constructing Ancient Structures...');
            await yieldToBrowser();
            generateAlchemyStation();

            updateLoadingStatus('Finalizing...');
            await yieldToBrowser();
            activateInitialChunks();
            createPlayerBody();
            createWoodenBox(150, -150, 24, 64);
            //createWoodenBox(150 + 128, -150, 24, 64);
            //createWoodenBox(150 + 64, -250, 128, 16);

            updateLoadingStatus('Done!');
            await new Promise(resolve => setTimeout(resolve, 100));
            loadingOverlay.style.transition = 'opacity 0.5s';
            loadingOverlay.style.opacity = '0';
            await new Promise(resolve => setTimeout(() => {
                loadingOverlay.style.display = 'none';
                resolve();
            }, 500));
            gameLoop();
        }

        function updateWorldColliders(now) {
            const neededChunks = new Set(),
                lookahead = 1,
                allDynBodies = [...rigidBodies, player];
            for (const bodyObj of allDynBodies) {
                if (!bodyObj.body) continue;
                const body = bodyObj.body;
                let aabb = null;
                for (let f = body.getFixtureList(); f; f = f.getNext()) {
                    const f_aabb = f.getAABB(0);
                    if (!aabb) aabb = { lX: f_aabb.lowerBound.x, lY: f_aabb.lowerBound.y, uX: f_aabb.upperBound.x, uY: f_aabb.upperBound.y };
                    else { aabb.lX = Math.min(aabb.lX, f_aabb.lowerBound.x); aabb.lY = Math.min(aabb.lY, f_aabb.lowerBound.y); aabb.uX = Math.max(aabb.uX, f_aabb.upperBound.x); aabb.uY = Math.max(aabb.uY, f_aabb.upperBound.y); }
                }
                if (!aabb) continue;
                const minCX = Math.floor(aabb.lX * B2_SCALE / CHUNK_SIZE) - lookahead,
                    maxCX = Math.ceil(aabb.uX * B2_SCALE / CHUNK_SIZE) + lookahead;
                const minCY = Math.floor(aabb.lY * B2_SCALE / CHUNK_SIZE) - lookahead,
                    maxCY = Math.ceil(aabb.uY * B2_SCALE / CHUNK_SIZE) + lookahead;
                for (let cy = minCY; cy <= maxCY; cy++)
                    for (let cx = minCX; cx <= maxCX; cx++) {
                        // --- THIS IS THE FIX ---
                        neededChunks.add(coordToKey(cx, cy)); // Use numeric key
                    }
            }
            for (const key of activeStaticChunks) {
                if (!neededChunks.has(key)) {
                    const chunk = chunkMap.get(key);
                    if (chunk && chunk.staticBody) chunk.staticBody.setActive(false);
                }
            }
            for (const key of neededChunks) {
                const chunk = getChunk(chunkMap, key);
                if (chunk.dirty && chunk.staticBody) {
                    if (now - chunk.lastRegenTime > REGEN_COOLDOWN) { world.destroyBody(chunk.staticBody); chunk.staticBody = null; }
                }
                if (!chunk.staticBody) { chunk.staticBody = generateStaticBodyForChunk(chunk); chunk.dirty = false; chunk.lastRegenTime = now; }
                chunk.staticBody.setActive(true);
            }
            activeStaticChunks = neededChunks;
        }

        function updateRigidBodies(now) {
            // THE FIX: Only run the expensive collider update logic periodically.
            if (now - lastColliderUpdateTime > COLLIDER_UPDATE_INTERVAL) {
                updateWorldColliders(now);
                lastColliderUpdateTime = now;
            }

            // The core physics step still runs every frame.
            world.step(1 / 60);
        }

        function generateStaticBodyForChunk(chunk) {
            const body=world.createBody({type:'static'});
            const startX=chunk.cx*CHUNK_SIZE, startY=chunk.cy*CHUNK_SIZE;
            const mask=new Uint8Array(CHUNK_SIZE*CHUNK_SIZE);
            for(let y=0;y<CHUNK_SIZE;y++)for(let x=0;x<CHUNK_SIZE;x++){
                const wX=startX+x, wY=startY+y;
                mask[y*CHUNK_SIZE+x]=isSolidForPlayer(getGrid(wX,wY)) && getAuxData(etcChunkMap, wX, wY) !== 1 ? 1 : 0;
            }
            const islands=extractIslands(mask,CHUNK_SIZE,CHUNK_SIZE);
            for(const island of islands){
                const outline=marchingSquares(island,CHUNK_SIZE,CHUNK_SIZE); if(outline.length<3)continue;
                const simplifiedPre=simplifyDouglasPeucker(outline,0.2); if(simplifiedPre.length<3)continue;
                const simplified=removeCollinear(simplifiedPre,0.001); if(simplified.length<3)continue;
                validatePolygon(simplified);
                const flat=[];for(const p of simplified)flat.push(p.x,p.y);
                const indices=earcut(flat);
                for(let i=0;i<indices.length;i+=3){
                    const p0=simplified[indices[i]],p1=simplified[indices[i+1]],p2=simplified[indices[i+2]];
                    const ax=(startX+p0.x)/B2_SCALE,ay=(startY+p0.y)/B2_SCALE,bx=(startX+p1.x)/B2_SCALE,by=(startY+p1.y)/B2_SCALE,cx=(startX+p2.x)/B2_SCALE,cy=(startY+p2.y)/B2_SCALE;
                    body.createFixture(pl.Polygon([pl.Vec2(ax,ay),pl.Vec2(bx,by),pl.Vec2(cx,cy)]));
                }
            }
            body.setActive(false);
            return body;
        }
        
        function renderPlayerStatsUI(){
            const barW=75,barH=8,x=16;let y=8;ctx.imageSmoothingEnabled=false;
            ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(x,y,barW,barH);const hpP=player.hp/player.maxHp;ctx.fillStyle='#d14242';ctx.fillRect(x,y,barW*hpP,barH);
            ctx.fillStyle='white';ctx.font='8px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(`${player.hp}/${player.maxHp}`,x+barW/2,y+barH/2);
            y+=barH+5;ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(x,y,barW,barH);const enP=player.hoverEnergy/player.maxHoverEnergy;ctx.fillStyle='#DDED64';ctx.fillRect(x,y,barW*enP,barH);
            ctx.fillStyle='white';ctx.font='8px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(`${Math.round(player.hoverEnergy)}/${player.maxHoverEnergy}`,x+barW/2,y+barH/2);
        }

        window.onload = function() {
            const loadingStatus = document.getElementById('loading-status');
            loadingStatus.innerText = 'Loading Physics Engine...';
            mainLoader();
        };
    </script>
</body>
</html>