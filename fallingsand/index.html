<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Sand Platformer</title>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            user-select: none;
            overflow: hidden;
        }
        h1 { margin-bottom: 10px; }
        .controls {
            margin-bottom: 10px;
            background: #333;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        .btn-sand { background-color: #f6d7b0; color: #333; }
        .btn-water { background-color: #4fa4f4; color: white; }
        .btn-soil { background-color: #5d4037; color: white; }
        .btn-wall { background-color: #888; color: white; }
        .btn-gas { background-color: #e0e0e0; color: #333; }
        .btn-fire { background-color: #ff4500; color: white; }
        .btn-oil {
            background-color: #5a4622;
            color: #fff;
        }
        .btn-coal {
            background-color: #111111;
            color: #fff;
        }
        .btn-wood { background-color: #8b4513; color: white; }
        .btn-gunpowder { background-color: #444; color: #fff; border: 1px solid #777; }
        .btn-acid { background-color: #00ff00; color: white; }
        .btn-glass { background-color: #e0e0ff; color: #333; }
        .btn-glass-wall { background-color: #b4b4e0; color: #333; }
        .btn-adamantium { background-color: #4d5257; color: white; border: 1px solid #aeb5be; }
        .btn-copper { background-color: #b87333; color: white; }
        .btn-silver { background-color: #c0c0c0; color: #333; }
        .btn-gold { background-color: #ffd700; color: #333; }
        .btn-platinum { background-color: #e5e4e2; color: #333; }
        .btn-rune-wall { background-color: #2a2a3a; color: #d0c0ff; border: 1px solid #5a4a7a; }
        .btn-eraser { background-color: #000; color: white; border: 1px solid #555; }
        button.active {
            outline: 2px solid white;
            box-shadow: 0 0 8px rgba(255,255,255,0.6);
        }
        .info-bar { font-size: 14px; color: #ccc; }
        .info-bar strong { color: white; }
        canvas {
            border: 2px solid #555;
            background-color: #000;
            cursor: crosshair;
            image-rendering: pixelated; 
        }
        #controls_ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 8px 10px;
            border-radius: 6px;
            pointer-events: none;
        }
    </style>
</head>
<body>
   <div id="loading-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a2a; color: #fff; z-index: 1000; display: flex; justify-content: center; align-items: center; flex-direction: column;">
        <h1 style="font-size: 2.5em; margin-bottom: 20px;">Falling Sand Platformer</h1>
        <p id="loading-status" style="font-size: 1.2em; font-family: monospace;">Initializing...</p>
    </div>

    <h1>Falling Sand Platformer</h1>
    <div class="info-bar">
        Use <strong>A/D</strong> to Move, <strong>W</strong> to Jump. Use the mouse to build and destroy.
    </div>

    <div class="controls">
        <button class="btn-sand active" onclick="setMaterial('sand')">Sand</button>
        <button class="btn-soil" onclick="setMaterial('soil')">Soil</button>
        <button class="btn-water" onclick="setMaterial('water')">Water</button>
        <button class="btn-gas" onclick="setMaterial('gas')">Gas</button>
        <button class="btn-wall" onclick="setMaterial('wall')">Wall</button>
        <button class="btn-wood" onclick="setMaterial('wood')">Wood</button>
        <button class="btn-fire" onclick="setMaterial('fire')">Fire</button>
        <button class="btn-gunpowder" onclick="setMaterial('gunpowder')">Gunpowder</button>
        <button class="btn-oil" onclick="setMaterial('oil')">Oil</button>
        <button class="btn-coal" onclick="setMaterial('coal')">Coal</button>
        <button class="btn-acid" onclick="setMaterial('acid')">Acid</button>
        <button class="btn-glass" onclick="setMaterial('glass')">Glass</button>
        <button class="btn-glass-wall" onclick="setMaterial('glass-wall')">Glass Wall</button>
        <button class="btn-adamantium" onclick="setMaterial('adamantium')">Adamantium</button>
        <button class="btn-copper" onclick="setMaterial('copper')">Copper</button>
        <button class="btn-silver" onclick="setMaterial('silver')">Silver</button>
        <button class="btn-gold" onclick="setMaterial('gold')">Gold</button>
        <button class="btn-platinum" onclick="setMaterial('platinum')">Platinum</button>
        <button class="btn-rune-wall" onclick="setMaterial('rune-wall')">Rune Wall</button>
        <button class="btn-eraser" onclick="setMaterial('empty')">Eraser</button>
    </div>

    <div id="controls_ui">
        <b>Controls</b><br>
        A / D – Move<br>
        W – Jump<br>
        Q – Switch Container<br>
        Left Click – Pour<br>
        Right Click – Store<br>
        Middle Click – Paint Brush
    </div>

    <canvas id="canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/earcut@2.2.4/dist/earcut.min.js"></script>
    <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>


    <script>
        // --- CONFIGURATION ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const pl = planck;

        const world = new pl.World({
            gravity: pl.Vec2(0, 10)
        });

        const B2_SCALE = 30; // 30 pixels = 1 meter in the physics world
        let rigidBodies = [];
        let staticWorldBodies = []; // To hold temporary terrain colliders
        let activeStaticChunks = new Set();
        let bodiesToDestroy = [];   // NEW: A "kill list" for entire b2Bodies
        let tempVec1 = null;
        let tempVec2 = null;

        const CHUNK_SIZE = 16; // Chunks will be 16x16 pixels
        let chunkWidth, chunkHeight;
        let chunkGrid; // This will hold state for each chunk
        let activeChunks = new Set(); // A set of active chunk indices for the current frame
        let nextActiveChunks = new Set(); // A set of chunks to activate for the *next* frame


        // NEW: Increased view area and reduced scale
        const viewWidth = 480;
        const viewHeight = 270;
        const scale = 3; // Smaller pixels

        const SIMULATION_STEPS_PER_FRAME = 2;

        // canvas.width = viewWidth * scale; // Same canvas size: 300*4 = 1200
        // canvas.height = viewHeight * scale; // Same canvas size: 200*4 = 800
        canvas.width = viewWidth;
        canvas.height = viewHeight;

        canvas.style.width = viewWidth * scale + "px";
        canvas.style.height = viewHeight * scale + "px";

        canvas.style.imageRendering = "pixelated";


        const worldWidth = 3000;
        const worldHeight = 10000;

        const renderWidth = viewWidth;
        const renderHeight = viewHeight;

        const imageData = ctx.createImageData(renderWidth, renderHeight);
        const pixels = imageData.data; // Uint8ClampedArray

        // --- MATERIAL DEFINITIONS ---
        const MAT = {
            EMPTY: 0, ROCK_WALL: 1, SAND: 2, WATER: 3, SOIL: 4, GAS: 5, 
            WOOD: 10, FIRE: 11, GUNPOWDER: 12, GUNPOWDER_IGNITED: 13,
            OIL: 14, OIL_BURNING: 15,
            COAL:16, COAL_BURNING:17,
            ACID:18, GLASS:19, GLASS_WALL: 20,
            ADAMANTIUM: 21, COPPER: 22, SILVER: 23, GOLD: 24, PLATINUM: 25, RUNE_WALL: 26,
            SANDSTONE_WALL: 27, VOLCANIC_WALL: 28, LABYRINTH_WALL: 29, MAGIC_WALL: 30,
            RIGID_BODY_STUB: 99
        };

        const COLORS = {
            [MAT.ROCK_WALL]: [100, 100, 100], [MAT.SAND]: [246, 215, 176],
            [MAT.WATER]: [79, 164, 244], [MAT.SOIL]: [93, 64, 55],
            [MAT.GAS]: [200, 200, 200], [MAT.WOOD]: [139, 69, 19],
            [MAT.FIRE]: [255, 69, 0], [MAT.GUNPOWDER]: [60, 60, 60],
            [MAT.GUNPOWDER_IGNITED]: [120, 80, 80], [MAT.OIL]: [90, 70, 30], [MAT.OIL_BURNING]: [255, 69, 0],
            [MAT.COAL]: [30, 30, 30], [MAT.COAL_BURNING]: [255, 69, 0],
            [MAT.ACID]: [0, 255, 0], [MAT.GLASS]: [200, 200, 255], [MAT.GLASS_WALL]: [180, 180, 235],
            [MAT.ADAMANTIUM]: [77, 82, 87], [MAT.COPPER]: [184, 115, 51],
            [MAT.SILVER]: [192, 192, 192], [MAT.GOLD]: [255, 215, 0],
            [MAT.PLATINUM]: [229, 228, 226], [MAT.RUNE_WALL]: [200, 200, 100],
            [MAT.SANDSTONE_WALL]: [130, 100, 70],
            [MAT.VOLCANIC_WALL]: [45, 20, 20],
            [MAT.LABYRINTH_WALL]: [70, 75, 80],
            [MAT.MAGIC_WALL]: [40, 25, 60]
        };

        const MATERIAL_NAME = {
            [MAT.EMPTY]: 'Empty',
            [MAT.ROCK_WALL]: 'Wall',
            [MAT.SAND]: 'Sand',
            [MAT.WATER]: 'Water',
            [MAT.SOIL]: 'Soil',
            [MAT.GAS]: 'Gas',
            [MAT.WOOD]: 'Wood',
            [MAT.FIRE]: 'Fire',
            [MAT.GUNPOWDER]: 'Gunpowder',
            [MAT.GUNPOWDER_IGNITED]: 'Gunpowder (Ignited)',
            [MAT.OIL]: 'Oil',
            [MAT.OIL_BURNING]: 'Burning Oil',
            [MAT.COAL]: 'Coal',
            [MAT.COAL_BURNING]: 'Burning Coal',
            [MAT.ACID]: 'Acid',
            [MAT.GLASS]: 'Glass',
            [MAT.GLASS_WALL]: 'Glass Wall',
            [MAT.ADAMANTIUM]: 'Adamantium', 
            [MAT.COPPER]: 'Copper',
            [MAT.SILVER]: 'Silver', 
            [MAT.GOLD]: 'Gold', 
            [MAT.PLATINUM]: 'Platinum',
            [MAT.RUNE_WALL]: 'Rune Wall',
            [MAT.SANDSTONE_WALL]: 'Sandstone Wall', 
            [MAT.VOLCANIC_WALL]: 'Volcanic Wall',
            [MAT.LABYRINTH_WALL]: 'Labyrinth Wall', 
            [MAT.MAGIC_WALL]: 'Magic Wall'
        };

        const WALL_TYPES = new Set([
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, 
            MAT.LABYRINTH_WALL, MAT.MAGIC_WALL
        ]);

        // --- RUNE DEFINITIONS ---
        // A library of rune patterns. 1 represents the rune material, 0 is empty.
        const DWARVEN_RUNES = {
            // A simple 7x9 pixel font for the runes
            RUNE_WIDTH: 7,
            RUNE_HEIGHT: 9,
            PATTERNS: [
                // "Axe"
                [
                    [0,1,1,1,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,0,1,1,0]
                ],
                // "Hammer"
                [
                    [1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0]
                ],
                // "Shield"
                [
                    [1,1,1,1,1,1,1],
                    [1,0,0,1,0,0,1],
                    [1,0,0,1,0,0,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1]
                ],
                // "Spear"
                [
                    [0,0,0,1,0,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,1,1,1,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ],
                // "Pickaxe"
                [
                    [1,1,0,0,0,1,1],
                    [0,1,1,0,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ]
            ]
        };


        const LIQUID_DENSITY = {
            [MAT.ACID]: 3,
            [MAT.WATER]: 2,
            [MAT.OIL]: 1,
            [MAT.OIL_BURNING]: 1
        };

        const ALWAYS_VISIBLE_MATERIALS = new Set([
            MAT.RUNE_WALL,
            MAT.ADAMANTIUM // Also used for the alchemy station and world borders
        ]);

        const SHIMMERING_METALS = new Set([
            MAT.ADAMANTIUM,
            MAT.COPPER,
            MAT.SILVER,
            MAT.GOLD,
            MAT.PLATINUM,
            MAT.RUNE_WALL
        ]);

        const STATIC_MATERIALS = new Set([
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, MAT.LABYRINTH_WALL, MAT.MAGIC_WALL, // All walls added
            MAT.WOOD,
            MAT.GLASS_WALL,
            MAT.ADAMANTIUM,
            MAT.RUNE_WALL
        ]);


        const MAX_STEP_HEIGHT = 2;
        const GRAVITY = 0.1;
        const MAX_FALL_SPEED = 4;
        const MAX_HOVER_SPEED = 4;

        const MAX_CHUNKS_PER_FRAME = 250;
        const REGEN_COOLDOWN = 250;
        const REBUILD_COOLDOWN = 250;
        const MIN_ISLAND_PIXELS = 5;
        let pendingActiveChunks = []; // An array to hold active chunks that were deferred from the previous frame.
        
        let grid = new Uint8Array(worldWidth * worldHeight).fill(MAT.EMPTY);
        let rigidBodyGrid = new Uint8Array(worldWidth * worldHeight);
        let ignitionTimer = new Uint8Array(worldWidth * worldHeight);
        let currentMaterial = MAT.SAND;
        let isDrawing = false;
        let isStoring = false;
        let frameCount = 0;
        let playerFacingRight = true;
		let projectiles = [];
        let alchemyJobs = [];

        let tSimMs = 0, tRenderMs = 0, tOtherMs = 0;


        let lightGrid = new Uint8Array(worldWidth * worldHeight).fill(0); // 0 = black, 15 = brightest
        const MAX_LIGHT_LEVEL = 30;
        const LIGHTING_UPDATE_INTERVAL = 30;
        const VISIBLE_LIQUID_SCAN_INTERVAL = 5; // Update lighting every 30 frames

        const MAX_VISIBLE_DISTANCE = 8;

        // --- Magic Particle System ---
        const MAX_MAGIC_PARTICLES = 5000;
        const magicParticlePool = [];
        for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
            magicParticlePool.push({ x: 0, y: 0, vx: 0, vy: 0, lifespan: 0, color: [0,0,0], active: false });
        }

        let magicEmitters = [];
        let nextEmitterId = 0;
        let firePixelsCoords = [];
        let triggers = [];
        let nextTriggerId = 0;
        let isAlchemyUIVisible = false;

        let lastFpsTime = performance.now();
        let framesThisSecond = 0;
        let fps = 0;
        let leftToRight = true;

        let hudFPS = 0;
        let hudMaterial = '--';
        let hudTimer = 0;

        let skyImageData = null;

        // --- INVENTORY AND CONTAINERS ---
        const pouchWidth = 32;
        const pouchHeight = 32;
        const flaskWidth = 24;
        const flaskHeight = 40;

        let pouchGrid = new Array(pouchWidth * pouchHeight).fill(MAT.EMPTY);
        let flaskGrid = new Array(flaskWidth * flaskHeight).fill(MAT.EMPTY);

        let activeContainer = 'pouch'; // 'pouch' or 'flask'
        let isPouring = false;
        let pourCooldown = 0;
        let pouredParticles = []; // For the pouring stream effect
        let activeStubs = [];

        const STORABLE_SOLIDS = new Set([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM]);
        const STORABLE_LIQUIDS = new Set([MAT.WATER, MAT.OIL, MAT.ACID]);

        let fluidsCanvas = null;
        let fluidsCtx = null;
        let fluidsImageData = null;
        let fluidsPixels = null;

        // Tune per material/category
        function fluidAlpha(type) {
            if (type === MAT.GAS) return 80;     // ~30%
            if (LIQUIDS.has(type)) return 140;   // ~55%
            return 255;
        }

        function isFluid(type) {
            return type === MAT.GAS || LIQUIDS.has(type);
        }


        function validatePolygon(points) {
            return;
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    const dx = points[i].x - points[j].x;
                    const dy = points[i].y - points[j].y;
                    const distSq = dx*dx + dy*dy;

                    // if (distSq < 0.0001) {
                    //     console.error("Duplicate or near-duplicate vertices:", i, j, points[i], points[j]);
                    // }
                }
            }
        }


        class RigidBody {
            constructor(x, y, width, height, material) {
                this.width = width;
                this.height = height;
                this.pixels = new Uint8Array(width * height);
                this.moved = new Uint8Array(width * height);
                this.materialType = material;
                this.fixtureCount = 0;
                
                this.isDestroyed = false;
                this.needsShapeUpdate = false;
                this.lastRebuildTime = 0;
                this.isSplit = false;

                this.pixels.fill(this.materialType);

                // --- Create the Box2D Body ---
                this.body = world.createBody({
                    type: 'dynamic',
                    position: pl.Vec2(x / B2_SCALE, y / B2_SCALE)
                });
                this.body.setUserData(this);
                
                // CORRECTED: Call the safe creation function, NOT rebuild.
                this._createFixturesFromPixels(); 
            }

            rebuildFixtures() {
                let f = this.body.getFixtureList();
                while (f) {
                    const next = f.getNext();
                    this.body.destroyFixture(f);
                    f = next;
                }

                // Now that the body is clean, call the helper to build the new fixtures and get the new count.
                this._createFixturesFromPixels();
                
                this.needsShapeUpdate = false;
            }

            getBinaryMask() {
                const mask = new Uint8Array(this.width * this.height);
                for (let i = 0; i < mask.length; i++) {
                    const t = this.pixels[i];
                    mask[i] = (t !== MAT.EMPTY && t !== MAT.GAS) ? 1 : 0;
                }
                return mask;
            }

            _createFixturesFromPixels() {

                this.fixtureCount = 0;

                const w = this.width;
                const h = this.height;

                const mask = new Uint8Array(w * h);

                // Build solidity mask
                for (let i = 0; i < mask.length; i++) {
                    const t = this.pixels[i];
                    mask[i] = (t !== MAT.EMPTY && t !== MAT.GAS) ? 1 : 0;
                }

                // If nothing solid remains → destroy body
                if (!mask.some(v => v === 1)) {
                    this.isDestroyed = true;
                    return;
                }

                const islands = extractIslands(mask, w, h);

                for (const island of islands) {

                    const outline = marchingSquares(island, w, h);
                    if (outline.length < 3) continue;

                    const preSimplified = simplifyDouglasPeucker(outline, 1.0);
                    if (preSimplified.length < 3) continue;

                    const simplified = removeCollinear(preSimplified, 0.01);
                    if (simplified.length < 3) continue;

                    validatePolygon(simplified);

                    // Flatten for earcut
                    const flat = [];
                    for (const p of simplified) {
                        flat.push(p.x, p.y);
                    }

                    const indices = earcut(flat);

                    for (let i = 0; i < indices.length; i += 3) {

                        const p0 = simplified[indices[i]];
                        const p1 = simplified[indices[i + 1]];
                        const p2 = simplified[indices[i + 2]];

                        // Convert to local body coordinates
                        const ax = (p0.x - w / 2) / B2_SCALE;
                        const ay = (p0.y - h / 2) / B2_SCALE;

                        const bx = (p1.x - w / 2) / B2_SCALE;
                        const by = (p1.y - h / 2) / B2_SCALE;

                        const cx = (p2.x - w / 2) / B2_SCALE;
                        const cy = (p2.y - h / 2) / B2_SCALE;

                        // ---- Skip degenerate triangles ----

                        const area = Math.abs(
                            ax * (by - cy) +
                            bx * (cy - ay) +
                            cx * (ay - by)
                        ) * 0.5;

                        if (area < 0.00001) continue;

                        // ---- Ensure CCW winding (Planck requirement) ----

                        const cross =
                            (bx - ax) * (cy - ay) -
                            (by - ay) * (cx - ax);

                        let verts;

                        if (cross < 0) {
                            // Reverse winding
                            verts = [
                                pl.Vec2(ax, ay),
                                pl.Vec2(cx, cy),
                                pl.Vec2(bx, by)
                            ];
                        } else {
                            verts = [
                                pl.Vec2(ax, ay),
                                pl.Vec2(bx, by),
                                pl.Vec2(cx, cy)
                            ];
                        }

                        try {
                            this.body.createFixture(
                                pl.Polygon(verts),
                                {
                                    density: 1.0,
                                    friction: 0.6,
                                    restitution: 0.1
                                }
                            );

                            this.fixtureCount++;
                        } catch (e) {
                            // If Planck rejects it, just skip triangle
                            continue;
                        }
                    }
                }

                this.body.resetMassData();
            }


            

        }

        function extractIslands(mask, w, h) {
            const visited = new Uint8Array(mask.length);
            const islands = [];

            const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {

                    const idx = y*w+x;
                    if (!mask[idx] || visited[idx]) continue;

                    const stack = [[x,y]];
                    const island = new Set();

                    visited[idx] = 1;

                    while (stack.length) {
                        const [cx, cy] = stack.pop();
                        island.add(cy*w+cx);

                        for (const [dx,dy] of dirs) {
                            const nx = cx+dx;
                            const ny = cy+dy;
                            if (nx<0||ny<0||nx>=w||ny>=h) continue;

                            const nIdx = ny*w+nx;
                            if (mask[nIdx] && !visited[nIdx]) {
                                visited[nIdx]=1;
                                stack.push([nx,ny]);
                            }
                        }
                    }

                    islands.push(island);
                }
            }

            return islands;
        }

        function marchingSquares(island, w, h) {

            const isSolid = (x, y) => {
                if (x < 0 || y < 0 || x >= w || y >= h) return false;
                return island.has(y * w + x);
            };

            // Find starting boundary pixel
            let start = null;
            for (const idx of island) {
                const x = idx % w;
                const y = Math.floor(idx / w);
                if (!isSolid(x - 1, y)) { // left edge exposed
                    start = { x, y };
                    break;
                }
            }

            if (!start) return [];

            const outline = [];
            let x = start.x;
            let y = start.y;
            let dir = 0; // 0=up,1=right,2=down,3=left

            const dirs = [
                [0, -1],
                [1, 0],
                [0, 1],
                [-1, 0]
            ];

            do {
                outline.push({ x: x + 0.5, y: y + 0.5 });

                // Check directions clockwise
                for (let i = 0; i < 4; i++) {
                    const ndir = (dir + 3 + i) % 4;
                    const nx = x + dirs[ndir][0];
                    const ny = y + dirs[ndir][1];

                    if (isSolid(nx, ny)) {
                        x = nx;
                        y = ny;
                        dir = ndir;
                        break;
                    }
                }

            } while (!(x === start.x && y === start.y));

            return outline;
        }

        function simplifyDouglasPeucker(points, epsilon) {
            if (points.length < 3) return points;

            const sqDist = (p, a, b) => {
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const t = ((p.x-a.x)*dx + (p.y-a.y)*dy)/(dx*dx+dy*dy);
                const proj = {x:a.x+t*dx,y:a.y+t*dy};
                return (p.x-proj.x)**2 + (p.y-proj.y)**2;
            };

            const simplify = (pts) => {
                let maxDist = 0;
                let index = 0;

                for (let i=1;i<pts.length-1;i++){
                    const d = sqDist(pts[i], pts[0], pts[pts.length-1]);
                    if (d>maxDist){maxDist=d;index=i;}
                }

                if (Math.sqrt(maxDist) > epsilon){
                    const left = simplify(pts.slice(0,index+1));
                    const right = simplify(pts.slice(index));
                    return left.slice(0,-1).concat(right);
                }

                return [pts[0], pts[pts.length-1]];
            };

            return simplify(points);
        }

        function removeCollinear(points, epsilon = 0.001) {
            const result = [];

            for (let i = 0; i < points.length; i++) {
                const prev = points[(i - 1 + points.length) % points.length];
                const curr = points[i];
                const next = points[(i + 1) % points.length];

                const ax = curr.x - prev.x;
                const ay = curr.y - prev.y;
                const bx = next.x - curr.x;
                const by = next.y - curr.y;

                const cross = ax * by - ay * bx;

                if (Math.abs(cross) > epsilon) {
                    result.push(curr);
                }
            }

            return result;
        }

        /**
         * Determines if a pixel type should be considered solid for the purpose of
         * checking structural connectivity. This should match the logic used for building physics fixtures.
         * @param {number} type - The material ID of the pixel.
         * @returns {boolean} True if the pixel is structural, false otherwise.
         */
        function isPixelSolidForConnectivity(type) {
            return type !== MAT.EMPTY && type !== MAT.GAS;
        }

        /**
         * Uses a flood-fill (BFS) algorithm to find all separate, contiguous "islands"
         * of solid pixels within a single rigid body's pixel grid. This version checks
         * 8 directions to correctly handle diagonal connections.
         * @param {Uint8Array} pixels - The body's internal pixel array.
         * @param {number} width - The width of the body's grid.
         * @param {number} height - The height of the body's grid.
         * @returns {Array<Array<{x: number, y: number}>>} An array of islands, where each island is an array of its pixel coordinates.
         */
        function findPixelIslands(pixels, width, height) {
            const islands = [];
            const visited = new Uint8Array(width * height);
            const getIdx = (x, y) => (y * width + x);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = getIdx(x, y);

                    // If this pixel is solid (using the new check) and we haven't visited it yet, we've found a new island.
                    if (isPixelSolidForConnectivity(pixels[idx]) && !visited[idx]) {
                        const newIsland = [];
                        const queue = [{ x, y }];
                        visited[idx] = 1;

                        while (queue.length > 0) {
                            const current = queue.shift();
                            newIsland.push(current);

                            // THE FIX: Check all 8 neighbors, including diagonals.
                            const neighbors = [
                                { dx: 0, dy: 1 }, { dx: 0, dy: -1 }, { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
                                { dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }, { dx: -1, dy: -1 }
                            ];
                            for (const n of neighbors) {
                                const nx = current.x + n.dx;
                                const ny = current.y + n.dy;

                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIdx = getIdx(nx, ny);
                                    // Also use the new check here.
                                    if (isPixelSolidForConnectivity(pixels[nIdx]) && !visited[nIdx]) {
                                        visited[nIdx] = 1;
                                        queue.push({ x: nx, y: ny });
                                    }
                                }
                            }
                        }
                        islands.push(newIsland);
                    }
                }
            }
            return islands;
        }

        function checkForSplits(body) {
            const islands = findPixelIslands(body.pixels, body.width, body.height);
            if (islands.length <= 1) return null;

            const MIN_ISLAND_PIXELS = 6;

            const validIslands = [];
            const smallIslands = [];

            for (const island of islands) {
                if (island.length >= MIN_ISLAND_PIXELS) validIslands.push(island);
                else smallIslands.push(island);
            }

            // If we don't have a real split, do nothing (and do NOT delete small bits here)
            if (validIslands.length <= 1) return null;

            // ✅ Remove tiny fragments from the old body's pixel grid so they don't hang around.
            for (const island of smallIslands) {
                for (const p of island) {
                    body.pixels[p.y * body.width + p.x] = MAT.EMPTY;
                }
            }

            const oldBody = body.body;

            const oldAngle = oldBody.getAngle();
            const oldLinVel = oldBody.getLinearVelocity();
            const oldAngVel = oldBody.getAngularVelocity();

            const newBodies = [];

            for (const island of validIslands) {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                for (const p of island) {
                    if (p.x < minX) minX = p.x;
                    if (p.y < minY) minY = p.y;
                    if (p.x > maxX) maxX = p.x;
                    if (p.y > maxY) maxY = p.y;
                }

                const newWidth = maxX - minX + 1;
                const newHeight = maxY - minY + 1;

                const localOriginX = (minX + newWidth / 2) - (body.width / 2);
                const localOriginY = (minY + newHeight / 2) - (body.height / 2);

                const worldOrigin = oldBody.getWorldPoint(
                    pl.Vec2(localOriginX / B2_SCALE, localOriginY / B2_SCALE)
                );

                const worldX = worldOrigin.x * B2_SCALE;
                const worldY = worldOrigin.y * B2_SCALE;

                const newPixels = new Uint8Array(newWidth * newHeight).fill(MAT.EMPTY);
                for (const p of island) {
                    const nx = p.x - minX;
                    const ny = p.y - minY;
                    newPixels[ny * newWidth + nx] = body.pixels[p.y * body.width + p.x];
                }

                const nb = new RigidBody(worldX, worldY, newWidth, newHeight, body.materialType);
                nb.pixels = newPixels;
                nb.rebuildFixtures();

                nb.body.setAngle(oldAngle);
                nb.body.setLinearVelocity(pl.Vec2(oldLinVel.x, oldLinVel.y));
                nb.body.setAngularVelocity(oldAngVel);

                nb.body.setAwake(false);

                newBodies.push(nb);
            }

            world.destroyBody(oldBody);
            body.body = null;
            body.isDestroyed = true;

            return newBodies;
        }



        function createChunkGrid() {
            chunkWidth = Math.ceil(worldWidth / CHUNK_SIZE);
            chunkHeight = Math.ceil(worldHeight / CHUNK_SIZE);
            chunkGrid = new Array(chunkWidth * chunkHeight);

            for (let i = 0; i < chunkGrid.length; i++) {
                chunkGrid[i] = { 
                    index: i,
                    staticBody: null,
                    dirty: true,
                    lastRegenTime: 0 // NEW: Track when the body was last rebuilt
                }; 
            }
        }

        /**
         * Scans the fully generated world and activates any chunks containing
         * dynamic materials that need to be simulated from frame one.
         * This must be called AFTER all terrain is generated.
         */
        function activateInitialChunks() {
            for (let y = 0; y < worldHeight; y++) {
                for (let x = 0; x < worldWidth; x++) {
                    const type = grid[getIdx(x, y)];
                    if (type !== MAT.EMPTY && !STATIC_MATERIALS.has(type)) {
                        activateChunkAt(x, y);
                    }
                }
            }
        }

        /**
         * Scans ONLY the area currently visible to the player to find liquid surfaces.
         * This is a highly efficient way to ensure that any on-screen liquids
         * remain active and flowing, preventing them from looking frozen.
         */
        function findAndActivateVisibleLiquidSurfaces() {
            const surfaceChunks = new Set();

            // Define the boundaries of the scan, clamped to the world edges.
            const startX = Math.floor(Math.max(0, camera.x));
            const startY = Math.floor(Math.max(0, camera.y));
            const endX = Math.floor(Math.min(worldWidth, camera.x + viewWidth));
            const endY = Math.floor(Math.min(worldHeight, camera.y + viewHeight));

            // Scan only the pixels within the camera's view.
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = getIdx(x, y);
                    const type = grid[idx];

                    if (isLiquid(type)) {
                        const aboveIdx = getIdx(x, y - 1);
                        // Check if the pixel above is empty space.
                        if (aboveIdx !== -1 && grid[aboveIdx] === MAT.EMPTY) {
                            // This is a surface pixel. Find and add its chunk.
                            const chunkX = Math.floor(x / CHUNK_SIZE);
                            const chunkY = Math.floor(y / CHUNK_SIZE);
                            surfaceChunks.add(chunkGrid[chunkY * chunkWidth + chunkX]);
                        }
                    }
                }
            }

            // Add all the unique chunks we found in the player's view to the simulation list.
            for (const chunk of surfaceChunks) {
                nextActiveChunks.add(chunk);
            }
        }

        function setGrid(idx, type) {
            if (idx === -1) return;

            const oldType = grid[idx];
            if (type === oldType) return;

            // --- THE CRITICAL OPTIMIZATION ---
            // Only mark the chunk as dirty if the "solidness" of the pixel changes.
            // This prevents sand moving over empty space from triggering an expensive physics rebuild.
            const wasSolid = isSolidForPlayer(oldType);
            const isSolid = isSolidForPlayer(type);

            if (wasSolid !== isSolid) {
                const x = idx % worldWidth;
                const y = Math.floor(idx / worldWidth);
                const chunkX = Math.floor(x / CHUNK_SIZE);
                const chunkY = Math.floor(y / CHUNK_SIZE);
                const chunkIndex = chunkY * chunkWidth + chunkX;
                if (chunkGrid[chunkIndex]) {
                    chunkGrid[chunkIndex].dirty = true;
                }
            }
            // --- END OPTIMIZATION ---

            grid[idx] = type;
            activateChunkAt(idx % worldWidth, Math.floor(idx / worldWidth));
        }

        /**
         * Activates the chunk at the given world coordinates, as well as its 8 neighbors.
         * This ensures interactions across chunk borders are always simulated.
         */
        function activateChunkAt(worldX, worldY) {
            const chunkX = Math.floor(worldX / CHUNK_SIZE);
            const chunkY = Math.floor(worldY / CHUNK_SIZE);

            // Activate the 3x3 grid of chunks around the target
            for (let cy = chunkY - 1; cy <= chunkY + 1; cy++) {
                for (let cx = chunkX - 1; cx <= chunkX + 1; cx++) {
                    if (cx >= 0 && cx < chunkWidth && cy >= 0 && cy < chunkHeight) {
                        const chunkIndex = cy * chunkWidth + cx;
                        nextActiveChunks.add(chunkGrid[chunkIndex]);
                    }
                }
            }
        }

        /**
         * A self-contained Perlin Noise generator object.
         * Based on the original implementation by Ken Perlin.
         */
        const PerlinNoise = {
            p: [],
            seed: function(s) {
                // Use a seeded PRNG to ensure the permutation table is the same for a given seed.
                let random = (function() {
                    let seed = s;
                    return function() {
                        seed = (seed * 9301 + 49297) % 233280;
                        return seed / 233280;
                    };
                })();
                
                this.p = new Uint8Array(512);
                let permutation = [];
                for (let i = 0; i < 256; i++) {
                    permutation.push(i);
                }
                // Shuffle permutation table
                for (let i = permutation.length - 1; i > 0; i--) {
                    const j = Math.floor(random() * (i + 1));
                    [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
                }
                // Duplicate the permutation table to avoid buffer overflows
                for (let i = 0; i < 256; i++) {
                    this.p[i] = this.p[i + 256] = permutation[i];
                }
            },
            fade: function(t) { return t * t * t * (t * (t * 6 - 15) + 10); },
            lerp: function(t, a, b) { return a + t * (b - a); },
            grad: function(hash, x, y, z) {
                let h = hash & 15;
                let u = h < 8 ? x : y,
                    v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            },
            noise: function(x, y, z = 0) {
                let X = Math.floor(x) & 255,
                    Y = Math.floor(y) & 255,
                    Z = Math.floor(z) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                let u = this.fade(x),
                    v = this.fade(y),
                    w = this.fade(z);
                let A = this.p[X] + Y, AA = this.p[A] + Z, AB = this.p[A + 1] + Z,
                    B = this.p[X + 1] + Y, BA = this.p[B] + Z, BB = this.p[B + 1] + Z;

                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z),
                                                              this.grad(this.p[BA], x - 1, y, z)),
                                                      this.lerp(u, this.grad(this.p[AB], x, y - 1, z),
                                                              this.grad(this.p[BB], x - 1, y - 1, z))),
                                       this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
                                                              this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                                                      this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),
                                                              this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));
            }
        };

        /**
         * Generates a high-quality, themed, and pixelated multi-layered cave background.
         * This version uses smaller (mostly 2x2) pixel blocks for a finer, more detailed aesthetic.
         */
        function generateCaveBackground(width, height) {
            const img = ctx.createImageData(width, height);
            const d = img.data;
            const layerHeight = height / 5;
            const transitionSize = 40;

            PerlinNoise.seed(1337);

            const hash = (x, y, s = 0) => {
                let h = x * 374761393 + y * 668265263 + s * 1442695041;
                h = (h ^ (h >> 13)) * 1274126177;
                return (h ^ (h >> 16)) & 255;
            };
            const lerp = (a, b, t) => a + (b - a) * t;
            const lerpColor = (c1, c2, t) => [lerp(c1[0], c2[0], t), lerp(c1[1], c2[1], t), lerp(c1[2], c2[2], t)];

            // --- RE-TUNED: Finer Pixel-Art Layer Generators ---

            const getSandCaveColor = (x, y) => {
                const px = x >> 1; const py = y >> 1; // Use 2x2 pixel blocks
                const n = (PerlinNoise.noise(px * 0.04, py * 0.1) + 1) / 2;
                
                if (n > 0.6) return [60, 45, 30];
                if (n > 0.4) return [50, 38, 25];
                return [40, 30, 20];
            };

            const getCoalMineColor = (x, y) => {
                const px = x >> 1; const py = y >> 1; // Use 2x2 pixel blocks
                const rockNoise = (PerlinNoise.noise(px * 0.1, py * 0.1) + 1) / 2;
                const seamNoise = PerlinNoise.noise(px * 0.02, py * 0.15);
                
                if (Math.pow(seamNoise, 2) > 0.3) return [5, 3, 3];
                
                if (rockNoise > 0.6) return [28, 25, 25];
                if (rockNoise > 0.45) return [20, 18, 18];
                return [12, 10, 10];
            };

            const getVolcanicColor = (x, y) => {
                const px = x >> 1; const py = y >> 1; // Keep 2x2 blocks
                const crackle = Math.abs(PerlinNoise.noise(px * 0.06, py * 0.06) * 2.5);

                if (crackle > 0.98) return [255, 170, 0];
                if (crackle > 0.95) return [255, 90, 0];
                
                const rockNoise = hash(px >> 1, py >> 1) / 255;
                if (rockNoise > 0.5) return [25, 10, 10];
                return [15, 5, 5];
            };

            const getLabyrinthColor = (x, y) => {
                const px = x >> 2; const py = y >> 2; // Use smaller 4x4 pixel bricks
                const isMortarX = x % 4 < 1;
                const isMortarY = y % 4 < 1;
                if(isMortarX || isMortarY) return [20, 22, 25];
                
                return hash(px, py) > 128 ? [55, 60, 65] : [45, 50, 55];
            };

            const getMagicDungeonColor = (x, y) => {
                const px = x >> 1; const py = y >> 1; // Use 2x2 pixel blocks
                const energy = (PerlinNoise.noise(px * 0.03, py * 0.03) + 1) / 2;
                
                const crystal = Math.abs(PerlinNoise.noise(px * 0.16, py * 0.16));
                if (Math.pow(crystal, 3) > 0.2) return [180, 150, 255];
                if (Math.pow(crystal, 2) > 0.25) return [100, 80, 140];
                
                if(hash(x,y) > 254) return [200, 200, 255];
                if(energy > 0.55) return [40, 15, 60];
                return [20, 5, 40];
            };
            
            const layerFunctions = [getSandCaveColor, getCoalMineColor, getVolcanicColor, getLabyrinthColor, getMagicDungeonColor];

            // Main Pixel Loop (This part remains the same)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const layerIndex = Math.min(layerFunctions.length - 1, Math.floor(y / layerHeight));
                    const yInLayer = y % layerHeight;
                    let color;
                    if (layerIndex > 0 && yInLayer < transitionSize) {
                        const t = yInLayer / transitionSize;
                        const color1 = layerFunctions[layerIndex - 1](x, y);
                        const color2 = layerFunctions[layerIndex](x, y);
                        color = lerpColor(color1, color2, t * t);
                    } else {
                        color = layerFunctions[layerIndex](x, y);
                    }
                    const i = (y * width + x) * 4;
                    d[i] = color[0]; d[i + 1] = color[1]; d[i + 2] = color[2]; d[i + 3] = 255;
                }
            }
            return img;
        }

        // --- PLAYER AND CAMERA ---
        const player = {
            x: 30, y: 80, vx: 0, vy: 0,
            width: 8, height: 16, speed: 1, onGround: false,
            body: null,
            canInteract: false,
            currentTrigger: null,
            maxHoverEnergy: 100,
            hoverEnergy: 100,
            hoverForce: 0.25,      // Upward force, must be > GRAVITY to ascend
            hoverDrainRate: 0.5,     // Energy used per frame of hovering
            hoverRechargeRate: 1, // Energy recovered per frame when not hovering
            maxHp: 100,
            hp: 100
        };
        const camera = { x: player.x - viewWidth / 2, y: 0 };
		const mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };
        
        // --- INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', (e) => {
            // If the UI is open, input is handled differently
            if (isAlchemyUIVisible) {
                if (e.code === 'Escape') {
                    isAlchemyUIVisible = false;
                }
                // Check if a number key was pressed
                if (e.code.startsWith('Digit')) {
                    const index = parseInt(e.code.replace('Digit', ''), 10) - 1;
                    const reactionKeys = Object.keys(ALCHEMY_REACTIONS);
                    if (index >= 0 && index < reactionKeys.length) {
                        const reactionKey = reactionKeys[index];
                        // Pass the station's geometry to the execute function
                        ALCHEMY_REACTIONS[reactionKey].execute(player.currentTrigger.associatedData.stationGeometry);
                        isAlchemyUIVisible = false; // Close UI after executing
                    }
                }
                return; // Stop further input processing
            }

            keys[e.code] = true;

            if (e.code === 'KeyQ') {
                activeContainer = activeContainer === 'pouch' ? 'flask' : 'pouch';
            }

            if (e.code === 'KeyE') {
                // Check if the player is currently in a trigger zone
                if (player.canInteract && player.currentTrigger) {
                    // Fire the specific trigger's onInteract function
                    player.currentTrigger.onInteract(player.currentTrigger);
                }
            }
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        /**
         * Creates a dynamic Planck body for the player with a composite shape
         * (box + circle) for better movement characteristics.
         */
        function createPlayerBody() {

            // Create dynamic body
            player.body = world.createBody({
                type: 'dynamic',
                position: pl.Vec2(player.x / B2_SCALE, player.y / B2_SCALE),
                fixedRotation: true,   // Prevent tipping
                linearDamping: 0.5     // Air/ground resistance
            });

            // --------------------------------------------------
            // 1. Torso Fixture (Rectangle)
            // --------------------------------------------------

            const halfWidth  = (player.width / 2 - 1) / B2_SCALE;
            const halfHeight = (player.height / 2 - 2) / B2_SCALE;

            player.body.createFixture(
                pl.Box(
                    halfWidth,
                    halfHeight,
                    pl.Vec2(0, -2 / B2_SCALE), // shift torso upward slightly
                    0
                ),
                {
                    density: 1.0,
                    friction: 0.3
                }
            );

            // --------------------------------------------------
            // 2. Foot Fixture (Circle)
            // --------------------------------------------------

            const footRadius = (player.width / 2 - 1) / B2_SCALE;

            player.body.createFixture(
                pl.Circle(
                    pl.Vec2(0, (player.height / 2 - 2) / B2_SCALE),
                    footRadius
                ),
                {
                    friction: 0.05 // very low friction for smooth sliding
                }
            );
        }


        function setMaterial(name) {
            const map = {
                sand: MAT.SAND, water: MAT.WATER, oil: MAT.OIL, coal: MAT.COAL,
                soil: MAT.SOIL, wall: MAT.ROCK_WALL, gas: MAT.GAS, wood: MAT.WOOD,
                fire: MAT.FIRE, gunpowder: MAT.GUNPOWDER, acid: MAT.ACID,
                glass: MAT.GLASS, 'glass-wall': MAT.GLASS_WALL, empty: MAT.EMPTY,
                adamantium: MAT.ADAMANTIUM, copper: MAT.COPPER, silver: MAT.SILVER,
                gold: MAT.GOLD, platinum: MAT.PLATINUM,
                'rune-wall': MAT.RUNE_WALL
            };

            if (map[name] === undefined) {
                console.warn('Unknown material:', name);
                return;
            }

            currentMaterial = map[name];

            document.querySelectorAll('.controls button')
                .forEach(btn => btn.classList.remove('active'));

            const btn = document.querySelector(`.btn-${name}`);
            if (btn) btn.classList.add('active');
        }

        function isFlammable(type) {
            return (
                type === MAT.WOOD ||
                type === MAT.GUNPOWDER ||
                type === MAT.OIL ||
                type === MAT.COAL
            );
        }

        const LIQUIDS = new Set([
            MAT.WATER,
            MAT.OIL,
            MAT.OIL_BURNING,
            MAT.ACID
        ]);

        function tryIgniteAt(x, y, probability = 1.0) {
            const idx = getIdx(x, y);
            if (idx === -1) return;

            const type = grid[idx];

            if (!isFlammable(type)) return;
            if (Math.random() > probability) return;

            switch (type) {
                case MAT.GUNPOWDER:
                    setGrid(idx, MAT.GUNPOWDER_IGNITED);
                    ignitionTimer[idx] = 3 + Math.floor(Math.random() * 5);
                    break;

                case MAT.OIL:
                    setGrid(idx, MAT.OIL_BURNING);
                    break;

                case MAT.COAL:
                    setGrid(idx, MAT.COAL_BURNING);
                    break;

                case MAT.WOOD:
                    setGrid(idx, MAT.FIRE);
                    break;
            }
        }


        const getMousePos = (evt) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = evt.clientX - rect.left;
            mouse.y = evt.clientY - rect.top;
        };

        function draw(x, y) {
            const brushSize = 10; // Scaled brush size
            const r = Math.floor(brushSize / 2);
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (dx*dx + dy*dy <= r*r) {
                        const px = x + dx; const py = y + dy;
                        const idx = getIdx(px, py);
                        if (idx !== -1) {
                            setGrid(idx, currentMaterial);
                            activateChunkAt(px, py);
                        }
                    }
                }
            }
        }
        canvas.addEventListener('mousemove', getMousePos);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { isPouring = true; } // Left-click to pour
            else if (e.button === 1) { isDrawing = true; draw(mouse.worldX, mouse.worldY); e.preventDefault(); } // Middle-click to draw
            else if (e.button === 2) { 
                isStoring = true; // Set storing state to true
                storeMaterial(mouse.worldX, mouse.worldY); // Store immediately on click
            } 
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) isPouring = false;
            if (e.button === 1) isDrawing = false;
            if (e.button === 2) isStoring = false; // Set storing state to false
        });

        canvas.addEventListener('mousemove', (e) => {
             if (isDrawing) draw(mouse.worldX, mouse.worldY);
        });

        // --- CORE PHYSICS ENGINE ---
        const getIdx = (x, y, w = worldWidth, h = worldHeight) => {
            x = Math.floor(x);
            y = Math.floor(y);
            if (x < 0 || x >= w || y < 0 || y >= h) return -1;
            return y * w + x;
        };

        const isSolidForPlayer = (type) => [
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, MAT.LABYRINTH_WALL, MAT.MAGIC_WALL, // All walls added
            MAT.SOIL, MAT.WOOD, MAT.SAND, 
            MAT.GUNPOWDER, MAT.COAL, MAT.COAL_BURNING, MAT.GLASS, 
            MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.COPPER, MAT.SILVER, 
            MAT.GOLD, MAT.PLATINUM, MAT.RUNE_WALL
        ].includes(type);

        function collidesAt(x, y) {
            for (let iy = 0; iy < player.height; iy++) {
                for (let ix = 0; ix < player.width; ix++) {
                    const idx = getIdx(Math.floor(x + ix), Math.floor(y + iy));
                    if (idx !== -1 && isSolidForPlayer(grid[idx])) {
                        return true;
                    }
                }
            }
            return false;
        }

        function collidesAtSides(x, y, dir) {
            const edgeX = dir > 0
                ? Math.floor(x + player.width - 1) // right edge
                : Math.floor(x);                   // left edge

            for (let iy = 0; iy < player.height - 1; iy++) { // ignore feet
                const idx = getIdx(edgeX, Math.floor(y + iy));
                if (idx !== -1 && isSolidForPlayer(grid[idx])) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Stamps a "no-go" zone onto the rigidBodyGrid for terrain generation.
         * Planck.js version.
         */
        function updateRigidBodyGrid() {

            // 1️⃣ Clear previous frame
            rigidBodyGrid.fill(0);

            const buffer = 1; // safety buffer in pixels

            // 2️⃣ Iterate dynamic bodies
            for (const body of rigidBodies) {

                if (body.isDestroyed) continue;

                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {

                        if (body.pixels[y * body.width + x] === MAT.EMPTY) continue;

                        // Convert local pixel → world position (Planck)
                        const localPos = pl.Vec2(
                            (x - body.width / 2 + 0.5) / B2_SCALE,
                            (y - body.height / 2 + 0.5) / B2_SCALE
                        );

                        const worldPos = body.body.getWorldPoint(localPos);

                        const worldX = Math.floor(worldPos.x * B2_SCALE);
                        const worldY = Math.floor(worldPos.y * B2_SCALE);

                        // 3️⃣ Stamp buffer zone
                        for (let dy = -buffer; dy <= buffer; dy++) {
                            for (let dx = -buffer; dx <= buffer; dx++) {

                                const stampX = worldX + dx;
                                const stampY = worldY + dy;

                                const stampIdx = getIdx(stampX, stampY);

                                if (stampIdx !== -1) {
                                    rigidBodyGrid[stampIdx] = 1;

                                    // Optional sand displacement:
                                    // if (grid[stampIdx] !== MAT.EMPTY) {
                                    //     setGrid(stampIdx, MAT.EMPTY);
                                    // }
                                }
                            }
                        }
                    }
                }
            }
        }


        

        function updatePlayer() {

            if (isAlchemyUIVisible) {
                player.body.setLinearVelocity(pl.Vec2(0, 0));
                return;
            }

            const currentVel = player.body.getLinearVelocity();
            let targetVelX = 0;

            // --------------------------------------------------
            // 1. Horizontal Movement
            // --------------------------------------------------

            if (keys['KeyA']) {
                targetVelX = -player.speed * 2.5;
                playerFacingRight = false;
            }
            else if (keys['KeyD']) {
                targetVelX = player.speed * 2.5;
                playerFacingRight = true;
            }

            // --------------------------------------------------
            // 2. Ground Check (simple velocity check)
            // --------------------------------------------------

            player.onGround = Math.abs(currentVel.y) < 0.1;

            // --------------------------------------------------
            // 3. Hover / Jump
            // --------------------------------------------------

            let newVelY = currentVel.y;

            if (keys['KeyW'] && player.hoverEnergy > 0) {
                newVelY = -MAX_HOVER_SPEED;
                player.hoverEnergy = Math.max(0, player.hoverEnergy - player.hoverDrainRate);
                spawnLevitationParticles(2);
            }

            // --------------------------------------------------
            // 4. Recharge Energy
            // --------------------------------------------------

            if (player.onGround && !keys['KeyW']) {
                player.hoverEnergy = Math.min(
                    player.maxHoverEnergy,
                    player.hoverEnergy + player.hoverRechargeRate
                );
            }

            // --------------------------------------------------
            // 5. Apply Velocity
            // --------------------------------------------------

            player.body.setLinearVelocity(
                pl.Vec2(targetVelX, newVelY)
            );
        }


        /**
         * Reads the position from the player's b2Body and updates the
         * graphical player object to match.
         */
        function syncPlayerWithBody() {
            const pos = player.body.getPosition();
            // The position is the center of the body, so we offset by half size to get top-left
            player.x = (pos.x * B2_SCALE) - (player.width / 2);
            player.y = (pos.y * B2_SCALE) - (player.height / 2);
        }

        /**
         * Scans a 3x3 area in the world and teleports valid materials into the correct container.
         */
        function storeMaterial(worldX, worldY) {
            const storeRadius = 1; // Creates a 3x3 area
            for (let dy = -storeRadius; dy <= storeRadius; dy++) {
                for (let dx = -storeRadius; dx <= storeRadius; dx++) {
                    const wx = worldX + dx;
                    const wy = worldY + dy;
                    const worldIdx = getIdx(wx, wy, worldWidth, worldHeight);
                    if (worldIdx === -1) continue;

                    const type = grid[worldIdx];
                    let targetGrid, targetW, targetH;

                    if (STORABLE_SOLIDS.has(type)) {
                        targetGrid = pouchGrid; targetW = pouchWidth; targetH = pouchHeight;
                    } else if (STORABLE_LIQUIDS.has(type)) {
                        targetGrid = flaskGrid; targetW = flaskWidth; targetH = flaskHeight;
                    } else {
                        continue; // Can't store this type
                    }

                    // NEW: Scan from the top of the container downwards, across the full width, to find an empty spot.
                    let spotFound = false;
                    for (let y = 0; y < targetH; y++) {
                        // Start scanning at a random x-offset each time to prevent filling bias on one side.
                        const xOffset = Math.floor(Math.random() * targetW);
                        for (let i = 0; i < targetW; i++) {
                            const x = (i + xOffset) % targetW; // Loop through all x-coordinates
                            
                            const containerIdx = getIdx(x, y, targetW, targetH);
                            if (containerIdx !== -1 && targetGrid[containerIdx] === MAT.EMPTY) {
                                targetGrid[containerIdx] = type; // Place material
                                setGrid(worldIdx, MAT.EMPTY);      // Remove from world
                                spotFound = true;
                                break; // Exit inner x-loop
                            }
                        }
                        if (spotFound) {
                            break; // Exit outer y-loop
                        }
                    }
                }
            }
        }

        /**
         * Takes one particle from the bottom of the active container and adds it to the pouredParticles array.
         */
        function pourFromContainer() {
            const [containerGrid, containerW, containerH] = activeContainer === 'pouch'
                ? [pouchGrid, pouchWidth, pouchHeight]
                : [flaskGrid, flaskWidth, flaskHeight];

            // NEW: Variables to control how many particles are poured each frame
            const maxPourPerFrame = 3; 
            let pouredCount = 0;

            // Find particles at the bottom to pour
            for (let y = containerH - 1; y >= 0; y--) {
                for (let i = 0; i < containerW; i++) {
                    // Scan from the center outwards
                    const x = Math.floor(containerW / 2) + (i % 2 === 0 ? 1 : -1) * Math.floor(i / 2);
                    const idx = getIdx(x, y, containerW, containerH);
                    const type = containerGrid[idx];

                    if (type !== MAT.EMPTY && type !== MAT.GAS) { // Cannot pour gas
                        containerGrid[idx] = MAT.EMPTY; // Remove from container

                        // --- Start of Noita-style Variance Logic ---

                        // 1. Add variance to spawn position
                        const baseSpawnX = player.x + (playerFacingRight ? player.width : 0);
                        const baseSpawnY = player.y + 9;
                        const spawnOffsetX = (Math.random() - 0.5) * 2; 
                        const spawnOffsetY = (Math.random() - 0.5) * 2; 
                        const finalSpawnX = baseSpawnX + spawnOffsetX;
                        const finalSpawnY = baseSpawnY + spawnOffsetY;

                        // 2. Add variance to the angle (spread)
                        const baseAngle = Math.atan2(mouse.worldY - finalSpawnY, mouse.worldX - finalSpawnX);
                        const spread = 0.05; // CHANGED: Reduced from 0.25 to make the stream tighter
                        const finalAngle = baseAngle + (Math.random() - 0.5) * spread;

                        // 3. Add variance to the velocity
                        const baseVelocity = 4.0;
                        const velocityVariance = 0.5;
                        const finalVelocity = baseVelocity + (Math.random() - 0.5) * velocityVariance;

                        // --- End of Noita-style Variance Logic ---

                        pouredParticles.push({
                            x: finalSpawnX, 
                            y: finalSpawnY,
                            vx: Math.cos(finalAngle) * finalVelocity,
                            vy: Math.sin(finalAngle) * finalVelocity,
                            type: type
                        });
                        
                        pouredCount++;
                        if (pouredCount >= maxPourPerFrame) {
                           return; // Exit after pouring the max number of particles
                        }
                    }
                }
            }
        }

        function isRigidBodyAtPixel(worldX, worldY) {
            // Build a tiny AABB around the pixel center in physics units
            const pMin = pl.Vec2((worldX - 0.5) / B2_SCALE, (worldY - 0.5) / B2_SCALE);
            const pMax = pl.Vec2((worldX + 0.5) / B2_SCALE, (worldY + 0.5) / B2_SCALE);
            const aabb = new pl.AABB(pMin, pMax);

            let hit = false;

            world.queryAABB(aabb, (fixture) => {
                const body = fixture.getBody();
                const ud = body.getUserData();

                // Your rigid bodies set userData to the RigidBody instance :contentReference[oaicite:1]{index=1}
                if (ud && ud.pixels && ud.width && ud.height) {
                    hit = true;
                    return false; // stop query early
                }
                return true;
            });

            return hit;
        }


        /**
         * Updates the position and state of all particles currently being poured.
         */
        function updatePouredParticles() {
            pouredParticles = pouredParticles.filter(p => {
                // Apply gravity
                p.vy += GRAVITY * 0.5;

                // 1. Calculate the particle's potential next position
                const nextX = p.x + p.vx;
                const nextY = p.y + p.vy;
                const nextIX = Math.floor(nextX);
                const nextIY = Math.floor(nextY);

                const worldIdx = getIdx(nextIX, nextIY);
                
                // Check if the particle is about to go off-screen
                if (worldIdx === -1) {
                    return false; // Remove if it leaves the world
                }
                
                // 2. Check for an obstruction at that future position
                const gridBlocked = grid[worldIdx] !== MAT.EMPTY && grid[worldIdx] !== MAT.GAS;
                const rigidBlocked = isRigidBodyAtPixel(nextIX, nextIY);
                const isObstructed = gridBlocked || rigidBlocked;

                const hasStopped = (p.vx * p.vx + p.vy * p.vy < 1.0);

                // 3. If a collision is predicted OR the particle has stopped, materialize it
                if (isObstructed || hasStopped) {
                    // THE FIX: Start the search from the particle's CURRENT, known-good position, not the invalid future one.
                    let placeX = Math.floor(p.x);
                    let placeY = Math.floor(p.y);
                    
                    // The upward search is still useful for stacking, but now starts from a safe location.
                    while (true) {
                        const checkIdx = getIdx(placeX, placeY);
                        
                        // Stop if we search off the top of the map
                        if (checkIdx === -1) {
                            break; 
                        }

                        // If we find an empty spot, place the material and we're done.
                        if (grid[checkIdx] === MAT.EMPTY || grid[checkIdx] === MAT.GAS) {
                            setGrid(checkIdx, p.type);
                            activateChunkAt(placeX, placeY);
                            break;
                        }
                        
                        // If the spot was taken, move up one pixel and try again.
                        placeY--;
                    }
                    
                    // The particle's journey is over. Remove it.
                    return false;
                } else {
                    // 4. If no collision is predicted, update the particle's position and keep it alive.
                    p.x = nextX;
                    p.y = nextY;
                    return true; 
                }
            });
        }

        function shootFire() {
            const projectileSpeed = 1.0; 
            
            // Calculate wand tip position in world coordinates for the larger sprite
            const wandTipX = player.x + (playerFacingRight ? player.width + 2 : -4);
            const wandTipY = player.y + 9; // Centered on the new wand vertically

            const angle = Math.atan2(mouse.worldY - wandTipY, mouse.worldX - wandTipX);
            projectiles.push({
                x: wandTipX, y: wandTipY,
                vx: Math.cos(angle) * projectileSpeed, vy: Math.sin(angle) * projectileSpeed
            });
        }
		
		function updateProjectiles() {
            projectiles = projectiles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                const idx = getIdx(p.x, p.y);
                if (idx === -1) return false; 
                if (grid[idx] !== MAT.EMPTY) {
                    setGrid(idx, MAT.FIRE); return false;
                }
                return true;
            });
        }

        const movedWorld = new Uint8Array(worldWidth * worldHeight);
        const movedPouch = new Uint8Array(pouchWidth * pouchHeight);
        const movedFlask = new Uint8Array(flaskWidth * flaskHeight);
        
        /**
         * Runs the simulation on the main world grid using the active chunk optimization.
         */
        function runWorldSimulationWithChunks(moved) {
            moved.fill(0);
            const localGetIdx = (x, y) => getIdx(x, y, worldWidth, worldHeight);
            const scanDir = (frameCount % 2 === 0);
            
            // For the main world, the "setter" is the original setGrid function.
            const setter = setGrid; 

            for (const chunk of activeChunks) {
                const chunkX = chunk.index % chunkWidth;
                const chunkY = Math.floor(chunk.index / chunkWidth);
                const startX = chunkX * CHUNK_SIZE;
                const startY = chunkY * CHUNK_SIZE;
                const endX = startX + CHUNK_SIZE;
                const endY = startY + CHUNK_SIZE;

                // PASS 1: solids, gas, fire
                for (let y = endY - 1; y >= startY; y--) {
                    for (let x = (scanDir ? startX : endX - 1); (scanDir ? x < endX : x >= startX); x += (scanDir ? 1 : -1)) {
                        stepNonLiquid(x, y, moved, grid, worldWidth, worldHeight, localGetIdx, setter);
                    }
                }

                // PASS 2: liquids
                for (let y = endY - 1; y >= startY; y--) {
                    for (let x = (scanDir ? startX : endX - 1); (scanDir ? x < endX : x >= startX); x += (scanDir ? 1 : -1)) {
                        stepLiquid(x, y, moved, grid, worldWidth, worldHeight, localGetIdx, setter);
                    }
                }
            }
        }

        function runSimulationOnSmallGrid(moved, currentGrid, gridWidth, gridHeight, setter) {
             moved.fill(0);
             const localGetIdx = (x, y) => getIdx(x, y, gridWidth, gridHeight);
             const scanDir = (frameCount % 2 === 0);

            // PASS 1: solids, gas, fire
            for (let y = gridHeight - 1; y >= 0; y--) {
                 for (let x = (scanDir ? 0 : gridWidth - 1); (scanDir ? x < gridWidth : x >= 0); x += (scanDir ? 1 : -1)) {
                    stepNonLiquid(x, y, moved, currentGrid, gridWidth, gridHeight, localGetIdx, setter);
                }
            }

            // PASS 2: liquids
            for (let y = gridHeight - 1; y >= 0; y--) {
                 for (let x = (scanDir ? 0 : gridWidth - 1); (scanDir ? x < gridWidth : x >= 0); x += (scanDir ? 1 : -1)) {
                    stepLiquid(x, y, moved, currentGrid, gridWidth, gridHeight, localGetIdx, setter);
                }
            }
        }

        function stepAll(x, y, moved) {
            const idx = getIdx(x, y);
            if (idx === -1 || moved[idx]) return;

            const type = grid[idx];
            if ([MAT.EMPTY, MAT.ROCK_WALL, MAT.WOOD].includes(type)) return;
            if (type === MAT.WATER) updateLiquid(x, y, idx, moved);
            if (type === MAT.FIRE) updateFire(x, y, idx, moved);
            else if ([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER].includes(type))
                updateSolid(x, y, idx, type, moved);
            else if (type === MAT.GAS) updateGas(x, y, idx, moved);
            else if (type >= 20) updateSource(x, y, idx, type);
        }

        function stepNonLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const idx = getIdx(x, y); 
            if (idx === -1 || moved[idx]) return;
            const type = grid[idx];
            if (WALL_TYPES.has(type) || [MAT.EMPTY, MAT.WOOD, MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.RUNE_WALL, MAT.RIGID_BODY_STUB].includes(type) || LIQUIDS.has(type)) return;

            if (type === MAT.FIRE) updateFire(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if ([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.COAL_BURNING, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM].includes(type)) updateSolid(x, y, idx, type, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.COAL_BURNING) updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.GAS) updateGas(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.GUNPOWDER_IGNITED) updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter);
        }

        function stepLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const idx = getIdx(x, y, w, h);
            if (idx === -1 || moved[idx]) return;
            if (![MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.ACID].includes(grid[idx])) return;

            updateLiquid(x, y, idx, moved, grid, w, h, getIdx, setter);
        }


        function updateCamera() {
            // Follow player on X-axis
            const targetCamX = player.x - viewWidth / 2;
            camera.x += (targetCamX - camera.x) * 0.1;

            // Follow player on Y-axis
            const targetCamY = player.y - viewHeight / 2;
            camera.y += (targetCamY - camera.y) * 0.1;

            // Clamp camera to world bounds
            if (camera.x < 0) camera.x = 0;
            if (camera.x > worldWidth - viewWidth) camera.x = worldWidth - viewWidth;
            if (camera.y < 0) camera.y = 0;
            if (camera.y > worldHeight - viewHeight) camera.y = worldHeight - viewHeight;
        }

        function updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter) {
            ignitionTimer[idx]--;

            for (let n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                const nIdx = getIdx(x + n.x, y + n.y);
                if (Math.random() < 0.35) {
                    if (nIdx !== -1 && grid[nIdx] === MAT.GUNPOWDER) {
                        setter(nIdx, MAT.GUNPOWDER_IGNITED);
                        ignitionTimer[nIdx] = 8 + Math.floor(Math.random() * 6);
                    }
                }
            }

            if (ignitionTimer[idx] <= 0) {
                setter(idx, MAT.EMPTY);
                // Explosions only happen in the main world, so we can still call setGrid here.
                if (setter === setGrid) triggerExplosion(x, y, 6);
            }
        }

        function triggerExplosion(centerX, centerY, radius) {
            const maxRadius = 100; // Scaled max radius
            if (radius > maxRadius) radius = maxRadius;
            const rSquared = radius * radius;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx*dx + dy*dy > rSquared) continue;
                    const ex = Math.floor(centerX + dx);
                    const ey = Math.floor(centerY + dy);
                    const idx = getIdx(ex, ey);
                    if (idx === -1 || ex === 0 || ex === worldWidth - 1 || ey === 0 || ey === worldHeight - 1) continue;
                    
                    if (!WALL_TYPES.has(grid[idx]) && grid[idx] !== MAT.ADAMANTIUM) {
                        const rand = Math.random();
                        if (rand < 0.3) setGrid(idx, MAT.FIRE);
                        else if (rand < 0.7) setGrid(idx, MAT.GAS); 
                        else setGrid(idx, MAT.EMPTY);
                    } else if (radius > 20 && Math.random() < 0.5) { // Scaled check
                        setGrid(idx, MAT.GAS);
                    }
                }
            }
        }

        function explodeCluster(startX, startY) {
            let queue = [{x: startX, y: startY}];
            let cluster = [{x: startX, y: startY}]; 
            let visited = new Set([`${startX},${startY}`]);
            setGrid(getIdx(startX, startY), MAT.EMPTY);
            let iterations = 0; const maxIterations = 3000;
            while (queue.length > 0 && iterations++ < maxIterations) {
                let current = queue.shift();
                for (let d of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                    const nx = current.x + d.x, ny = current.y + d.y;
                    const key = `${nx},${ny}`;
                    const nIdx = getIdx(nx, ny);
                    if (nIdx !== -1 && !visited.has(key) && grid[nIdx] === MAT.GUNPOWDER) {
                        visited.add(key); queue.push({x: nx, y: ny});
                        cluster.push({x: nx, y: ny}); setGrid(nIdx, MAT.EMPTY);
                    }
                }
            }
            let sumX = 0, sumY = 0;
            for (let p of cluster) { sumX += p.x; sumY += p.y; }
            triggerExplosion(sumX / cluster.length, sumY / cluster.length, 5 + Math.sqrt(cluster.length));
        }

        function updateFire(x, y, idx, moved, grid, w, h, getIdx, setter) {
            let nearbyFuel = false;
            for (let n of [{x:0,y:1},{x:0,y:1},{x:-1,y:0},{x:1,y:0},{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}]) {
                const nx = x + n.x, ny = y + n.y;
                const nIdx = getIdx(nx, ny);
                if (nIdx === -1) continue;
                const nType = grid[nIdx];

                if (nType === MAT.SAND && Math.random() < 0.05) setter(nIdx, MAT.GLASS);
                if (nType === MAT.GUNPOWDER && Math.random() < 0.5) {
                    setter(nIdx, MAT.GUNPOWDER_IGNITED);
                    ignitionTimer[nIdx] = 8 + Math.floor(Math.random() * 6);
                    return;
                }
                if (nType === MAT.OIL) { setter(nIdx, MAT.OIL_BURNING); return; }
                if (nType === MAT.COAL) { setter(nIdx, MAT.COAL_BURNING); return; }
                if (nType === MAT.WOOD) {
                    nearbyFuel = true;
                    if (Math.random() < 0.02) { setter(nIdx, MAT.FIRE); moved[nIdx] = 1; }
                }
                if (nType === MAT.WATER) { setter(nIdx, MAT.GAS); setter(idx, MAT.GAS); return; }
            }
            let targetIdx = idx;
            if (!nearbyFuel && y > 0) {
                let nextX = x, nextY = y - 1;
                if (Math.random() < 0.5) nextX += Math.random() < 0.5 ? -1 : 1;
                const nextIdx = getIdx(nextX, nextY);
                if (nextIdx !== -1 && (grid[nextIdx] === MAT.EMPTY || grid[nextIdx] === MAT.GAS)) {
                    setter(idx, grid[nextIdx]); setter(nextIdx, MAT.FIRE);
                    moved[nextIdx] = 1; targetIdx = nextIdx;
                }
            }
            if (Math.random() < (nearbyFuel ? 0.0 : 0.15))
            {
                if (Math.random() < 0.15) {
                    setter(targetIdx, MAT.GAS);
                } else {
                    setter(targetIdx, MAT.EMPTY);
                }
            } 
                
        }

        function updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter) {
            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                const nx = x + n.x, ny = y + n.y;
                const nIdx = getIdx(nx, ny);
                if (nIdx === -1) continue;
                if (grid[nIdx] === MAT.SAND && Math.random() < 0.08) setter(nIdx, MAT.GLASS);
                // tryIgniteAt is world-only, so we check the setter
                if (setter === setGrid) tryIgniteAt(nx, ny, 0.02);
            }
            if (Math.random() < 0.02) {
                const aboveIdx = getIdx(x, y - 1);
                if (aboveIdx !== -1 && grid[aboveIdx] === MAT.EMPTY) setter(aboveIdx, MAT.FIRE);
            }
            if (Math.random() < 0.003)
            {
                setter(idx, Math.random() < 0.15 ? MAT.GAS : MAT.EMPTY);
            } 
            if (grid[idx] === MAT.COAL_BURNING && setter === setGrid) activateChunkAt(x, y);
        }
        
        function updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter) {
            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0},{x:1,y:1},{x:-1,y:1},{x:1,y:-1},{x:-1,y:-1}]) {
                const nx = x + n.x, ny = y + n.y;
                const nIdx = getIdx(nx, ny);
                if (nIdx === -1) continue;
                if (grid[nIdx] === MAT.SAND && Math.random() < 0.1) setter(nIdx, MAT.GLASS);
                if (setter === setGrid) tryIgniteAt(nx, ny, 0.05);
            }
            if (Math.random() < 0.05) {
                const aboveIdx = getIdx(x, y - 1);
                if (aboveIdx !== -1 && grid[aboveIdx] === MAT.EMPTY) setter(aboveIdx, MAT.FIRE);
            }
            if (Math.random() < 0.008){
                setter(idx, Math.random() < 0.15 ? MAT.GAS : MAT.EMPTY);
            } 
            if (grid[idx] === MAT.OIL_BURNING && setter === setGrid) activateChunkAt(x, y);
        }

        function updateSolid(x, y, idx, type, moved, grid, w, h, getIdx, setter) {
            const belowIdx = getIdx(x, y + 1);
            if (belowIdx === -1) return;

            // Handle special material interactions (like coal burning)
            if (type === MAT.COAL_BURNING) {updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter)}
            if (grid[belowIdx] === MAT.FIRE && type === MAT.COAL) {
                setter(idx, MAT.COAL_BURNING);
                return;
            }

            // --- THE CRITICAL COLLISION CHECK ---
            // First, check if the space directly below is occupied by a rigid body.
            if (rigidBodyGrid[belowIdx] !== 1) {
                // If NOT blocked by a body, then check the main grid for other materials.
                const belowType = grid[belowIdx];
                if ([MAT.EMPTY, MAT.GAS].includes(belowType) || isLiquid(belowType)) {
                    setter(idx, belowType); // Swap with whatever is below (liquid, gas, or empty)
                    setter(belowIdx, type);
                    moved[belowIdx] = 1;
                    return;
                }
            }

            // If directly below is blocked (by a body OR other solids), try moving diagonally.
            const dir = Math.random() < 0.5 ? -1 : 1;
            for (let dx of [dir, -dir]) {
                const dIdx = getIdx(x + dx, y + 1);
                // Check if the diagonal space is valid AND not occupied by a rigid body.
                if (dIdx !== -1 && rigidBodyGrid[dIdx] !== 1) {
                    const diagType = grid[dIdx];
                    if ([MAT.EMPTY, MAT.GAS].includes(diagType) || isLiquid(diagType)) {
                        setter(idx, diagType);
                        setter(dIdx, type);
                        moved[dIdx] = 1;
                        return;
                    }
                }
            }
        }

        function isLiquid (type) {
            return LIQUIDS.has(type);
        }

        function updateLiquid(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const type = grid[idx];

            // Acid logic remains the same
            if (type === MAT.ACID) {
                let consumed = false;
                for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                    const nIdx = getIdx(x + n.x, y + n.y);
                    if (nIdx === -1) continue;
                    const nType = grid[nIdx];
                    const isImmune = [MAT.EMPTY, MAT.GLASS, MAT.GAS, MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.RUNE_WALL].includes(nType);
                    if (!isImmune && !isLiquid(nType) && Math.random() < 0.25) {
                        setter(nIdx, MAT.EMPTY);
                        if (Math.random() < 0.2) { setter(idx, MAT.EMPTY); consumed = true; break; }
                    }
                }
                if (consumed) { moved[idx] = 1; return; }
            }

            const belowIdx = getIdx(x, y + 1);
            if (belowIdx === -1) return;

            // --- THE CRITICAL COLLISION CHECK ---
            // If the space below is occupied by a rigid body, stop falling and try to spread sideways.
            if (rigidBodyGrid[belowIdx] === 1) {
                tryMoveLiquidSide(x, y, idx, type, moved, Math.random() < 0.5 ? -1 : 1, 20, 1, grid, w, h, getIdx, setter);
                if (grid[idx] === MAT.OIL_BURNING) updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter);
                return; // Stop vertical movement and exit
            }

            // Burning logic remains the same
            if (grid[belowIdx] === MAT.FIRE) {
                if (grid[idx] === MAT.OIL) setter(idx, MAT.OIL_BURNING);
                else { setter(idx, MAT.GAS); setter(belowIdx, MAT.GAS); }
                return;
            }

            // Standard liquid movement logic
            const below = grid[belowIdx];
            if ([MAT.EMPTY, MAT.GAS].includes(below)) {
                setter(idx, below); setter(belowIdx, type); moved[belowIdx] = 1; return;
            }
            if (LIQUID_DENSITY[type] > LIQUID_DENSITY[below]) {
                setter(idx, below); setter(belowIdx, type); moved[belowIdx] = 1; return;
            }
            tryMoveLiquidSide(x, y, idx, type, moved, Math.random() < 0.5 ? -1 : 1, 20, 1, grid, w, h, getIdx, setter);
            if (grid[idx] === MAT.OIL_BURNING) updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter);
        }

        function updateGas(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const aboveIdx = getIdx(x, y - 1);
            if (y === 0) { setter(idx, MAT.EMPTY); return; }
            const above = grid[aboveIdx];
            if ([MAT.EMPTY, MAT.WATER, MAT.SAND, MAT.SOIL, MAT.GUNPOWDER].includes(above)) {
                setter(idx, above); setter(aboveIdx, MAT.GAS); moved[aboveIdx] = 1;
                return;
            }
            tryMoveLiquidSide(x, y, idx, MAT.GAS, moved, Math.random() < 0.5 ? -1 : 1, 4, -1, grid, w, h, getIdx, setter);
        }

        function tryMoveLiquidSide(x, y, currentIdx, type, moved, dir, limit, vDir, grid, w, h, getIdx, setter) {
            let targetX = x;
            const movableMaterials = [MAT.EMPTY, MAT.GAS, MAT.FIRE];
            const allMovableMaterials = [...LIQUIDS, ...movableMaterials];
            for (let i = 1; i <= limit; i++) {
                const nextX = x + (dir * i);
                const nextIdx = getIdx(nextX, y);
                if (nextIdx === -1 || rigidBodyGrid[nextIdx] === 1) break;
                const content = grid[nextIdx];
                const canMove = allMovableMaterials.includes(content) && type != content;
                if (canMove) {
                    targetX = nextX;
                    const vIdx = getIdx(nextX, y + vDir);
                    if (vIdx !== -1 && movableMaterials.includes(grid[vIdx])) break;
                } else break;
            }
            if (targetX !== x) {
                const tIdx = getIdx(targetX, y);
                setter(currentIdx, grid[tIdx]); setter(tIdx, type); moved[tIdx] = 1;
                return true;
            }
            return false;
        }

        function pushLiquidRowSideways(x, y, liquidType, grid, w, h, getIdx, maxPush = 10) {
            const dirs = Math.random() < 0.5 ? [-1, 1] : [1, -1];

            for (const dir of dirs) {
                // find empty space
                for (let i = 1; i <= maxPush; i++) {
                    const targetIdx = getIdx(x + dir * i, y);
                    if (targetIdx === -1) break;

                    if (grid[targetIdx] === MAT.EMPTY) {
                        // shift liquid toward empty space
                        for (let j = i; j > 0; j--) {
                            const fromIdx = getIdx(x + dir * (j - 1), y);
                            const toIdx   = getIdx(x + dir * j, y);

                            if (grid[fromIdx] !== liquidType) break;
                            setGrid(toIdx, grid[fromIdx]);
                            setGrid(fromIdx, MAT.EMPTY);
                            activateChunkAt(x + dir * (j - 1), y);
                            activateChunkAt(x + dir * j, y);
                        }
                        return true;
                    }

                    // stop if blocked by solid
                    if (![MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.ACID].includes(grid[targetIdx])) {
                        break;
                    }
                }
            }
            return false;
        }

        function findGroundBelow(x, startY) {
            for (let y = startY; y < worldHeight; y++) {
                const idx = getIdx(x, y);
                if (idx !== -1 && grid[idx] !== MAT.EMPTY) {
                    return y;
                }
            }
            return worldHeight - 1;
        }

        function createReservoir({
            x,
            y,
            width,
            height,
            fillType,
            wallType = MAT.WOOD
        }) {
            const groundY = findGroundBelow(x, y);
            const topY = Math.max(0, groundY - height);
            const leftX = Math.floor(x - width / 2);
            const rightX = Math.floor(x + width / 2);
            const wallWidth = 2;

            for (let iy = topY; iy <= groundY; iy++) {
                for (let ix = leftX; ix <= rightX; ix++) {
                    const idx = getIdx(ix, iy);
                    if (idx === -1) continue;

                    const isWall =
                        ix <= leftX + wallWidth ||
                        ix >= rightX - wallWidth ||
                        iy >= groundY - wallWidth;

                    setGrid(idx, isWall ? wallType : fillType);
                }
            }
        }

        function createCircle({
            x,
            y,
            radius,
            type
        }) {
            const r2 = radius * radius;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy > r2) continue;

                    const px = Math.floor(x + dx);
                    const py = Math.floor(y + dy);
                    const idx = getIdx(px, py);
                    if (idx === -1) continue;

                    setGrid(idx, type);
                }
            }
        }

        function createCircleOutline({ x, y, radius, thickness = 1, type }) {
            const r2 = radius * radius;
            const inner = (radius - thickness) ** 2;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const d2 = dx * dx + dy * dy;
                    if (d2 > r2 || d2 < inner) continue;

                    const idx = getIdx(x + dx, y + dy);
                    if (idx !== -1) setGrid(idx, type);
                }
            }
        }

        /**
         * Performs a fast, localized lighting update on a single chunk.
         * Crucially, it also detects if light has "spilled" over a border and returns
         * a Set of neighboring chunks that should now also be activated.
         * @param {object} chunk - The chunk object to process.
         * @returns {Set<object>} A set of neighboring chunk objects to activate next.
         */
        function updateLocalLightingAndFindNeighbors(chunk) {
            const neighborsToActivate = new Set();
            const chunkX_base = chunk.index % chunkWidth;
            const chunkY_base = Math.floor(chunk.index / chunkWidth);
            const startX = chunkX_base * CHUNK_SIZE;
            const startY = chunkY_base * CHUNK_SIZE;
            const endX = startX + CHUNK_SIZE;
            const endY = startY + CHUNK_SIZE;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = getIdx(x, y);
                    if (idx === -1) continue;

                    let maxNeighborLight = 0;
                    if (x > 0) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx - 1]);
                    if (x < worldWidth - 1) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx + 1]);
                    if (y > 0) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx - worldWidth]);
                    if (y < worldHeight - 1) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx + worldWidth]);

                    const isWall = WALL_TYPES.has(grid[idx]);
                    const lightLoss = isWall ? 3 : 0;
                    const potentialLight = maxNeighborLight - lightLoss;
                    
                    let lightChanged = false;
                    if (potentialLight > lightGrid[idx]) {
                        lightGrid[idx] = potentialLight;
                        lightChanged = true;
                    }

                    if (grid[idx] === MAT.EMPTY && lightGrid[idx] < MAX_LIGHT_LEVEL) {
                        lightGrid[idx] = MAX_LIGHT_LEVEL;
                        lightChanged = true;
                    }

                    if (lightChanged) {
                        // Check neighbors if this pixel is on a chunk border
                        const dirs = [{dx:-1, dy:0}, {dx:1, dy:0}, {dx:0, dy:-1}, {dx:0, dy:1}];
                        for (const dir of dirs) {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;
                            
                            // Check if the neighbor is in a different chunk
                            if (Math.floor(nx / CHUNK_SIZE) !== chunkX_base || Math.floor(ny / CHUNK_SIZE) !== chunkY_base) {
                                const nIdx = getIdx(nx, ny);
                                // If the neighbor exists and isn't a wall, it can receive light.
                                if (nIdx !== -1 && !WALL_TYPES.has(grid[nIdx])) {
                                    const nChunkX = Math.floor(nx / CHUNK_SIZE);
                                    const nChunkY = Math.floor(ny / CHUNK_SIZE);
                                    if (nChunkX >= 0 && nChunkX < chunkWidth && nChunkY >= 0 && nChunkY < chunkHeight) {
                                        neighborsToActivate.add(chunkGrid[nChunkY * chunkWidth + nChunkX]);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return neighborsToActivate;
        }

        /**
         * Calculates light levels using a Breadth-First Search with material-dependent dampening.
         * Light originates from EMPTY cells, travels freely through non-ROCK_WALL materials,
         * and loses strength when penetrating WALLs.
         */
        function updateLighting() {
            lightGrid.fill(0);
            const queue = [];

            // 1. Seed the queue with all empty cells as the light sources.
            // const searchRadius = 25;
            // const startX = Math.max(0, Math.floor(camera.x) - searchRadius);
            // const endX = Math.min(worldWidth, Math.floor(camera.x) + viewWidth + searchRadius);
            // const startY = Math.max(0, Math.floor(camera.y) - searchRadius);
            // const endY = Math.min(worldHeight, Math.floor(camera.y) + viewHeight + searchRadius);

            const startX = 0;
            const endX = worldWidth;
            const startY = 0;
            const endY = worldHeight;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = getIdx(x, y);
                    if (idx !== -1 && grid[idx] === MAT.EMPTY) {
                        lightGrid[idx] = MAX_LIGHT_LEVEL;
                        queue.push(idx);
                    }
                }
            }

            // 2. Spread the light outwards layer by layer (BFS)
            let head = 0;
            const DIRS = [-1, 1, -worldWidth, worldWidth];

            while (head < queue.length) {
                const currentIdx = queue[head++];
                const currentLight = lightGrid[currentIdx];

                if (currentLight <= 1) continue;

                for (const dir of DIRS) {
                    const nextIdx = currentIdx + dir;

                    if (nextIdx < 0 || nextIdx >= grid.length || (dir === 1 && nextIdx % worldWidth === 0) || (dir === -1 && currentIdx % worldWidth === 0)) {
                        continue;
                    }
                    
                    // --- NEW LIGHTING LOGIC ---
                    // Determine the light loss based on the material we are *entering*.
                    const isNextMaterialWall = WALL_TYPES.has(grid[nextIdx]);
                    
                    // Light passing into a WALL is heavily dampened.
                    // Light passing into ANY OTHER material is not dampened at all.
                    const lightLoss = isNextMaterialWall ? 3 : 0;
                    
                    const nextLight = currentLight - lightLoss;

                    // If our calculated light is brighter than the neighbor's current light, update it.
                    if (nextLight > lightGrid[nextIdx]) {
                        lightGrid[nextIdx] = nextLight;
                        // Always add the neighbor to the queue to continue spreading light.
                        queue.push(nextIdx); 
                    }
                }
            }
        }

        let playerMaskCanvas, playerMaskCtx;

        // --- RENDERING ---
        function setPixel(x, y, r, g, b, a = 255) {
            const i = (y * renderWidth + x) * 4;
            pixels[i]     = r;
            pixels[i + 1] = g;
            pixels[i + 2] = b;
            pixels[i + 3] = a;
        }

        function render() {
            // --- WORLD ---
            firePixelsCoords = [];

            // ---- PASS 0: Background into BASE buffer (opaque) ----
            const bgPixels = skyImageData.data;
            const bgStartY = Math.floor(camera.y);

            for (let screenY = 0; screenY < renderHeight; screenY++) {
                const worldY = screenY + bgStartY;

                for (let screenX = 0; screenX < renderWidth; screenX++) {
                    const destI = (screenY * renderWidth + screenX) * 4;
                    const sourceI = (worldY * worldWidth + screenX) * 4;

                    if (sourceI >= 0 && sourceI < bgPixels.length) {
                        pixels[destI]     = bgPixels[sourceI];
                        pixels[destI + 1] = bgPixels[sourceI + 1];
                        pixels[destI + 2] = bgPixels[sourceI + 2];
                        pixels[destI + 3] = 255;
                    }
                }
            }

            const time = frameCount * 0.04;

            // Camera top-left in world pixels
            const startX = Math.floor(camera.x);
            const startY = Math.floor(camera.y);

            // ---- PASS 1: Build BASE + inline FLUID blend ----
            for (let screenY = 0; screenY < viewHeight; screenY++) {
                const worldY = screenY + startY;

                for (let screenX = 0; screenX < viewWidth; screenX++) {
                    const worldX = screenX + startX;

                    const idx = getIdx(worldX, worldY);
                    if (idx === -1) continue;

                    const type = grid[idx];
                    if (type === MAT.EMPTY || type === MAT.RIGID_BODY_STUB) continue;

                    const lightLevel = lightGrid[idx];

                    // If fully dark and not always visible
                    if (lightLevel === 0 && !ALWAYS_VISIBLE_MATERIALS.has(type)) {
                        setPixel(screenX, screenY, 0, 0, 0);
                        continue;
                    }

                    // Base color
                    let r, g, b;
                    [r, g, b] = COLORS[type];

                    // Animate / vary
                    if (type === MAT.FIRE) {
                        r = 255; g = 80 + Math.random() * 80; b = 0;
                        firePixelsCoords.push({ x: screenX, y: screenY });
                    } else if (type === MAT.OIL_BURNING || type === MAT.COAL_BURNING) {
                        firePixelsCoords.push({ x: screenX, y: screenY });
                        [r, g, b] = varyColor(...COLORS[type], worldX, worldY, type, 4);
                    } else if (LIQUIDS.has(type)) {
                        [r, g, b] = varyColor(...COLORS[type], worldX, worldY, type, 4);
                    } else {
                        if (SHIMMERING_METALS.has(type)) {
                            [r, g, b] = metallicColor(worldX, worldY, COLORS[type]);
                        } else {
                            [r, g, b] = varyColor(...COLORS[type], worldX, worldY, type, 16);
                        }
                    }

                    // Metal shimmer “spark”
                    if (SHIMMERING_METALS.has(type)) {
                        const shimmerHash = hashCell(worldX, worldY, Math.floor(frameCount / 4));
                        if (shimmerHash > 254) {
                            const shimmerBrightness = 35;
                            r = Math.min(255, r + shimmerBrightness);
                            g = Math.min(255, g + shimmerBrightness);
                            b = Math.min(255, b + shimmerBrightness);
                        }
                    }

                    // Lighting
                    if (!ALWAYS_VISIBLE_MATERIALS.has(type)) {
                        const brightness = lightLevel / MAX_LIGHT_LEVEL;
                        r = (r * brightness) | 0;
                        g = (g * brightness) | 0;
                        b = (b * brightness) | 0;
                    }

                    const destI = (screenY * renderWidth + screenX) * 4;

                    if (isFluid(type)) {
                        // Inline alpha blend into base pixels
                        const a = fluidAlpha(type); // 0..255
                        blendPixel(pixels, destI, r | 0, g | 0, b | 0, a);
                    } else {
                        // Opaque write
                        pixels[destI]     = r | 0;
                        pixels[destI + 1] = g | 0;
                        pixels[destI + 2] = b | 0;
                        pixels[destI + 3] = 255;
                    }
                }
            }

            // Draw BASE (now includes fluids)
            ctx.putImageData(imageData, 0, 0);

            // Bloom still based on firePixelsCoords from base world draw
            // renderBloom();

            // --- RENDER RIGID BODIES (Planck version) ---
            for (const body of rigidBodies) {
                if (!body.body) continue;

                const pos = body.body.getPosition();
                const angle = body.body.getAngle();

                ctx.save();
                ctx.translate(
                    pos.x * B2_SCALE - camera.x,
                    pos.y * B2_SCALE - camera.y
                );
                ctx.rotate(angle);

                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const type = body.pixels[y * body.width + x];
                        if (type === MAT.EMPTY) continue;

                        let r, g, b;
                        if (SHIMMERING_METALS.has(type)) {
                            [r, g, b] = metallicColor(x, y, COLORS[type]);
                        } else {
                            [r, g, b] = varyColor(...COLORS[type], x, y, type, 8);
                        }

                        ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
                        ctx.fillRect(x - body.width / 2, y - body.height / 2, 1, 1);
                    }
                }

                ctx.restore();
            }
            // --- END BLOCK ---

            // ---- PLAYER (scaled + 2-frame anim, modular) ----
            const aim = computePlayerAim();
            const anim = getPlayerAnimFrame();
            const playerDraw = renderPlayer(aim, anim);
            wandScreenX = playerDraw.wandOriginX;
            wandScreenY = playerDraw.wandOriginY;

            // --- RENDER POURED PARTICLES ---
            for (const p of pouredParticles) {
                const [r, g, b] = COLORS[p.type];
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1);
            }

            // --- RENDER MAGIC PARTICLES ---
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (p.active) {
                    ctx.fillStyle = `rgb(${p.color[0]}, ${p.color[1]}, ${p.color[2]})`;
                    ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1);
                }
            }

            // --- RENDER INTERACT HINT ---
            if (player.canInteract && player.currentTrigger) {
                const trigger = player.currentTrigger;

                const hintX = Math.round(trigger.x - camera.x + trigger.width / 2);
                const hintY = Math.round(trigger.y - camera.y - 15);

                const hoverAmplitude = 3;
                const hoverSpeed = 0.05;
                const animatedY = hintY + Math.sin(frameCount * hoverSpeed) * hoverAmplitude;

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(hintX - 8, animatedY - 12, 16, 16);

                ctx.font = 'bold 12px monospace';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('E', hintX, animatedY);
            }

            // --- AIM LINE ---
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(wandScreenX, wandScreenY);
            ctx.lineTo(mouse.x / scale, mouse.y / scale);
            ctx.stroke();

            // ✅ fluids compositing removed

            //debugDrawActiveChunks(activeChunks);
            renderPlayerStatsUI();
            renderAlchemyUI();
        }

        // 8x16 base sprite pixels (local coords). Keep it simple.
        const PLAYER_PIXELS = {
            cloak: [
                // hood/top
                [2,0],[3,0],[4,0],[5,0],[6,0],[7,0],
                [0,2],[1,2],[2,2],[3,2],[4,2],[5,2],[6,2],[7,2],
                // body fill (rough)
                // you can tweak these lists later
            ],
            body: [
                // fill a block-ish cloak body
                ...(() => {
                const pts = [];
                for (let y=3; y<=13; y++) for (let x=0; x<=7; x++) pts.push([x,y]);
                return pts;
                })(),
                // feet
                [2,14],[3,14],[4,14],[5,14],[2,15],[3,15],[4,15],[5,15],
            ],
            faceR: [[4,2],[5,2],[4,3],[5,3],[4,4],[5,4],[4,5],[5,5]],
            faceL: [[2,2],[3,2],[2,3],[3,3],[2,4],[3,4],[2,5],[3,5]],
        };

        // 8x16 sprite masks (strings). '.' = transparent, '#' = cloak/body, 'F' = face.
        // Frame 0/1 are very similar; frame 1 shifts arms/torso by 1 px to fake motion.
        const PLAYER_SPRITE = [
        [
            "....##..", // 0
            "...####.", // 1
            "..######", // 2
            "..##F##.", // 3
            "..##F##.", // 4
            "..######", // 5
            ".#######", // 6
            ".#######", // 7
            ".#######", // 8
            ".#######", // 9
            "..######", //10
            "..######", //11
            "...####.", //12
            "..######", //13  (robe hem)
            ".######.", //14  (feet)
            "########"  //15
        ],
        [
            "....##..", // 0
            "...####.", // 1
            "..######", // 2
            "..##F##.", // 3
            "..##F##.", // 4
            "..######", // 5
            ".#######", // 6
            ".#######", // 7
            ".#######", // 8
            ".#######", // 9
            "..######", //10
            "...#####", //11  (slight shift)
            "..#####.", //12  (slight shift)
            "..######", //13
            ".######.", //14
            "########"  //15
        ],
        ];


        function drawPlayerBodyScreen(baseScreenX, baseScreenY, facingRight, bob, frameIdx) {
            // Colors (same as before)
            const cloak = [0x4a, 0x2d, 0x5e];
            const face  = [0x21, 0x1e, 0x20];

            const sprite = PLAYER_SPRITE[frameIdx & 1];

            for (let y = 0; y < 16; y++) {
                const row = sprite[y];
                for (let x = 0; x < 8; x++) {
                    const ch = row[x];
                    if (ch === '.') continue;

                    // Flip horizontally when facing left
                    const fx = facingRight ? x : (7 - x);

                    const sx = baseScreenX + fx;
                    const sy = baseScreenY + y + bob;

                    if (ch === 'F') {
                        drawPlayerPx(sx, sy, face[0], face[1], face[2]);
                    } else {
                        drawPlayerPx(sx, sy, cloak[0], cloak[1], cloak[2]);
                    }
                }
            }
        }




        // Alpha blend (src over dst) directly into the main pixel buffer.
        // a = 0..255
        function blendPixel(pixels, destI, r, g, b, a) {
            // If fully opaque, just write
            if (a >= 255) {
                pixels[destI]     = r;
                pixels[destI + 1] = g;
                pixels[destI + 2] = b;
                pixels[destI + 3] = 255;
                return;
            }
            // If fully transparent, do nothing
            if (a <= 0) return;

            const invA = 255 - a;

            // dst is already opaque background/world in your pipeline
            pixels[destI]     = ((r * a + pixels[destI]     * invA) / 255) | 0;
            pixels[destI + 1] = ((g * a + pixels[destI + 1] * invA) / 255) | 0;
            pixels[destI + 2] = ((b * a + pixels[destI + 2] * invA) / 255) | 0;
            pixels[destI + 3] = 255;
        }

        function getWorldTypeAtScreen(screenX, screenY) {
            const worldX = (screenX + camera.x) | 0;
            const worldY = (screenY + camera.y) | 0;
            const idx = getIdx(worldX, worldY);
            return (idx === -1) ? MAT.EMPTY : grid[idx];
        }

        // Returns 0..1 alpha for drawing player pixels at this screen coord.
        // If liquid is present, player becomes more transparent so liquid appears “in front”.
        function playerAlphaAtScreen(screenX, screenY) {
            const t = getWorldTypeAtScreen(screenX, screenY);
            if (!isFluid(t)) return 1;

            // fluidAlpha(t) is 0..255. Higher means “more opaque liquid”.
            const a = fluidAlpha(t) / 255;

            // Tune these:
            // - minAlpha: how visible player remains under very opaque liquid
            // - strength: how strongly fluid alpha suppresses player
            const minAlpha = 0.20;
            const strength = 0.85;

            const out = 1 - a * strength;
            return out < minAlpha ? minAlpha : out;
        }

        // Draw a single player pixel with automatic “under-liquid” alpha.
        function drawPlayerPx(screenX, screenY, r, g, b) {
            const a = playerAlphaAtScreen(screenX, screenY);
            if (a >= 0.999) {
                ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
                ctx.fillRect(screenX, screenY, 1, 1);
                return;
            }
            ctx.save();
            ctx.globalAlpha = a;
            ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
            ctx.fillRect(screenX, screenY, 1, 1);
            ctx.restore();
        }



        // ---- PLAYER RENDERING (modular) ----
        const PLAYER_SPRITE_SCALE = 1.0;

        // Returns: { facingRight, wandDir, aimAngle }
        function computePlayerAim() {
            const aimDX = mouse.worldX - (player.x + player.width / 2);
            const aimDY = (player.y + 9) - mouse.worldY; // keep your existing "aim from chest" feel
            const aimAngle = Math.atan2(aimDY, aimDX);
            const wandDir = angleToDir16(aimAngle);

            playerFacingRight = aimDX >= 0;

            return { facingRight: playerFacingRight, wandDir, aimAngle };
        }

        // Simple 2-frame animation. Faster when moving, slower when idle.
        // Returns: { bob, armBob }
        function getPlayerAnimFrame() {
            const moving =
                keys['KeyA'] || keys['KeyD'] || keys['KeyW'] ||
                Math.abs(player.vx) > 0.05 || Math.abs(player.vy) > 0.05;

            const rate = moving ? 6 : 14;
            const frameIdx = ((frameCount / rate) | 0) & 1;

            const bob = frameIdx ? 1 : 0;
            const armBob = frameIdx ? 1 : 0;

            return { bob, armBob, frameIdx };
        }


        // Draws cloak + face at sprite-local coords (8x16 base)
        function drawPlayerBody(ctx, facingRight, bob) {
            const cloakColor = '#4a2d5e';
            const faceColor  = '#211e20';

            ctx.fillStyle = cloakColor;

            if (facingRight) {
                ctx.fillRect(2, 0 + bob, 6, 2);
                ctx.fillRect(0, 2 + bob, 8, 12);
                ctx.fillRect(2, 14 + bob, 4, 2);

                ctx.fillStyle = faceColor;
                ctx.fillRect(4, 2 + bob, 2, 4);
            } else {
                ctx.fillRect(0, 0 + bob, 6, 2);
                ctx.fillRect(0, 2 + bob, 8, 12);
                ctx.fillRect(2, 14 + bob, 4, 2);

                ctx.fillStyle = faceColor;
                ctx.fillRect(2, 2 + bob, 2, 4);
            }
        }

        // Draws wand pixels from a hand point (sprite-local), returns wand origin in SCREEN coords
        function drawWand(ctx, baseScreenX, baseScreenY, facingRight, wandDir, bob, armBob) {
            // Hand point in sprite-local coords (these matched your old numbers)
            const handLocalX = facingRight ? 8 : -1;
            const handLocalY = 9 + bob - armBob;

            // Convert to screen coords
            const handX = baseScreenX + handLocalX;
            const handY = baseScreenY + handLocalY;

            const wandLen = 3;
            const dx = wandDir.x;
            const dy = wandDir.y;
            const mag = Math.max(Math.abs(dx), Math.abs(dy)) || 1;

            ctx.fillStyle = '#bfa76a';
            for (let i = 0; i < wandLen; i++) {
                ctx.fillRect(
                    handX + Math.round(dx * i / mag),
                    handY + Math.round(dy * i / mag),
                    1, 1
                );
            }

            // Tip
            ctx.fillStyle = '#ffcc66';
            ctx.fillRect(
                handX + Math.round(dx * wandLen / mag),
                handY + Math.round(dy * wandLen / mag),
                1, 1
            );

            // Use wand origin for your aim line start
            return { wandOriginX: handX, wandOriginY: handY };
        }

        function drawWandScreen(handX, handY, wandDir) {
            const wandLen = 3;
            const dx = wandDir.x, dy = wandDir.y;
            const mag = Math.max(Math.abs(dx), Math.abs(dy)) || 1;

            // shaft
            for (let i = 0; i < wandLen; i++) {
                drawPlayerPx(
                    handX + Math.round(dx * i / mag),
                    handY + Math.round(dy * i / mag),
                    0xbf, 0xa7, 0x6a
                );
            }
            // tip
            drawPlayerPx(
                handX + Math.round(dx * wandLen / mag),
                handY + Math.round(dy * wandLen / mag),
                0xff, 0xcc, 0x66
            );
        }


        // Orchestrator: scales sprite 1.5x around feet so it "grows" nicely.
        // Returns: { wandOriginX, wandOriginY }
        function renderPlayer(aim, anim) {
            const facingRight = aim.facingRight;
            const wandDir = aim.wandDir;
            const bob = anim.bob;
            const armBob = anim.armBob;

            // Base sprite size (your original)
            const baseW = 8;
            const baseH = 16;

            const playerScreenX = Math.round(player.x - camera.x);
            const playerScreenY = Math.round(player.y - camera.y);

            ctx.imageSmoothingEnabled = false;

            // Anchor at feet-center, then scale, then draw at (-baseW/2, -baseH)
            const anchorX = playerScreenX + (baseW / 2);
            const anchorY = playerScreenY + baseH;

            ctx.save();
            ctx.translate(anchorX, anchorY);
            ctx.scale(PLAYER_SPRITE_SCALE, PLAYER_SPRITE_SCALE);

            // Sprite-local top-left
            const localX = -baseW / 2;
            const localY = -baseH;

            ctx.translate(localX, localY);

            // IMPORTANT: wand is drawn in SCREEN coords, so we draw it *after* restoring
            ctx.restore();
            
            // To draw wand at the correct place with scaling, we compute where the scaled sprite's
            // local origin ended up in screen space:
            const scaledBaseX = Math.round(anchorX + localX * PLAYER_SPRITE_SCALE);
            const scaledBaseY = Math.round(anchorY + localY * PLAYER_SPRITE_SCALE);
            
            drawPlayerBodyScreen(scaledBaseX, scaledBaseY, facingRight, bob, anim.frameIdx);
            // Wand is drawn in screen pixels (1x1 rects), so it looks crisp.
            return drawWand(ctx, scaledBaseX, scaledBaseY, facingRight, wandDir, bob, armBob);
        }



        function createWoodenBox(x, y, width = 16, height = 16) {
            const box = new RigidBody(x, y, width, height, MAT.WOOD);
            rigidBodies.push(box);
        }

        function updateRigidBodyInteractions() {
            const now = performance.now();

            // Tuneables
            const SPLIT_COOLDOWN_MS = 250;       // 150–500
            const SPLIT_DELTA_THRESHOLD = 25;    // 10–80 depending on body size/burn rate

            // Rigid-body internal fire → world gas emission limiter
            const RB_GAS_BUDGET_PER_BODY = 10;   // 5–20
            const RB_GAS_CHANCE = 0.25;          // 0.1–0.4

            // IMPORTANT:
            // FIRE is treated as STRUCTURAL inside rigid bodies.
            // Collider only changes when pixels become EMPTY (or GAS).
            const isStructural = (t) => (t !== MAT.EMPTY && t !== MAT.GAS);

            for (const body of rigidBodies) {
                if (body.isDestroyed) continue;

                // Lazy-init debounce fields
                body.lastSplitTime = body.lastSplitTime ?? 0;
                body.pendingStructuralDelta = body.pendingStructuralDelta ?? 0;

                let pixelsChanged = false;
                let structuralEditsThisTick = 0;

                // --------------------------------------------------
                // World interactions affecting rigid body pixels
                // --------------------------------------------------
                body_pixel_loop:
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const localIdx = y * body.width + x;
                        const type = body.pixels[localIdx];
                        if (type === MAT.EMPTY) continue;

                        // local pixel -> world position
                        const localPos = pl.Vec2(
                            (x - body.width / 2 + 0.5) / B2_SCALE,
                            (y - body.height / 2 + 0.5) / B2_SCALE
                        );
                        const worldPos = body.body.getWorldPoint(localPos);
                        const worldX = Math.floor(worldPos.x * B2_SCALE);
                        const worldY = Math.floor(worldPos.y * B2_SCALE);

                        // WOOD reacts to nearby materials
                        if (type === MAT.WOOD) {
                            const searchRadius = 2;

                            for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                                for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                                    const checkIdx = getIdx(worldX + dx, worldY + dy);
                                    if (checkIdx === -1) continue;

                                    const worldMaterial = grid[checkIdx];

                                    // Acid destroys wood
                                    if (worldMaterial === MAT.ACID) {
                                        const oldT = body.pixels[localIdx];
                                        const newT = MAT.EMPTY;

                                        if (oldT !== newT) {
                                            body.pixels[localIdx] = newT;
                                            setGrid(checkIdx, MAT.EMPTY);

                                            pixelsChanged = true;
                                            if (isStructural(oldT) !== isStructural(newT)) structuralEditsThisTick++;
                                        }
                                        continue body_pixel_loop;
                                    }

                                    // Fire ignites wood (visual/state only; now STRUCTURAL stays true)
                                    if (
                                        (worldMaterial === MAT.FIRE ||
                                        worldMaterial === MAT.OIL_BURNING ||
                                        worldMaterial === MAT.COAL_BURNING)
                                        && Math.random() < 0.25
                                    ) {
                                        const oldT = body.pixels[localIdx];
                                        const newT = MAT.FIRE;

                                        if (oldT !== newT) {
                                            body.pixels[localIdx] = newT;
                                            pixelsChanged = true;

                                            // With FIRE treated as structural, this does NOT trigger rebuilds.
                                            if (isStructural(oldT) !== isStructural(newT)) structuralEditsThisTick++;
                                        }
                                        continue body_pixel_loop;
                                    }
                                }
                            }
                        }
                    }
                }

                // --------------------------------------------------
                // Internal simulation (fire spread inside rigid body)
                // --------------------------------------------------
                let rbGasBudget = RB_GAS_BUDGET_PER_BODY;

                function emitGasFromLocalIndex(localIdx) {
                    const lx = localIdx % body.width;
                    const ly = (localIdx / body.width) | 0;

                    const localPos = pl.Vec2(
                        (lx - body.width / 2 + 0.5) / B2_SCALE,
                        (ly - body.height / 2 + 0.5) / B2_SCALE
                    );

                    const worldPos = body.body.getWorldPoint(localPos);
                    const wx = Math.floor(worldPos.x * B2_SCALE);
                    const wy = Math.floor(worldPos.y * B2_SCALE);

                    const wIdx = getIdx(wx, wy);
                    if (wIdx === -1) return;

                    if (grid[wIdx] === MAT.EMPTY || grid[wIdx] === MAT.GAS) {
                        setGrid(wIdx, MAT.GAS);
                    }
                }

                const localSetter = (idx, type) => {
                    if (idx === -1) return;

                    const oldT = body.pixels[idx];

                    // If local sim produces GAS, emit it to world and clear locally
                    if (type === MAT.GAS) {
                        if (rbGasBudget > 0 && Math.random() < RB_GAS_CHANCE) {
                            emitGasFromLocalIndex(idx);
                            rbGasBudget--;
                        }

                        const newT = MAT.EMPTY;
                        if (oldT !== newT) {
                            body.pixels[idx] = newT;
                            pixelsChanged = true;
                            if (isStructural(oldT) !== isStructural(newT)) structuralEditsThisTick++;
                        }
                        return;
                    }

                    // Normal set
                    if (oldT !== type) {
                        body.pixels[idx] = type;
                        pixelsChanged = true;
                        if (isStructural(oldT) !== isStructural(type)) structuralEditsThisTick++;
                    }
                };

                runSimulationOnSmallGrid(
                    body.moved,
                    body.pixels,
                    body.width,
                    body.height,
                    localSetter
                );

                // --------------------------------------------------
                // Leak some FIRE out into world (optional)
                // --------------------------------------------------
                if (pixelsChanged) {
                    let leaks = 0;
                    const MAX_LEAKS = 3;

                    for (let y = 0; y < body.height && leaks < MAX_LEAKS; y++) {
                        for (let x = 0; x < body.width && leaks < MAX_LEAKS; x++) {
                            const localIdx = y * body.width + x;
                            if (body.pixels[localIdx] !== MAT.FIRE) continue;

                            const localPos = pl.Vec2(
                                (x - body.width / 2 + 0.5) / B2_SCALE,
                                (y - body.height / 2 + 0.5) / B2_SCALE
                            );
                            const worldPos = body.body.getWorldPoint(localPos);
                            const worldX = Math.floor(worldPos.x * B2_SCALE);
                            const worldY = Math.floor(worldPos.y * B2_SCALE);

                            const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
                            const d = dirs[(Math.random() * dirs.length) | 0];

                            const checkIdx = getIdx(worldX + d.dx, worldY + d.dy);
                            if (checkIdx !== -1 && (grid[checkIdx] === MAT.EMPTY || grid[checkIdx] === MAT.GAS)) {
                                setGrid(checkIdx, MAT.FIRE);
                                leaks++;
                            }
                        }
                    }
                }

                // --------------------------------------------------
                // ✅ Debounced collider updates
                // --------------------------------------------------
                if (structuralEditsThisTick > 0) {
                    body.pendingStructuralDelta += structuralEditsThisTick;
                }

                if (
                    body.pendingStructuralDelta >= SPLIT_DELTA_THRESHOLD &&
                    (now - body.lastSplitTime) > SPLIT_COOLDOWN_MS
                ) {
                    body.needsShapeUpdate = true;      // your rebuild loop will decide rebuild vs split
                    body.pendingStructuralDelta = 0;
                    body.lastSplitTime = now;
                }
            }
        }




        /**
         * Top-level function to draw both inventory containers on the screen.
         */
        function renderContainers() {
            const pouchX = renderWidth - pouchWidth - 12;
            const flaskX = pouchX - flaskWidth - 8;
            const commonY = 40;

            renderContainer(pouchGrid, pouchWidth, pouchHeight, pouchX, commonY, activeContainer === 'pouch');
            renderContainer(flaskGrid, flaskWidth, flaskHeight, flaskX, commonY, activeContainer === 'flask');
        }

        /**
         * Draws a single container's border and its contents.
         */
        function renderContainer(cGrid, cW, cH, screenX, screenY, isActive) {
            // Draw background and border
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(screenX - 2, screenY - 2, cW + 4, cH + 4);
            ctx.strokeStyle = isActive ? 'white' : '#888'; // Highlight if active
            ctx.lineWidth = 2;
            ctx.strokeRect(screenX - 2, screenY - 2, cW + 4, cH + 4);

            // Draw contents
            for (let y = 0; y < cH; y++) {
                for (let x = 0; x < cW; x++) {
                    const type = cGrid[getIdx(x, y, cW, cH)];
                    if (type !== MAT.EMPTY) {
                        if (SHIMMERING_METALS.has(type)) {
                            [r, g, b] = metallicColor(x, y, COLORS[type]);
                        } else {
                            [r, g, b] = varyColor(...COLORS[type], x, y, type, 8);
                        }

                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fillRect(screenX + x, screenY + y, 1, 1);
                    }
                }
            }
        }

        function renderBloom() {
            if (firePixelsCoords.length === 0) return;

            // --- Configuration ---
            const bloomRadius = 6; // How far the glow extends, in pixels
            const bloomIntensity = 0.01; // How bright the glow is (0.0 to 1.0)
            const bloomColor = [180, 100, 50]; // The color of the glow (R, G, B)
            
            // Get the current canvas content so we can blend with it
            const screenData = ctx.getImageData(0, 0, renderWidth, renderHeight);
            const screenPixels = screenData.data;
            
            const r2 = bloomRadius * bloomRadius;

            // Iterate ONLY through the fire pixels we found earlier
            for (const p of firePixelsCoords) {
                // For each fire pixel, draw a glow "stamp" around it
                for (let dy = -bloomRadius; dy <= bloomRadius; dy++) {
                    for (let dx = -bloomRadius; dx <= bloomRadius; dx++) {
                        const distSq = dx * dx + dy * dy;
                        if (distSq > r2) continue;

                        const px = p.x + dx;
                        const py = p.y + dy;

                        // Bounds check
                        if (px < 0 || px >= renderWidth || py < 0 || py >= renderHeight) continue;
                        
                        // Calculate falloff: glow is strongest at the center
                        const falloff = (1.0 - (distSq / r2)) * bloomIntensity;
                        if (falloff <= 0) continue;
                        
                        const i = (py * renderWidth + px) * 4;

                        // Additive blending
                        screenPixels[i]     = Math.min(255, screenPixels[i]     + bloomColor[0] * falloff);
                        screenPixels[i + 1] = Math.min(255, screenPixels[i + 1] + bloomColor[1] * falloff);
                        screenPixels[i + 2] = Math.min(255, screenPixels[i + 2] + bloomColor[2] * falloff);
                    }
                }
            }

            // Put the modified pixel data (with bloom) back onto the canvas
            ctx.putImageData(screenData, 0, 0);
        }

        function angleToDir16(a) {
            const step = Math.PI / 8;
            const i = Math.round(a / step) & 15;
            return WAND_DIRS_16[i];
        }


        const WAND_DIRS_16 = [
            { x: 1,  y: 0 },
            { x: 2,  y: -1 },
            { x: 1,  y: -1 },
            { x: 1,  y: -2 },
            { x: 0,  y: -1 },
            { x: -1, y: -2 },
            { x: -1, y: -1 },
            { x: -2, y: -1 },
            { x: -1, y: 0 },
            { x: -2, y: 1 },
            { x: -1, y: 1 },
            { x: -1, y: 2 },
            { x: 0,  y: 1 },
            { x: 1,  y: 2 },
            { x: 1,  y: 1 },
            { x: 2,  y: 1 },
        ];

        function animateLiquidColor(r, g, b, x, y, type, time) {
            // Static grain (same as solids)
            const baseNoise = (hashCell(x, y, type) / 255 - 0.5) * 12;

            // Animated wave
            const wave = liquidWave(x, y, time) * 10;

            const delta = baseNoise + wave;

            return [
                Math.max(0, Math.min(255, r + delta)),
                Math.max(0, Math.min(255, g + delta)),
                Math.max(0, Math.min(255, b + delta))
            ];
        }

        function liquidWave(x, y, t) {
            return Math.sin(x * 0.15 + t) * 0.5 +
                Math.sin(y * 0.1  + t * 1.3) * 0.5;
        }

        function hashCell(x, y, type) {
            // Fast, deterministic hash
            let h = x * 374761393 + y * 668265263 + type * 1442695041;
            h = (h ^ (h >> 13)) * 1274126177;
            return (h ^ (h >> 16)) & 0xff; // 0..255
        }

        function metallicColor(x, y, baseRGB) {
            const [br, bg, bb] = baseRGB;

            // Deterministic "brushed metal" stripes (smooth, not grain)
            // Use low-frequency sine + a diagonal component
            const stripe =
                0.5 +
                0.5 * Math.sin((x * 0.35) + (y * 0.18));

            // Subtle second layer to avoid flatness
            const stripe2 =
                0.5 +
                0.5 * Math.sin((x * 0.08) - (y * 0.12));

            // Combine, keep it subtle
            const t = 0.65 * stripe + 0.35 * stripe2; // 0..1

            // "Specular" glint: occasional thin highlight bands
            const glint = (Math.sin(x * 0.9 + y * 0.25) > 0.985) ? 0.25 : 0.0;

            // Final brightness multiplier
            const m = 0.85 + 0.35 * t + glint;

            // Keep it in a steel-ish range (slightly bluer)
            const r = Math.min(255, Math.max(0, br * m));
            const g = Math.min(255, Math.max(0, bg * (m * 0.98)));
            const b = Math.min(255, Math.max(0, bb * (m * 1.05)));

            return [r | 0, g | 0, b | 0];
        }


        function varyColor(r, g, b, x, y, type, strength = 18) {
            // strength = max brightness change (try 12–24)
            const n = hashCell(x, y, type) / 255; // 0..1
            const delta = (n - 0.5) * strength * 2;

            return [
                Math.max(0, Math.min(255, r + delta)),
                Math.max(0, Math.min(255, g + delta)),
                Math.max(0, Math.min(255, b + delta))
            ];
        }

        function updateHoverMaterial() {
            const idx = getIdx(mouse.worldX, mouse.worldY);
            if (idx === -1) {
                hudMaterial = '--';
            } else {
                const type = grid[idx];
                hudMaterial = MATERIAL_NAME[type] || 'Unknown';
            }
        }


        function findGroundSurfaceY(x) {
            for (let y = 0; y < worldHeight; y++) { if (grid[getIdx(x, y)] !== MAT.EMPTY) return y; }
            return worldHeight - 1;
        }
        function drawTree(baseX, baseY) {
            const trunkHeight = 40 + Math.floor(Math.random() * 12); // Scaled height
            for (let i = 0; i < trunkHeight; i++) {
                const y = baseY - i; if (y < 0) continue;
                setGrid(getIdx(baseX, y), MAT.WOOD);
                if(i < 30) { // Scaled thickness
					setGrid(getIdx(baseX - 1, y), MAT.WOOD);
					setGrid(getIdx(baseX + 1, y), MAT.WOOD);
				}
            }
        }


        /**
         * Generates a horizontal slab with a background, inscribed runes, and border lines.
         * @param {number} slabX - The top-left X coordinate of the slab.
         * @param {number} slabY - The top-left Y coordinate of the slab.
         * @param {number} slabWidth - The width of the slab.
         * @param {number} slabHeight - The height of the slab.
         * @param {material} backgroundMaterial - The material for the slab's base.
         * @param {material} runeMaterial - The material for the inscribed runes and borders.
         */
        function generateRunicSlab(slabX, slabY, slabWidth, slabHeight, backgroundMaterial, runeMaterial) {
            // 1. Fill the entire slab area with the background material.
            for (let y = slabY; y < slabY + slabHeight; y++) {
                for (let x = slabX; x < slabX + slabWidth; x++) {
                    const idx = getIdx(x, y);
                    if (idx !== -1) setGrid(idx, backgroundMaterial);
                }
            }

            // --- Calculate vertical positioning ---
            const verticalPadding = Math.floor((slabHeight - DWARVEN_RUNES.RUNE_HEIGHT) / 2);
            const runesTopY = slabY + verticalPadding;
            const runesBottomY = runesTopY + DWARVEN_RUNES.RUNE_HEIGHT - 1;

            // NEW: 2. Draw the horizontal border lines.
            const lineThickness = 1; // You can make this thicker if you like
            const linePadding = 3;   // Pixels of space between the line and the runes

            // Top line
            const topLineY = runesTopY - linePadding;
            for (let t = 0; t < lineThickness; t++) {
                for (let x = slabX; x < slabX + slabWidth; x++) {
                    const idx = getIdx(x, topLineY - t);
                    if (idx !== -1) setGrid(idx, runeMaterial);
                }
            }
            
            // Bottom line
            const bottomLineY = runesBottomY + linePadding;
            for (let t = 0; t < lineThickness; t++) {
                for (let x = slabX; x < slabX + slabWidth; x++) {
                    const idx = getIdx(x, bottomLineY + t);
                    if (idx !== -1) setGrid(idx, runeMaterial);
                }
            }
            
            // --- Inscribe the runes ---
            const runePadding = 5;
            let cursorX = slabX + runePadding;

            // 3. Loop and stamp the runes.
            while (cursorX + DWARVEN_RUNES.RUNE_WIDTH + runePadding < slabX + slabWidth) {
                // ... (The rest of the rune stamping logic is exactly the same) ...
                const pattern = DWARVEN_RUNES.PATTERNS[Math.floor(Math.random() * DWARVEN_RUNES.PATTERNS.length)];

                for (let y = 0; y < DWARVEN_RUNES.RUNE_HEIGHT; y++) {
                    for (let x = 0; x < DWARVEN_RUNES.RUNE_WIDTH; x++) {
                        if (pattern[y][x] === 1) {
                            const drawX = cursorX + x;
                            const drawY = runesTopY + y;
                            const idx = getIdx(drawX, drawY);
                            if (idx !== -1) {
                                setGrid(idx, runeMaterial);
                            }
                        }
                    }
                }

                cursorX += DWARVEN_RUNES.RUNE_WIDTH + runePadding;
            }
        }

        /**
         * Creates a persistent particle emitter that spawns particles over time.
         * Can spawn from an area or along a line.
         * @param {object} options - An object with configuration for the emitter.
         * @returns {number} The unique ID of the created emitter.
         */
        function createMagicEmitter(options) {
            const emitter = {
                id: nextEmitterId++,
                mainColor: options.mainColor || [255, 255, 255],
                spawnRate: options.spawnRate || 0.2,
                
                // --- NEW: Spawning type and coordinates ---
                spawnType: options.spawnType || 'area', // Can be 'area' or 'line'
                
                // Properties for 'area' type (the original behavior)
                x: options.x || 0,
                y: options.y || 0,
                spawnArea: options.spawnArea || { width: 10, height: 5 },
                
                // Properties for 'line' type
                x1: options.x1 || 0,
                y1: options.y1 || 0,
                x2: options.x2 || 0,
                y2: options.y2 || 0,

                // --- Particle-specific properties (remain the same) ---
                particleLifespan: options.particleLifespan || { min: 60, max: 150 },
                particleVelocity: options.particleVelocity || { 
                    vx: { min: -0.2, max: 0.2 },
                    vy: { min: -0.2, max: -0.6 }
                },
                colorVariance: options.colorVariance || 60
            };
            magicEmitters.push(emitter);
            return emitter.id;
        }

        /**
         * Removes a magic particle emitter by its unique ID.
         * @param {number} id - The ID of the emitter to remove.
         */
        function removeMagicEmitter(id) {
            magicEmitters = magicEmitters.filter(e => e.id !== id);
        }
        
        /**
         * Updates all active emitters, spawning new particles based on their configuration.
         * This function handles both 'area' and 'line' spawn types.
         */
        function updateMagicEmitters() {
            // Loop through every active emitter
            for (const emitter of magicEmitters) {
                // Use the spawnRate as a probability check for this frame
                if (Math.random() < emitter.spawnRate) {
                    
                    // Find an available (inactive) particle in the dedicated magic particle pool
                    for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                        const p = magicParticlePool[i];
                        if (!p.active) {
                            let spawnX, spawnY;

                            // --- Determine the particle's starting position based on emitter type ---
                            if (emitter.spawnType === 'line') {
                                // Pick a random point along the line using linear interpolation.
                                // A 't' value of 0 is the start of the line, 1 is the end.
                                const t = Math.random(); 
                                spawnX = emitter.x1 + t * (emitter.x2 - emitter.x1);
                                spawnY = emitter.y1 + t * (emitter.y2 - emitter.y1);
                            } else { // Default to 'area' if spawnType is not 'line'
                                spawnX = emitter.x + (Math.random() - 0.5) * emitter.spawnArea.width;
                                spawnY = emitter.y + (Math.random() - 0.5) * emitter.spawnArea.height;
                            }
                            
                            // --- Full Color Variance Logic ---
                            // Take the emitter's base color and add/subtract a random amount from each channel.
                            const r = Math.max(0, Math.min(255, emitter.mainColor[0] + (Math.random() - 0.5) * emitter.colorVariance));
                            const g = Math.max(0, Math.min(255, emitter.mainColor[1] + (Math.random() - 0.5) * emitter.colorVariance));
                            const b = Math.max(0, Math.min(255, emitter.mainColor[2] + (Math.random() - 0.5) * emitter.colorVariance));
                            
                            // --- Activate and configure the particle with all its properties ---
                            p.active = true;
                            p.x = spawnX;
                            p.y = spawnY;
                            p.vx = emitter.particleVelocity.vx.min + Math.random() * (emitter.particleVelocity.vx.max - emitter.particleVelocity.vx.min);
                            p.vy = emitter.particleVelocity.vy.min + Math.random() * (emitter.particleVelocity.vy.max - emitter.particleVelocity.vy.min);
                            p.lifespan = emitter.particleLifespan.min + Math.random() * (emitter.particleLifespan.max - emitter.particleLifespan.min);
                            p.color = [r, g, b];
                            
                            // We've successfully spawned a particle, so we can exit the inner loop.
                            break; 
                        }
                    }
                }
            }
        }

        /**
         * Spawns exhaust particles from the player's feet when levitating.
         * @param {number} count - The number of particles to attempt to spawn this frame.
         */
        function spawnLevitationParticles(count) {
            let spawnedCount = 0;
            // Base position is the center of the player's feet
            const baseX = player.x + player.width / 2;
            const baseY = player.y + player.height - 2; // Start the trail slightly inside the player model

            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) {
                    p.active = true;

                    // Position with slight horizontal randomness for a "cone" shape
                    p.x = baseX + (Math.random() - 0.5) * 4;
                    p.y = baseY + (Math.random() - 0.5) * 2;

                    // Velocity: Shoots downwards and spreads out.
                    // It's also slightly affected by the player's own upward speed to make it "lag behind".
                    p.vx = (Math.random() - 0.5) * 0.5;
                    p.vy = (Math.random() * 0.8) + 0.4 - (player.vy * 0.1);

                    // Color: A blueish-white "magic energy" color with some variance
                    const baseColor = [180, 200, 255];
                    const colorVariance = 40;
                    p.color = [
                        Math.max(0, Math.min(255, baseColor[0] + (Math.random() - 0.5) * colorVariance)),
                        Math.max(0, Math.min(255, baseColor[1] + (Math.random() - 0.5) * colorVariance)),
                        Math.max(0, Math.min(255, baseColor[2] + (Math.random() - 0.5) * colorVariance))
                    ];

                    // Lifespan: Particles last for less than a second
                    p.lifespan = 15 + Math.random() * 20;

                    spawnedCount++;
                    if (spawnedCount >= count) {
                        return; // We've spawned enough particles for this frame
                    }
                }
            }
        }

        /**
         * The main function to create a burst of magic particles at a specific location, using the object pool.
         * @param {number} count - The number of particles to create.
         * @param {number} x - The center X coordinate of the spawn area.
         * @param {number} y - The center Y coordinate of the spawn area.
         * @param {Array<number>} mainColor - The base color as an [R, G, B] array.
         */
        function spawnMagicParticles(count, x, y, mainColor) {
            let spawnedCount = 0;
            // Search the pool for an inactive particle to reuse
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) {
                    // --- Activate and configure the particle ---

                    p.active = true;

                    // 1. Create variance in the spawn position
                    p.x = x + (Math.random() - 0.5) * 20;
                    p.y = y + (Math.random() - 0.5) * 10;

                    // 2. Create the color with a random hue shift from the main color
                    const colorVariance = 60;
                    const r = Math.max(0, Math.min(255, mainColor[0] + (Math.random() - 0.5) * colorVariance));
                    const g = Math.max(0, Math.min(255, mainColor[1] + (Math.random() - 0.5) * colorVariance));
                    const b = Math.max(0, Math.min(255, mainColor[2] + (Math.random() - 0.5) * colorVariance));
                    p.color = [r, g, b];

                    // 3. Particles float upwards with a slight horizontal drift
                    p.vx = (Math.random() - 0.5) * 0.3;
                    p.vy = -0.2 + (Math.random() * -0.4);
                    
                    // 4. They last for about 1-2.5 seconds (at 60fps)
                    p.lifespan = 60 + Math.random() * 90;

                    spawnedCount++;
                    if (spawnedCount >= count) {
                        // We have spawned the requested number of particles, so we can stop searching.
                        return;
                    }
                }
            }
        }

        function updateMagicParticles() {
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) continue;

                p.x += p.vx;
                p.y += p.vy;
                p.lifespan--;

                if (p.lifespan <= 0) {
                    p.active = false;
                }
            }
        }

        /**
         * Helper function to find the most common storable material in a given area.
         * @returns {number|null} The material ID (e.g., MAT.SAND) or null if the area is empty.
         */
        function getDominantMaterialInArea(x, y, width, height) {
            const counts = {};
            let maxCount = 0;
            let dominantMaterial = null;

            for (let iy = y; iy < y + height; iy++) {
                for (let ix = x; ix < x + width; ix++) {
                    const idx = getIdx(ix, iy);
                    if (idx === -1) continue;
                    const type = grid[idx];
                    // Only count materials that can actually be stored/manipulated
                    if (STORABLE_SOLIDS.has(type) || STORABLE_LIQUIDS.has(type)) {
                        counts[type] = (counts[type] || 0) + 1;
                        if (counts[type] > maxCount) {
                            maxCount = counts[type];
                            dominantMaterial = type;
                        }
                    }
                }
            }
            return dominantMaterial;
        }

        /**
         * Manages alchemy jobs by teleporting materials from a manifest
         * to a location above the target cauldron (semicircle geometry).
         */
        function processAlchemyJobs() {
            if (alchemyJobs.length === 0) return;

            const particlesToTeleportThisFrame = 5;

            for (let i = alchemyJobs.length - 1; i >= 0; i--) {
                const job = alchemyJobs[i];
                const target = job.target; // {cx, cy, r}

                for (let j = 0; j < particlesToTeleportThisFrame; j++) {
                    if (job.manifest.length === 0) {
                        alchemyJobs.splice(i, 1);
                        break;
                    }

                    const materialInfo = job.manifest.shift();

                    // Spawn zone ABOVE the rim of the semicircle
                    // Rim is at y = target.cy
                    const rimX = target.cx;
                    const rimY = target.cy;

                    // Spawn within ~60% of bowl width so it falls inside
                    const span = target.r * 0.6;
                    const spawnX = Math.floor(rimX + (Math.random() * 2 - 1) * span);
                    const spawnY = Math.floor(rimY - (30 + Math.random() * 10)); // 5..15 px above rim

                    const spawnIdx = getIdx(spawnX, spawnY);

                    if (spawnIdx !== -1 && grid[spawnIdx] === MAT.EMPTY) {
                        setGrid(spawnIdx, materialInfo.type);
                        activateChunkAt(spawnX, spawnY);
                    } else {
                        // Put it back to try again next frame
                        job.manifest.unshift(materialInfo);
                    }
                }
            }
        }


        // --- THE ALCHEMY REACTION REGISTRY ---
        const ALCHEMY_REACTIONS = {
            'filter_material': {
                name: "Filter Material",
                description: "Moves materials from the left cauldron to the right, based on the sampler.",
                execute: function(station) {
                    console.log("Executing Filter Material reaction!");

                    const filterMaterial = getDominantMaterialInSemicircle(station.sampler);

                    if (filterMaterial === null) {
                        console.log("Sampler is empty. Nothing to filter.");
                        return;
                    }

                    console.log(`Filtering for: ${MATERIAL_NAME[filterMaterial]}`);

                    const source = station.cauldrons.left;
                    const target = station.cauldrons.right;

                    const translationManifest = [];

                    // 1) Build manifest from source semicircle
                    forEachInDownwardSemicircle(source, (x, y, idx) => {
                        if (grid[idx] === filterMaterial) {
                            translationManifest.push({ type: filterMaterial });
                            setGrid(idx, MAT.EMPTY);
                            activateChunkAt(x, y);
                        }
                    });

                    if (translationManifest.length === 0) {
                        console.log("No matching materials found.");
                        return;
                    }

                    // 2) Create job (target is now semicircle geometry)
                    alchemyJobs.push({
                        manifest: translationManifest,
                        target: target
                    });
                }
            },
            'heat_material': {
                name: "Heat Material",
                description: "Heats the material in the left cauldron, causing reactions.",
                execute: function(station) {
                    console.log("Executing Heat Material reaction!");

                    const source = station.cauldrons.left;

                    // Visual effect centered on semicircle
                    spawnMagicParticles(50, source.cx, source.cy + source.r * 0.5, [255, 100, 0]);

                    forEachInDownwardSemicircle(source, (x, y, idx) => {
                        const type = grid[idx];
                        let changed = true;

                        switch (type) {
                            case MAT.SAND:
                                setGrid(idx, MAT.GLASS);
                                break;
                            case MAT.WOOD:
                                setGrid(idx, MAT.FIRE);
                                break;
                            case MAT.OIL:
                                setGrid(idx, MAT.OIL_BURNING);
                                break;
                            case MAT.COAL:
                                setGrid(idx, MAT.COAL_BURNING);
                                break;
                            case MAT.GUNPOWDER:
                                setGrid(idx, MAT.GUNPOWDER_IGNITED);
                                ignitionTimer[idx] = 8 + Math.floor(Math.random() * 6);
                                break;
                            case MAT.WATER:
                                setGrid(idx, MAT.GAS);
                                break;
                            default:
                                changed = false;
                                break;
                        }

                        if (changed) activateChunkAt(x, y);
                    });
                }
            },
            'clear_cauldrons': {
                name: "Clear Cauldrons",
                description: "Clears all materials from both cauldrons and the sampler.",
                execute: function(station) {
                    console.log("Executing Clear Cauldrons reaction!");

                    const areasToClear = [
                        station.cauldrons.left,
                        station.cauldrons.right,
                        station.sampler
                    ];

                    for (const area of areasToClear) {

                        spawnMagicParticles(30, area.cx, area.cy, [200, 200, 255]);

                        forEachInDownwardSemicircle(area, (x, y, idx) => {
                            // don't delete the bowl walls
                            if (grid[idx] !== MAT.ADAMANTIUM && grid[idx] !== MAT.RUNE_WALL) {
                                setGrid(idx, MAT.EMPTY);
                                activateChunkAt(x, y);
                            }
                        });
                    }
                }
            }


            // ... more reactions can be added here ...
        };

        function forEachInDownwardSemicircle(area, fn) {
            const cx = area.cx, cy = area.cy, r = area.r;
            const r2 = r * r;

            const minX = Math.floor(cx - r);
            const maxX = Math.ceil(cx + r);
            const minY = Math.floor(cy);
            const maxY = Math.ceil(cy + r);

            for (let y = minY; y <= maxY; y++) {
                const dy = y - cy;
                const dy2 = dy * dy;
                for (let x = minX; x <= maxX; x++) {
                    const dx = x - cx;
                    if (dx * dx + dy2 <= r2) {
                        const idx = getIdx(x, y);
                        if (idx !== -1) fn(x, y, idx);
                    }
                }
            }
        }

        function getDominantMaterialInSemicircle(area) {
            const counts = new Map();

            forEachInDownwardSemicircle(area, (x, y, idx) => {
                const t = grid[idx];
                // ignore empty and the bowl material itself
                if (t === MAT.EMPTY || t === MAT.ADAMANTIUM || t === MAT.RUNE_WALL) return;
                counts.set(t, (counts.get(t) || 0) + 1);
            });

            let bestType = null;
            let bestCount = 0;
            for (const [t, c] of counts) {
                if (c > bestCount) {
                    bestType = t;
                    bestCount = c;
                }
            }
            return bestType;
        }


        /**
         * Clears a large space and generates the fixed alchemy station with a solid floor.
         */
        function generateAlchemyStation() {
            const stationWidth = 600;
            const stationHeight = 200;
            const startX = 0; 
            const startY = 5;
            const floorY = startY + stationHeight - 20;

            // 1. Carve out a huge, clean room.
            for (let y = startY; y < startY + stationHeight; y++) {
                for (let x = startX; x < startX + stationWidth; x++) {
                    const idx = getIdx(x, y);
                    if (idx !== -1) setGrid(idx, MAT.EMPTY);
                }
            }
            
            // 2. Build the solid Adamantium floor.
            for (let y = floorY; y < startY + stationHeight; y++) {
                for (let x = startX; x < startX + stationWidth; x++) {
                    setGrid(getIdx(x, y), MAT.ADAMANTIUM);
                }
            }

            // NEW: 3. Generate the decorative Runic Slab backdrop.
            const slabHeight = 15;
            const slabWidth = 70;
            const slabY = floorY - slabHeight; // Place it right on top of the floor
            const slabX = startX + 130;
            // We use the Rune Wall material as the base and Adamantium for the inscription
            generateRunicSlab(slabX, slabY, slabWidth, slabHeight, MAT.ADAMANTIUM, MAT.RUNE_WALL);

            // 3. Define the positions for the cauldrons and sampler.
            const leftCauldronX = startX + 260;
            const rightCauldronX = startX + 390;
            const samplerX = startX + 325;
            
            // 4. Create the components.
            // The cauldron's rim will be a few pixels above the main floor, making it protrude.
            const rimHeightAboveFloor = 15;
            const cauldronRimY = floorY - rimHeightAboveFloor;

            const CAULDRON_RADIUS = 32;
            const CAULDRON_THICKNESS = 4;
            const CAULDRON_INNER_R = CAULDRON_RADIUS - CAULDRON_THICKNESS;

            const SAMPLER_RADIUS = 16;
            const SAMPLER_THICKNESS = 4;
            const SAMPLER_INNER_R = SAMPLER_RADIUS - SAMPLER_THICKNESS;

            // Use the new, correct function
            // Left Cauldron
            createCauldron(leftCauldronX, cauldronRimY, CAULDRON_RADIUS, CAULDRON_THICKNESS, MAT.ADAMANTIUM, MAT.RUNE_WALL);
            // Right Cauldron
            createCauldron(rightCauldronX, cauldronRimY, CAULDRON_RADIUS, CAULDRON_THICKNESS, MAT.ADAMANTIUM, MAT.RUNE_WALL);
            // Sampler in the middle
            createCauldron(samplerX, floorY - 10, SAMPLER_RADIUS, SAMPLER_THICKNESS, MAT.ADAMANTIUM, MAT.RUNE_WALL);

            

            const stationGeometry = {
                cauldrons: {
                    left:  { cx: leftCauldronX,  cy: cauldronRimY, r: CAULDRON_INNER_R },
                    right: { cx: rightCauldronX, cy: cauldronRimY, r: CAULDRON_INNER_R }
                },
                sampler: { cx: samplerX, cy: floorY - 10, r: SAMPLER_INNER_R }
            };


            // Create the trigger with our custom onEnter and onLeave logic
            createTrigger({
                x: slabX,
                y: slabY,
                width: slabWidth,
                height: slabHeight,
                onEnter: function(trigger) {
                    // This function is called when the player steps ON the slab.
                    console.log("Player entered the sampler zone.");
                    
                    // Create a special gold-colored emitter on the slab
                    const emitterId = createMagicEmitter({
                        spawnType: 'line',
                        x1: slabX, y1: slabY,
                        x2: slabX + slabWidth, y2: slabY,
                        mainColor: [255, 230, 100], // Gold
                        spawnRate: 0.5 // Spawn a particle every 2 frames on average
                    });
                    
                    // IMPORTANT: Store the ID of the emitter we just created inside the trigger.
                    trigger.associatedData.emitterId = emitterId;
                },
                onLeave: function(trigger) {
                    // This function is called when the player steps OFF the slab.
                    console.log("Player left the sampler zone.");
                    
                    // Use the stored ID to find and remove the correct emitter.
                    if (trigger.associatedData.emitterId != null) {
                        removeMagicEmitter(trigger.associatedData.emitterId);
                        trigger.associatedData.emitterId = null; // Clear the stored ID
                    }
                },
                onInteract: function(trigger) {
                    // This function is called when the player presses "E" inside the zone.
                    console.log("Player INTERACTED with the sampler! Time for alchemy!");
                    isAlchemyUIVisible = true;
                },
                associatedData: {
                    stationGeometry: stationGeometry
                }
            });
        }

        function pointInDownwardSemicircle(px, py, cx, cy, r) {
            if (py < cy) return false;        // only below rim
            const dx = px - cx;
            const dy = py - cy;
            return (dx*dx + dy*dy) <= (r*r);
        }


        /**
         * Creates a hollow, downward-facing cauldron bowl, set into a surface.
         * The outermost 1px layer uses edgeMaterial.
         *
         * @param {number} cx - Center X of cauldron
         * @param {number} rimY - Y coordinate of rim
         * @param {number} radius - Outer radius
         * @param {number} thickness - Wall thickness
         * @param {material} material - Main wall material
         * @param {material} edgeMaterial - Outermost 1px edge material
         */
        function createCauldron(cx, rimY, radius, thickness, material, edgeMaterial) {

            const outerRadiusSq = radius * radius;
            const outerInnerRadius = radius - 1; // 1px outer shell
            const outerInnerRadiusSq = outerInnerRadius * outerInnerRadius;

            const innerRadius = radius - thickness;
            const innerRadiusSq = innerRadius * innerRadius;

            // 1️⃣ Draw solid outer bowl
            for (let dy = 0; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {

                    const distSq = dx * dx + dy * dy;
                    if (distSq <= outerRadiusSq) {

                        const idx = getIdx(cx + dx, rimY + dy);
                        if (idx === -1) continue;

                        // If within 1px of outer radius → edge material
                        if (distSq > outerInnerRadiusSq) {
                            setGrid(idx, edgeMaterial);
                        } else {
                            setGrid(idx, material);
                        }
                    }
                }
            }

            // 2️⃣ Carve hollow interior
            for (let dy = 0; dy < innerRadius; dy++) {
                for (let dx = -innerRadius; dx <= innerRadius; dx++) {

                    if (dx * dx + dy * dy <= innerRadiusSq) {

                        const idx = getIdx(cx + dx, rimY + dy);
                        if (idx !== -1) {
                            setGrid(idx, MAT.EMPTY);
                        }
                    }
                }
            }
        }


        /**
         * Generates caves with Perlin noise, including four thick, unbroken, noisy
         * horizontal bands that separate the world's five layers. Each band uses the
         * wall material of the layer below it.
         */
        function generateCavesWithPerlinNoise(width, height, grid) {
            const scale = 150;
            const depthBiasStrength = 0.1;
            const layerHeight = height / 5;

            const layerWallMaterials = [
                MAT.SANDSTONE_WALL, // Layer 1 (index 0)
                MAT.ROCK_WALL,      // Layer 2 (index 1)
                MAT.VOLCANIC_WALL,  // Layer 3 (index 2)
                MAT.LABYRINTH_WALL, // Layer 4 (index 3)
                MAT.MAGIC_WALL      // Layer 5 (index 4)
            ];
            const GENERATION_TIERS = [
                { material: MAT.COPPER,   threshold: 0.70 },
                { material: MAT.SILVER,   threshold: 0.75 },
                { material: MAT.GOLD,     threshold: 0.85 },
                { material: MAT.PLATINUM, threshold: 0.99 }
            ];
            const octaves = 4;
            const persistence = 0.5;
            const lacunarity = 2;

            // --- Band Configuration ---
            const bandCentersY = [
                layerHeight,      // Between layer 1 and 2
                layerHeight * 2,  // Between layer 2 and 3
                layerHeight * 3,  // Between layer 3 and 4
                layerHeight * 4   // Between layer 4 and 5
            ];
            const bandHalfHeight = 50;
            const bandNoiseFrequency = 0.004;
            const bandNoiseAmplitude = 60;
            // We no longer use a single band material.

            PerlinNoise.seed(12345 * Math.random() + 10000);

            for (let y = 0; y < height; y++) {
                const depthFactor = y / height;
                const currentDepthBias = depthFactor * depthBiasStrength;
                
                const layerIndex = Math.min(layerWallMaterials.length - 1, Math.floor(y / layerHeight));
                const baseWallType = layerWallMaterials[layerIndex];

                for (let x = 0; x < width; x++) {
                    
                    // --- Modified Band Generation Logic ---
                    let isInBand = false;
                    // Use an indexed loop to determine the correct material
                    for (let i = 0; i < bandCentersY.length; i++) {
                        const centerY = bandCentersY[i];
                        // The band material is the wall type of the layer *below* it.
                        // The first band (i=0) uses the wall from layer 2 (index 1).
                        const bandMaterial = layerWallMaterials[i + 1];

                        const noiseOffset = PerlinNoise.noise(x * bandNoiseFrequency, centerY) * bandNoiseAmplitude;
                        const noisyCenterY = centerY + noiseOffset;

                        if (y >= noisyCenterY - bandHalfHeight && y <= noisyCenterY + bandHalfHeight) {
                            setGrid(getIdx(x, y), bandMaterial);
                            isInBand = true;
                            break;
                        }
                    }

                    if (isInBand) {
                        continue;
                    }

                    // --- Existing Cave & Ore Generation Logic ---
                    let totalNoise = 0;
                    let frequency = 1;
                    let amplitude = 1;
                    let maxAmplitude = 0;
                    for (let i = 0; i < octaves; i++) {
                        const noiseValue = (PerlinNoise.noise(x*frequency/scale, y*frequency/scale)+1)/2;
                        totalNoise += noiseValue * amplitude;
                        maxAmplitude += amplitude;
                        amplitude *= persistence;
                        frequency *= lacunarity;
                    }
                    const finalNoise = totalNoise / maxAmplitude;

                    let materialToPlace = MAT.EMPTY;
                    if (finalNoise >= 0.52 - currentDepthBias) {
                        materialToPlace = baseWallType;
                    }
                    for (const tier of GENERATION_TIERS) {
                        if (finalNoise >= tier.threshold - currentDepthBias) {
                            materialToPlace = tier.material;
                        }
                    }
                    if (materialToPlace !== MAT.EMPTY) {
                        setGrid(getIdx(x, y), materialToPlace);
                    }
                }
            }
        }

        /**
         * Takes all potentially active chunks, sorts them by priority (on-screen, then distance to player),
         * and limits the number of off-screen chunks to be processed in a single frame.
         * @returns {void} - This function directly modifies the global activeChunks and pendingActiveChunks variables.
         */
        function prioritizeAndLimitActiveChunks() {
            // 1. Combine newly activated chunks with any that were deferred from the last frame.
            const allChunksToConsider = new Set([...pendingActiveChunks, ...nextActiveChunks]);
            nextActiveChunks.clear(); // Clear for the next simulation step.

            // 2. Separate chunks into on-screen (high priority) and off-screen (lower priority).
            const priorityChunks = new Set();
            const otherChunks = [];
            const camChunkX1 = Math.floor(camera.x / CHUNK_SIZE);
            const camChunkX2 = Math.floor((camera.x + viewWidth) / CHUNK_SIZE);
            const camChunkY1 = Math.floor(camera.y / CHUNK_SIZE);
            const camChunkY2 = Math.floor((camera.y + viewHeight) / CHUNK_SIZE);

            for (const chunk of allChunksToConsider) {
                const cx = chunk.index % chunkWidth;
                const cy = Math.floor(chunk.index / chunkWidth);
                if (cx >= camChunkX1 && cx <= camChunkX2 && cy >= camChunkY1 && cy <= camChunkY2) {
                    priorityChunks.add(chunk);
                } else {
                    otherChunks.push(chunk);
                }
            }

            // 3. Sort the off-screen chunks by their distance to the player (closest first).
            const playerChunkX = Math.floor(player.x / CHUNK_SIZE);
            const playerChunkY = Math.floor(player.y / CHUNK_SIZE);
            otherChunks.sort((a, b) => {
                const aX = a.index % chunkWidth;
                const aY = Math.floor(a.index / chunkWidth);
                const bX = b.index % chunkWidth;
                const bY = Math.floor(b.index / chunkWidth);
                const distA = (aX - playerChunkX)**2 + (aY - playerChunkY)**2;
                const distB = (bX - playerChunkX)**2 + (bY - playerChunkY)**2;
                return distA - distB;
            });
            
            // 4. Create the final processing list for this frame.
            const processingOrder = [...priorityChunks, ...otherChunks];

            // 5. Apply the limit and update the global variables for the simulation.
            const chunksToProcess = processingOrder.slice(0, priorityChunks.size + MAX_CHUNKS_PER_FRAME);
            pendingActiveChunks = processingOrder.slice(priorityChunks.size + MAX_CHUNKS_PER_FRAME);
            activeChunks = new Set(chunksToProcess);
        }

        // --- GAME LOOP ---
        function gameLoop(now = performance.now()) {
            frameCount++;
            framesThisSecond++;
            if (now - lastFpsTime >= 1000) {
                hudFPS = framesThisSecond;
                framesThisSecond = 0;
                lastFpsTime = now;
            }

            const t0 = performance.now();

            if (frameCount % VISIBLE_LIQUID_SCAN_INTERVAL === 0) {
                findAndActivateVisibleLiquidSurfaces();
            }
            prioritizeAndLimitActiveChunks();

            // --- UPDATE LOGIC ---
            updatePlayer();
            updateRigidBodyInteractions();
            updateRigidBodies(now);
            syncPlayerWithBody();

            updateRigidBodyGrid();

            const newBodiesFromSplits = [];

            // Use a reverse loop because we might be marking bodies for removal.
            for (let i = rigidBodies.length - 1; i >= 0; i--) {
                const body = rigidBodies[i];
                if (body.isDestroyed) continue;

                if (body.needsShapeUpdate && (now - body.lastRebuildTime > REBUILD_COOLDOWN)) {

                    const newBodies = checkForSplits(body);
                    
                    if (newBodies && newBodies.length) {
                        newBodiesFromSplits.push(...newBodies);
                        body.needsShapeUpdate = false;
                        body.lastRebuildTime = now;
                    } else {
                        body.rebuildFixtures();
                        body.lastRebuildTime = now;
                    }
                    
                }
            }

            // Add any newly created bodies to the main simulation list.
            if (newBodiesFromSplits.length > 0) {
                rigidBodies.push(...newBodiesFromSplits);
            }

            cleanupDestroyedBodies();

            const worldDynamic = countDynamicBodiesInWorld();
            const wrapperDynamic = rigidBodies.filter(rb => rb.body !== null).length + 1 //player;

            if (worldDynamic !== wrapperDynamic) {
                console.warn(
                    "Mismatch!",
                    "world dynamic =", worldDynamic,
                    "rigidBodies =", wrapperDynamic
                );
                destroyOrphanDynamicBodies();
            }


            updatePouredParticles();
            processAlchemyJobs();
            updateMagicParticles();
            updateMagicEmitters(); 
            updateTriggers();

            // --- NEW PROPAGATING LOCAL LIGHTING ---
            // This BFS will process the initial active chunks and any others connected by visible materials.
            const lightingQueue = [...activeChunks];     // Seed the queue with physics-active chunks
            const processedChunks = new Set(activeChunks); // Keep track of what's been processed this frame

            let head = 0;
            while (head < lightingQueue.length) {
                const chunkToUpdate = lightingQueue[head++];
                const newlyActivatedNeighbors = updateLocalLightingAndFindNeighbors(chunkToUpdate);

                for (const neighbor of newlyActivatedNeighbors) {
                    if (!processedChunks.has(neighbor)) {
                        processedChunks.add(neighbor);
                        lightingQueue.push(neighbor);
                    }
                }
            }

            // if (frameCount % LIGHTING_UPDATE_INTERVAL === 0) {
            //     updateLighting();
            // }

            if (isPouring) {
                pourFromContainer();
            }

            // Add this block to continuously store
            if (isStoring) {
                storeMaterial(mouse.worldX, mouse.worldY);
            }

            // Activate the chunk the mouse is currently interacting with
            if (isDrawing || isPouring || isStoring) {
                activateChunkAt(mouse.worldX, mouse.worldY);
            }

            const t1 = performance.now();
            // --- SIMULATIONS ---
            for (let i = 0; i < SIMULATION_STEPS_PER_FRAME; i++) {
                runWorldSimulationWithChunks(movedWorld);
                if (i === 0) {
                   // These two lines are now only for the player's inventory
                   const pouchSetter = (idx, type) => { if (idx !== -1) pouchGrid[idx] = type; };
                   runSimulationOnSmallGrid(movedPouch, pouchGrid, pouchWidth, pouchHeight, pouchSetter);
                   
                   const flaskSetter = (idx, type) => { if (idx !== -1) flaskGrid[idx] = type; };
                   runSimulationOnSmallGrid(movedFlask, flaskGrid, flaskWidth, flaskHeight, flaskSetter);
                }
            }

            tSimMs = performance.now() - t1;
            
            updateCamera();
            mouse.worldX = Math.floor(camera.x + mouse.x / scale);
            mouse.worldY = Math.floor(camera.y + mouse.y / scale);

            const t2 = performance.now();
            // --- RENDER LOGIC ---
            render();
            renderContainers();
            drawHUD();
            tRenderMs = performance.now() - t2;
            
            if ((frameCount % 2) === 0) { // Update hover material at 30fps
                updateHoverMaterial();
            }

            requestAnimationFrame(gameLoop);

            tOtherMs = performance.now() - t0 - tSimMs - tRenderMs;

            ctx.fillStyle = "white";
            ctx.font = "12px monospace";
            ctx.textAlign = "right";
            ctx.fillText(`simulation: ${tSimMs.toFixed(2)}ms`, renderWidth - 6, renderHeight - 30);
            ctx.fillText(`render: ${tRenderMs.toFixed(2)}ms`, renderWidth - 6, renderHeight - 50);
            ctx.fillText(`other: ${tOtherMs.toFixed(2)}ms`, renderWidth - 6, renderHeight - 70);
            ctx.textAlign = "left";
        }

        function destroyOrphanDynamicBodies() {
            const toDestroy = [];

            for (let b = world.getBodyList(); b; b = b.getNext()) {
                if (b.getType() !== 'dynamic') continue;

                const rb = b.getUserData();
                if (!rb) {
                    // ✅ orphan physics body
                    toDestroy.push(b);
                }
            }

            for (const b of toDestroy) {
                b.setActive(false);
                world.destroyBody(b);
            }

            if (toDestroy.length) {
                console.warn("Destroyed orphan dynamic bodies:", toDestroy.length);
            }
        }


        function countDynamicBodiesInWorld() {
            let count = 0;

            for (let b = world.getBodyList(); b; b = b.getNext()) {
                if (b.getType() === 'dynamic') {
                    count++;
                }
            }

            return count;
        }

        function cleanupDestroyedBodies() {
            const kept = [];

            for (const rb of rigidBodies) {
                if (!rb.isDestroyed) {
                    kept.push(rb);
                    continue;
                }

                // rb is destroyed: remove its physics body if it still exists
                if (rb.body) {
                    rb.body.setUserData(null);
                    rb.body.setActive(false);   // stop collisions immediately
                    world.destroyBody(rb.body); // remove from physics world
                    rb.body = null;             // avoid double-destroy
                }
            }

            rigidBodies = kept;
        }

        function updateUI()
        {
            if ((hudTimer++ & 1) === 0) { // ~30 Hz
                updateHoverMaterial();
            }
            hudFPS = fps;

        }

        function drawHUD() {
            const padding = 6;
            const x = renderWidth - 6;
            const y = 6;

            ctx.imageSmoothingEnabled = false;
            ctx.font = '12px monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(
                renderWidth - 150,
                4,
                146,
                34
            );

            // Text
            ctx.fillStyle = '#00ff90';
            ctx.fillText(`FPS: ${hudFPS}`, x, y);

            ctx.fillStyle = '#ffd966';
            ctx.fillText(`MAT: ${hudMaterial}`, x, y + 14);
        }

        /**
         * Creates a new trigger zone and adds it to the world.
         * @param {object} options - Configuration for the trigger.
         * @returns {number} The unique ID of the trigger.
         */
        function createTrigger(options) {
            const trigger = {
                id: nextTriggerId++,
                x: options.x,
                y: options.y,
                width: options.width,
                height: options.height,
                onEnter: options.onEnter || function() {}, // What to do when player enters
                onLeave: options.onLeave || function() {}, // What to do when player leaves
                onInteract: options.onInteract || function() {},
                isActive: false, // Tracks if the player is currently inside
                // A generic object to store any data this trigger needs to remember, like an emitter ID.
                associatedData: options.associatedData 
            };
            triggers.push(trigger);
            return trigger.id;
        }

        /**
         * Checks the player's position against all triggers and manages interaction state.
         * Now includes a vertical leeway to work correctly with the Box2D physics engine.
         */
        function updateTriggers() {
            const playerCheckX = player.x + player.width / 2;
            const playerCheckY = player.y + player.height;
            
            // NEW: A small tolerance to detect "standing on" a trigger in a physics world.
            const verticalLeeway = 2; // 2 pixels

            let canCurrentlyInteract = false;
            let activeTrigger = null;

            for (const trigger of triggers) {
                const isPlayerInside = (
                    playerCheckX >= trigger.x &&
                    playerCheckX <= trigger.x + trigger.width &&
                    // CORRECTED CHECK: Allow player's feet to be slightly *above* the trigger's top edge.
                    playerCheckY >= trigger.y - verticalLeeway && 
                    playerCheckY <= trigger.y + trigger.height
                );

                if (isPlayerInside) {
                    canCurrentlyInteract = true;
                    activeTrigger = trigger;

                    if (!trigger.isActive) {
                        trigger.isActive = true;
                        trigger.onEnter(trigger);
                    }
                } else {
                    if (trigger.isActive) {
                        trigger.isActive = false;
                        trigger.onLeave(trigger);
                    }
                }
            }

            player.canInteract = canCurrentlyInteract;
            player.currentTrigger = activeTrigger;
        }

        /**
         * Renders the alchemy reaction selection UI when it's active.
         */
        function renderAlchemyUI() {
            if (!isAlchemyUIVisible) return;

            // Draw a semi-transparent background to dim the game
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, renderWidth, renderHeight);

            // Draw the main UI box
            const boxWidth = 300;
            const boxHeight = 150;
            const boxX = (renderWidth - boxWidth) / 2;
            const boxY = (renderHeight - boxHeight) / 2;
            ctx.fillStyle = '#222';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeStyle = '#888';
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

            // Draw text
            ctx.fillStyle = 'white';
            ctx.font = '16px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText("Select a Reaction:", boxX + 10, boxY + 10);

            // List all available reactions from our registry
            let yOffset = 40;
            let reactionIndex = 1;
            for (const key in ALCHEMY_REACTIONS) {
                const reaction = ALCHEMY_REACTIONS[key];
                ctx.fillText(`[${reactionIndex}] ${reaction.name}`, boxX + 20, boxY + yOffset);
                yOffset += 20;
                reactionIndex++;
            }

            ctx.fillStyle = '#aaa';
            ctx.fillText("Press [ESC] to close.", boxX + 10, boxY + boxHeight - 25);
        }

        /**
         * Updates the text content of the loading screen overlay.
         * @param {string} message - The message to display.
         */
        function updateLoadingStatus(message) {
            document.getElementById('loading-status').innerText = message;
        }

        async function mainLoader() {
            const loadingOverlay = document.getElementById('loading-overlay');
            const yieldToBrowser = () => new Promise(resolve => setTimeout(resolve, 20));

            updateLoadingStatus('Structuring World...');
            await yieldToBrowser();
            createChunkGrid();

            updateLoadingStatus('Carving Background Strata...');
            await yieldToBrowser();
            skyImageData = generateCaveBackground(worldWidth, worldHeight);

            updateLoadingStatus('Generating Perlin Caves...');
            await yieldToBrowser();
            generateCavesWithPerlinNoise(worldWidth, worldHeight, grid);

            updateLoadingStatus('Constructing Ancient Structures...');
            await yieldToBrowser();
            generateAlchemyStation();

            updateLoadingStatus('Securing World Borders...');
            await yieldToBrowser();
            for (let y = 0; y < worldHeight; y++) {
                setGrid(getIdx(0, y), MAT.ADAMANTIUM);
                setGrid(getIdx(1, y), MAT.ADAMANTIUM);
                setGrid(getIdx(worldWidth - 1, y), MAT.ADAMANTIUM);
                setGrid(getIdx(worldWidth - 2, y), MAT.ADAMANTIUM);
            }
             for (let x = 0; x < worldWidth; x++) {
                setGrid(getIdx(x, 0), MAT.ADAMANTIUM);
                setGrid(getIdx(x, 1), MAT.ADAMANTIUM);
                setGrid(getIdx(x, worldHeight - 1), MAT.ADAMANTIUM);
                setGrid(getIdx(x, worldHeight - 2), MAT.ADAMANTIUM);
            }

            updateLoadingStatus('Activating Dynamic Matter...');
            await yieldToBrowser();
            activateInitialChunks();

            updateLoadingStatus('Igniting the First Light...');
            await yieldToBrowser();
            updateLighting(true);

            createPlayerBody(); 
            createWoodenBox(450, 150, 24, 64);
            createWoodenBox(450 + 128, 150, 24, 64);
            createWoodenBox(450 + 64, 50, 128, 16);

            updateLoadingStatus('Done!');
            await new Promise(resolve => setTimeout(resolve, 100));

            loadingOverlay.style.transition = 'opacity 0.5s';
            loadingOverlay.style.opacity = '0';
            await new Promise(resolve => setTimeout(() => {
                loadingOverlay.style.display = 'none';
                resolve();
            }, 500));
            
            // The game loop will now be started from the new entry point.
            gameLoop();
        }

        function drawPhysicsOutlines() {
            ctx.save();
            ctx.lineWidth = 1;

            for (let body = world.getBodyList(); body; body = body.getNext()) {

                const type = body.getType();

                if (type === 'dynamic') {
                    ctx.strokeStyle = 'lime';
                } else if (type === 'static') {
                    ctx.strokeStyle = 'red';
                } else {
                    continue; // skip kinematic if you want
                }

                for (let fixture = body.getFixtureList(); fixture; fixture = fixture.getNext()) {
                    const shape = fixture.getShape();

                    if (shape.getType() === 'polygon') {
                        const vertices = shape.m_vertices;

                        ctx.beginPath();

                        for (let i = 0; i < vertices.length; i++) {
                            const worldPoint = body.getWorldPoint(vertices[i]);
                            const px = worldPoint.x * B2_SCALE - camera.x;
                            const py = worldPoint.y * B2_SCALE - camera.y;

                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }

                        ctx.closePath();
                        ctx.stroke();
                    }

                    else if (shape.getType() === 'circle') {
                        const center = body.getWorldPoint(shape.m_p);
                        const radius = shape.m_radius * B2_SCALE;

                        ctx.beginPath();
                        ctx.arc(
                            center.x * B2_SCALE,
                            center.y * B2_SCALE,
                            radius,
                            0,
                            Math.PI * 2
                        );
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }



        function drawBodyFixtures(body) {

            for (let fixture = body.getFixtureList(); fixture; fixture = fixture.getNext()) {
                drawFixture(body, fixture);
            }
        }


        function drawFixture(body, fixture) {

            const shape = fixture.getShape();

            if (shape.getType() !== 'polygon') return;

            const vertices = shape.m_vertices; // local-space vertices
            const vertexCount = vertices.length;

            ctx.beginPath();

            for (let i = 0; i < vertexCount; i++) {

                const worldPoint = body.getWorldPoint(vertices[i]);

                const screenX = Math.floor(worldPoint.x * B2_SCALE - camera.x);
                const screenY = Math.floor(worldPoint.y * B2_SCALE - camera.y);

                if (i === 0) ctx.moveTo(screenX, screenY);
                else ctx.lineTo(screenX, screenY);
            }

            ctx.closePath();
            ctx.stroke();
        }

        /**
         * Renders the player's HP and Hover Energy bars in the top-left corner of the canvas.
         */
        function renderPlayerStatsUI() {
            const barWidth = 150;
            const barHeight = 10;
            const x = 15;
            let y = 15; // Starting Y position

            ctx.imageSmoothingEnabled = false;

            // --- HP Bar ---
            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Fill
            const hpPercent = player.hp / player.maxHp;
            ctx.fillStyle = '#d14242'; // Red for health
            ctx.fillRect(x, y, barWidth * hpPercent, barHeight);

            // Text Label
            ctx.fillStyle = 'white';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${player.hp}/${player.maxHp}`, x + barWidth / 2, y + barHeight / 2);

            // --- Hover Energy Bar ---
            y += barHeight + 5; // Move down for the next bar

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barWidth, barHeight);

            // Fill
            const energyPercent = player.hoverEnergy / player.maxHoverEnergy;
            ctx.fillStyle = '#DDED64';
            ctx.fillRect(x, y, barWidth * energyPercent, barHeight);
            
            // Text Label
            ctx.fillStyle = 'white';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${Math.round(player.hoverEnergy)}/${player.maxHoverEnergy}`, x + barWidth / 2, y + barHeight / 2);
        }

        // Draws a rectangle outline for each active chunk.
        // Call at the end of render() (after world is drawn), every frame.
        function debugDrawActiveChunks(activeChunks) {
            if (!activeChunks || activeChunks.size === 0) return;
            console.log(activeChunks.size);

            ctx.save();
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.9;

            // Bright visible outline (no fill)
            ctx.strokeStyle = "rgba(255,255,255,0.9)";

            // Helps crisp 1px lines on pixel art canvas
            const camX = camera.x | 0;
            const camY = camera.y | 0;

            for (const ch of activeChunks) {
                let cx, cy;

                const chunkX = ch.index % chunkWidth;
                const chunkY = Math.floor(ch.index / chunkWidth);
                const startX = chunkX * CHUNK_SIZE;
                const startY = chunkY * CHUNK_SIZE;

                ctx.strokeRect(startX - camX, startY - camY, CHUNK_SIZE, CHUNK_SIZE);
            }

            ctx.restore();
        }


        function generateStaticBodyForChunk(chunk) {

            const body = world.createBody({
                type: 'static'
            });

            chunk.fixtureCount = 0;

            const startX = (chunk.index % chunkWidth) * CHUNK_SIZE;
            const startY = Math.floor(chunk.index / chunkWidth) * CHUNK_SIZE;

            // Build mask for this chunk
            const mask = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE);

            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {

                    const worldX = startX + x;
                    const worldY = startY + y;
                    const idx = getIdx(worldX, worldY);

                    mask[y * CHUNK_SIZE + x] =
                        isSolidForPlayer(grid[idx]) &&
                        rigidBodyGrid[idx] !== 1 ? 1 : 0;
                }
            }

            // Extract islands inside chunk
            const islands = extractIslands(mask, CHUNK_SIZE, CHUNK_SIZE);

            for (const island of islands) {

                const outline = marchingSquares(island, CHUNK_SIZE, CHUNK_SIZE);
                if (outline.length < 3) continue;

                // Estimate size of the outline in pixels
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of outline) {
                if (p.x < minX) minX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.x > maxX) maxX = p.x;
                if (p.y > maxY) maxY = p.y;
                }
                const extent = Math.max(maxX - minX, maxY - minY);

                // For small features, simplify MUCH less
                const DP_EPS = extent < 12 ? 0.25 : extent < 24 ? 0.5 : 1.0;
                const COL_EPS = extent < 12 ? 0.001 : extent < 24 ? 0.003 : 0.01;

                const simplifiedPre = simplifyDouglasPeucker(outline, 0.2);
                if (simplifiedPre.length < 3) continue;

                const simplified = removeCollinear(simplifiedPre, 0.001);
                if (simplified.length < 3) continue;

                validatePolygon(simplified);

                const flat = [];
                for (const p of simplified) {
                    flat.push(p.x, p.y);
                }

                const indices = earcut(flat);

                for (let i = 0; i < indices.length; i += 3) {

                    const p0 = simplified[indices[i]];
                    const p1 = simplified[indices[i + 1]];
                    const p2 = simplified[indices[i + 2]];

                    const ax = (startX + p0.x) / B2_SCALE;
                    const ay = (startY + p0.y) / B2_SCALE;

                    const bx = (startX + p1.x) / B2_SCALE;
                    const by = (startY + p1.y) / B2_SCALE;

                    const cx = (startX + p2.x) / B2_SCALE;
                    const cy = (startY + p2.y) / B2_SCALE;

                    body.createFixture(
                        pl.Polygon([
                            pl.Vec2(ax, ay),
                            pl.Vec2(bx, by),
                            pl.Vec2(cx, cy)
                        ])
                    );

                    chunk.fixtureCount++;
                }
            }

            body.setActive(false);
            return body;
        }




        /**
         * High-performance collider update (Planck version).
         * Activates/deactivates chunk bodies and throttles regeneration.
         * @param {number} now - performance.now()
         */
        function updateWorldColliders(now) {

            const neededChunks = new Set();
            const lookahead = 1;

            const allDynamicBodies = [...rigidBodies, player];

            // 1️⃣ Determine which terrain chunks are needed
            for (const bodyObject of allDynamicBodies) {

                if (!bodyObject.body) continue;

                const body = bodyObject.body;

                let combinedAABB = null;

                for (let fixture = body.getFixtureList(); fixture; fixture = fixture.getNext()) {

                    const aabb = fixture.getAABB(0);

                    if (!combinedAABB) {
                        combinedAABB = {
                            lowerX: aabb.lowerBound.x,
                            lowerY: aabb.lowerBound.y,
                            upperX: aabb.upperBound.x,
                            upperY: aabb.upperBound.y
                        };
                    } else {
                        combinedAABB.lowerX = Math.min(combinedAABB.lowerX, aabb.lowerBound.x);
                        combinedAABB.lowerY = Math.min(combinedAABB.lowerY, aabb.lowerBound.y);
                        combinedAABB.upperX = Math.max(combinedAABB.upperX, aabb.upperBound.x);
                        combinedAABB.upperY = Math.max(combinedAABB.upperY, aabb.upperBound.y);
                    }
                }

                if (!combinedAABB) continue;

                const minChunkX = Math.floor(combinedAABB.lowerX * B2_SCALE / CHUNK_SIZE) - lookahead;
                const maxChunkX = Math.ceil(combinedAABB.upperX * B2_SCALE / CHUNK_SIZE) + lookahead;
                const minChunkY = Math.floor(combinedAABB.lowerY * B2_SCALE / CHUNK_SIZE) - lookahead;
                const maxChunkY = Math.ceil(combinedAABB.upperY * B2_SCALE / CHUNK_SIZE) + lookahead;

                for (let cy = minChunkY; cy <= maxChunkY; cy++) {
                    for (let cx = minChunkX; cx <= maxChunkX; cx++) {

                        if (
                            cx >= 0 && cx < chunkWidth &&
                            cy >= 0 && cy < chunkHeight
                        ) {
                            neededChunks.add(chunkGrid[cy * chunkWidth + cx]);
                        }
                    }
                }
            }


            // 2️⃣ Deactivate chunks no longer needed
            for (const chunk of activeStaticChunks) {

                if (!neededChunks.has(chunk) && chunk.staticBody) {
                    chunk.staticBody.setActive(false);
                }
            }

            // 3️⃣ Activate / Regenerate newly needed chunks
            for (const chunk of neededChunks) {

                // --- Throttled regeneration ---
                if (chunk.dirty && chunk.staticBody) {

                    if (now - chunk.lastRegenTime > REGEN_COOLDOWN) {

                        world.destroyBody(chunk.staticBody);
                        chunk.staticBody = null;
                        chunk.fixtureCount = 0;

                    } else {
                        // Still in cooldown → keep dirty but don't regen yet
                    }
                }

                // Create body if needed
                if (!chunk.staticBody) {

                    chunk.staticBody = generateStaticBodyForChunk(chunk);

                    chunk.dirty = false;
                    chunk.lastRegenTime = now;
                }

                chunk.staticBody.setActive(true);
            }

            activeStaticChunks = neededChunks;
        }


        function updateRigidBodies(now) {
            // First, update the terrain colliders based on the current state of the world
            updateWorldColliders(now);

            world.step(1/60);
        }

       
        function transformPoint(out, transform, localPoint) {
            const p = transform.get_p();
            const q = transform.get_q();

            const localX = localPoint.get_x();
            const localY = localPoint.get_y();

            const rotatedX = localX * q.get_c() - localY * q.get_s();
            const rotatedY = localX * q.get_s() + localY * q.get_c();

            out.set_x(rotatedX + p.get_x());
            out.set_y(rotatedY + p.get_y());
        }

        //mainLoader();

        // --- NEW, CORRECT GAME ENTRY POINT ---

        // This ensures the page is loaded before we try to run anything.
        window.onload = function() {
            const loadingStatus = document.getElementById('loading-status');
            loadingStatus.innerText = 'Loading Physics Engine...';
            
            

            // With physics ready, proceed to load the rest of the game.
            mainLoader();

        };
    </script>
</body>
</html>