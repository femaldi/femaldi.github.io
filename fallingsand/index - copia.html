<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Sand Platformer</title>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            user-select: none;
            overflow: hidden;
        }
        h1 { margin-bottom: 10px; }
        .controls {
            margin-bottom: 10px;
            background: #333;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        .btn-sand { background-color: #f6d7b0; color: #333; }
        .btn-water { background-color: #4fa4f4; color: white; }
        .btn-soil { background-color: #5d4037; color: white; }
        .btn-wall { background-color: #888; color: white; }
        .btn-gas { background-color: #e0e0e0; color: #333; }
        .btn-fire { background-color: #ff4500; color: white; }
        .btn-oil {
            background-color: #5a4622;
            color: #fff;
        }
        .btn-coal {
            background-color: #111111;
            color: #fff;
        }
        .btn-wood { background-color: #8b4513; color: white; }
        .btn-gunpowder { background-color: #444; color: #fff; border: 1px solid #777; }
        .btn-acid { background-color: #00ff00; color: white; }
        .btn-glass { background-color: #e0e0ff; color: #333; }
        .btn-glass-wall { background-color: #b4b4e0; color: #333; }
        .btn-adamantium { background-color: #4d5257; color: white; border: 1px solid #aeb5be; }
        .btn-copper { background-color: #b87333; color: white; }
        .btn-silver { background-color: #c0c0c0; color: #333; }
        .btn-gold { background-color: #ffd700; color: #333; }
        .btn-platinum { background-color: #e5e4e2; color: #333; }
        .btn-rune-wall { background-color: #2a2a3a; color: #d0c0ff; border: 1px solid #5a4a7a; }
        .btn-eraser { background-color: #000; color: white; border: 1px solid #555; }
        button.active {
            outline: 2px solid white;
            box-shadow: 0 0 8px rgba(255,255,255,0.6);
        }
        .info-bar { font-size: 14px; color: #ccc; }
        .info-bar strong { color: white; }
        canvas {
            border: 2px solid #555;
            background-color: #000;
            cursor: crosshair;
            image-rendering: pixelated; 
        }
        #controls_ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 8px 10px;
            border-radius: 6px;
            pointer-events: none;
        }
    </style>
</head>
<body>
   <div id="loading-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a2a; color: #fff; z-index: 1000; display: flex; justify-content: center; align-items: center; flex-direction: column;">
        <h1 style="font-size: 2.5em; margin-bottom: 20px;">Falling Sand Platformer</h1>
        <p id="loading-status" style="font-size: 1.2em; font-family: monospace;">Initializing...</p>
    </div>

    <h1>Falling Sand Platformer</h1>
    <div class="info-bar">
        Use <strong>A/D</strong> to Move, <strong>W</strong> to Jump. Use the mouse to build and destroy.
    </div>

    <div class="controls">
        <button class="btn-sand active" onclick="setMaterial('sand')">Sand</button>
        <button class="btn-soil" onclick="setMaterial('soil')">Soil</button>
        <button class="btn-water" onclick="setMaterial('water')">Water</button>
        <button class="btn-gas" onclick="setMaterial('gas')">Gas</button>
        <button class="btn-wall" onclick="setMaterial('wall')">Wall</button>
        <button class="btn-wood" onclick="setMaterial('wood')">Wood</button>
        <button class="btn-fire" onclick="setMaterial('fire')">Fire</button>
        <button class="btn-gunpowder" onclick="setMaterial('gunpowder')">Gunpowder</button>
        <button class="btn-oil" onclick="setMaterial('oil')">Oil</button>
        <button class="btn-coal" onclick="setMaterial('coal')">Coal</button>
        <button class="btn-acid" onclick="setMaterial('acid')">Acid</button>
        <button class="btn-glass" onclick="setMaterial('glass')">Glass</button>
        <button class="btn-glass-wall" onclick="setMaterial('glass-wall')">Glass Wall</button>
        <button class="btn-adamantium" onclick="setMaterial('adamantium')">Adamantium</button>
        <button class="btn-copper" onclick="setMaterial('copper')">Copper</button>
        <button class="btn-silver" onclick="setMaterial('silver')">Silver</button>
        <button class="btn-gold" onclick="setMaterial('gold')">Gold</button>
        <button class="btn-platinum" onclick="setMaterial('platinum')">Platinum</button>
        <button class="btn-rune-wall" onclick="setMaterial('rune-wall')">Rune Wall</button>
        <button class="btn-eraser" onclick="setMaterial('empty')">Eraser</button>
    </div>

    <div id="controls_ui">
        <b>Controls</b><br>
        A / D – Move<br>
        W – Jump<br>
        Q – Switch Container<br>
        Left Click – Pour<br>
        Right Click – Store<br>
        Middle Click – Paint Brush
    </div>

    <canvas id="canvas"></canvas>

    <script>
        var Module = { TOTAL_MEMORY: 256*1024*1024 };
    </script>
    <script src="https://kripken.github.io/box2d.js/demo/webgl/Box2D_v2.2.1_min.js"></script>

    <script>
        // --- CONFIGURATION ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const B2_SCALE = 30; // 30 pixels = 1 meter in the physics world
        let box2d;
        let box2dWorld;
        let rigidBodies = [];
        let staticWorldBodies = []; // To hold temporary terrain colliders
        let activeStaticChunks = new Set();
        let bodiesToDestroy = [];   // NEW: A "kill list" for entire b2Bodies
        let tempVec1 = null;
        let tempVec2 = null;

        // Box2D Aliases for easier access
        let b2Vec2;
        let b2BodyDef;
        let b2Body;
        let b2FixtureDef;
        let b2World;
        let b2PolygonShape;

        const CHUNK_SIZE = 16; // Chunks will be 16x16 pixels
        let chunkWidth, chunkHeight;
        let chunkGrid; // This will hold state for each chunk
        let activeChunks = new Set(); // A set of active chunk indices for the current frame
        let nextActiveChunks = new Set(); // A set of chunks to activate for the *next* frame


        // NEW: Increased view area and reduced scale
        const viewWidth = 600;
        const viewHeight = 400;
        const scale = 2; // Smaller pixels

        const SIMULATION_STEPS_PER_FRAME = 2;

        // canvas.width = viewWidth * scale; // Same canvas size: 300*4 = 1200
        // canvas.height = viewHeight * scale; // Same canvas size: 200*4 = 800
        canvas.width = viewWidth;
        canvas.height = viewHeight;

        canvas.style.width = viewWidth * scale + "px";
        canvas.style.height = viewHeight * scale + "px";

        canvas.style.imageRendering = "pixelated";


        const worldWidth = viewWidth * 15;
        const worldHeight = viewHeight * 10;

        const renderWidth = viewWidth;
        const renderHeight = viewHeight;

        const imageData = ctx.createImageData(renderWidth, renderHeight);
        const pixels = imageData.data; // Uint8ClampedArray

        // --- MATERIAL DEFINITIONS ---
        const MAT = {
            EMPTY: 0, ROCK_WALL: 1, SAND: 2, WATER: 3, SOIL: 4, GAS: 5, 
            WOOD: 10, FIRE: 11, GUNPOWDER: 12, GUNPOWDER_IGNITED: 13,
            OIL: 14, OIL_BURNING: 15,
            COAL:16, COAL_BURNING:17,
            ACID:18, GLASS:19, GLASS_WALL: 20,
            ADAMANTIUM: 21, COPPER: 22, SILVER: 23, GOLD: 24, PLATINUM: 25, RUNE_WALL: 26,
            SANDSTONE_WALL: 27, VOLCANIC_WALL: 28, LABYRINTH_WALL: 29, MAGIC_WALL: 30,
            RIGID_BODY_STUB: 99
        };

        const COLORS = {
            [MAT.ROCK_WALL]: [100, 100, 100], [MAT.SAND]: [246, 215, 176],
            [MAT.WATER]: [79, 164, 244], [MAT.SOIL]: [93, 64, 55],
            [MAT.GAS]: [200, 200, 200], [MAT.WOOD]: [139, 69, 19],
            [MAT.FIRE]: [255, 69, 0], [MAT.GUNPOWDER]: [60, 60, 60],
            [MAT.GUNPOWDER_IGNITED]: [120, 80, 80], [MAT.OIL]: [90, 70, 30], [MAT.OIL_BURNING]: [255, 69, 0],
            [MAT.COAL]: [30, 30, 30], [MAT.COAL_BURNING]: [255, 69, 0],
            [MAT.ACID]: [0, 255, 0], [MAT.GLASS]: [200, 200, 255], [MAT.GLASS_WALL]: [180, 180, 235],
            [MAT.ADAMANTIUM]: [77, 82, 87], [MAT.COPPER]: [184, 115, 51],
            [MAT.SILVER]: [192, 192, 192], [MAT.GOLD]: [255, 215, 0],
            [MAT.PLATINUM]: [229, 228, 226], [MAT.RUNE_WALL]: [200, 200, 100],
            [MAT.SANDSTONE_WALL]: [130, 100, 70],
            [MAT.VOLCANIC_WALL]: [45, 20, 20],
            [MAT.LABYRINTH_WALL]: [70, 75, 80],
            [MAT.MAGIC_WALL]: [40, 25, 60]
        };

        const MATERIAL_NAME = {
            [MAT.EMPTY]: 'Empty',
            [MAT.ROCK_WALL]: 'Wall',
            [MAT.SAND]: 'Sand',
            [MAT.WATER]: 'Water',
            [MAT.SOIL]: 'Soil',
            [MAT.GAS]: 'Gas',
            [MAT.WOOD]: 'Wood',
            [MAT.FIRE]: 'Fire',
            [MAT.GUNPOWDER]: 'Gunpowder',
            [MAT.GUNPOWDER_IGNITED]: 'Gunpowder (Ignited)',
            [MAT.OIL]: 'Oil',
            [MAT.OIL_BURNING]: 'Burning Oil',
            [MAT.COAL]: 'Coal',
            [MAT.COAL_BURNING]: 'Burning Coal',
            [MAT.ACID]: 'Acid',
            [MAT.GLASS]: 'Glass',
            [MAT.GLASS_WALL]: 'Glass Wall',
            [MAT.ADAMANTIUM]: 'Adamantium', 
            [MAT.COPPER]: 'Copper',
            [MAT.SILVER]: 'Silver', 
            [MAT.GOLD]: 'Gold', 
            [MAT.PLATINUM]: 'Platinum',
            [MAT.RUNE_WALL]: 'Rune Wall',
            [MAT.SANDSTONE_WALL]: 'Sandstone Wall', 
            [MAT.VOLCANIC_WALL]: 'Volcanic Wall',
            [MAT.LABYRINTH_WALL]: 'Labyrinth Wall', 
            [MAT.MAGIC_WALL]: 'Magic Wall'
        };

        const WALL_TYPES = new Set([
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, 
            MAT.LABYRINTH_WALL, MAT.MAGIC_WALL
        ]);

        // --- RUNE DEFINITIONS ---
        // A library of rune patterns. 1 represents the rune material, 0 is empty.
        const DWARVEN_RUNES = {
            // A simple 7x9 pixel font for the runes
            RUNE_WIDTH: 7,
            RUNE_HEIGHT: 9,
            PATTERNS: [
                // "Axe"
                [
                    [0,1,1,1,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,0,1,1,0]
                ],
                // "Hammer"
                [
                    [1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0]
                ],
                // "Shield"
                [
                    [1,1,1,1,1,1,1],
                    [1,0,0,1,0,0,1],
                    [1,0,0,1,0,0,1],
                    [1,1,1,1,1,1,1],
                    [0,0,1,1,1,0,0],
                    [0,0,1,1,1,0,0],
                    [1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1]
                ],
                // "Spear"
                [
                    [0,0,0,1,0,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,1,1,1,1,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ],
                // "Pickaxe"
                [
                    [1,1,0,0,0,1,1],
                    [0,1,1,0,1,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,0,0,0]
                ]
            ]
        };


        const LIQUID_DENSITY = {
            [MAT.ACID]: 3,
            [MAT.WATER]: 2,
            [MAT.OIL]: 1,
            [MAT.OIL_BURNING]: 1
        };

        const ALWAYS_VISIBLE_MATERIALS = new Set([
            MAT.RUNE_WALL,
            MAT.ADAMANTIUM // Also used for the alchemy station and world borders
        ]);

        const SHIMMERING_METALS = new Set([
            MAT.ADAMANTIUM,
            MAT.COPPER,
            MAT.SILVER,
            MAT.GOLD,
            MAT.PLATINUM,
            MAT.RUNE_WALL
        ]);

        const STATIC_MATERIALS = new Set([
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, MAT.LABYRINTH_WALL, MAT.MAGIC_WALL, // All walls added
            MAT.WOOD,
            MAT.GLASS_WALL,
            MAT.ADAMANTIUM,
            MAT.RUNE_WALL
        ]);


        const MAX_STEP_HEIGHT = 2;
        const GRAVITY = 0.1;
        const MAX_FALL_SPEED = 4;
        const MAX_HOVER_SPEED = 4;

        const MAX_CHUNKS_PER_FRAME = 250;
        const REGEN_COOLDOWN = 250;
        const REBUILD_COOLDOWN = 250;
        const MIN_ISLAND_PIXELS = 5; // Max number of off-screen chunks to process per frame. On-screen chunks are always processed.
        let pendingActiveChunks = []; // An array to hold active chunks that were deferred from the previous frame.
        
        let grid = new Uint8Array(worldWidth * worldHeight).fill(MAT.EMPTY);
        let rigidBodyGrid = new Uint8Array(worldWidth * worldHeight);
        let ignitionTimer = new Uint8Array(worldWidth * worldHeight);
        let currentMaterial = MAT.SAND;
        let isDrawing = false;
        let isStoring = false;
        let frameCount = 0;
        let playerFacingRight = true;
		let projectiles = [];
        let alchemyJobs = [];

        let lightGrid = new Uint8Array(worldWidth * worldHeight).fill(0); // 0 = black, 15 = brightest
        const MAX_LIGHT_LEVEL = 30;
        const LIGHTING_UPDATE_INTERVAL = 30;
        const VISIBLE_LIQUID_SCAN_INTERVAL = 5; // Update lighting every 30 frames

        const MAX_VISIBLE_DISTANCE = 8;

        // --- Magic Particle System ---
        const MAX_MAGIC_PARTICLES = 5000;
        const magicParticlePool = [];
        for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
            magicParticlePool.push({ x: 0, y: 0, vx: 0, vy: 0, lifespan: 0, color: [0,0,0], active: false });
        }

        let magicEmitters = [];
        let nextEmitterId = 0;
        let firePixelsCoords = [];
        let triggers = [];
        let nextTriggerId = 0;
        let isAlchemyUIVisible = false;

        let lastFpsTime = performance.now();
        let framesThisSecond = 0;
        let fps = 0;
        let leftToRight = true;

        let hudFPS = 0;
        let hudMaterial = '--';
        let hudTimer = 0;

        let skyImageData = null;

        // --- INVENTORY AND CONTAINERS ---
        const pouchWidth = 32;
        const pouchHeight = 32;
        const flaskWidth = 24;
        const flaskHeight = 40;

        let pouchGrid = new Array(pouchWidth * pouchHeight).fill(MAT.EMPTY);
        let flaskGrid = new Array(flaskWidth * flaskHeight).fill(MAT.EMPTY);

        let activeContainer = 'pouch'; // 'pouch' or 'flask'
        let isPouring = false;
        let pourCooldown = 0;
        let pouredParticles = []; // For the pouring stream effect
        let activeStubs = [];

        const STORABLE_SOLIDS = new Set([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM]);
        const STORABLE_LIQUIDS = new Set([MAT.WATER, MAT.OIL, MAT.ACID]);

        class RigidBody {
            constructor(x, y, width, height, material) {
                this.width = width;
                this.height = height;
                this.pixels = new Uint8Array(width * height);
                this.moved = new Uint8Array(width * height);
                this.materialType = material;
                this.fixtureCount = 0;
                
                this.isDestroyed = false;
                this.needsShapeUpdate = false;
                this.lastRebuildTime = 0;
                this.isSplit = false;

                this.pixels.fill(this.materialType);

                // --- Create the Box2D Body ---
                const bodyDef = new b2BodyDef();
                bodyDef.set_type(box2d.b2_dynamicBody);
                const position = new b2Vec2(x / B2_SCALE, y / B2_SCALE);
                bodyDef.set_position(position);

                this.b2Body = box2dWorld.CreateBody(bodyDef);
                
                // CORRECTED: Call the safe creation function, NOT rebuild.
                this._createFixturesFromPixels(); 
            }

            rebuildFixtures() {
                // --- YOUR CORRECTED LOGIC ---
                // Loop a known, finite number of times, destroying the head of the list each time.
                // This is immune to any iterator or GetNext() bugs.
                for (let i = 0; i < this.fixtureCount; i++) {
                    const fixture = this.b2Body.GetFixtureList();
                    if (fixture) {
                        //console.log(fixture)
                        this.b2Body.DestroyFixture(fixture);
                    } else {
                        // This is a safety break in case the count is somehow wrong.
                        // It should not be necessary but prevents an error.
                        break;
                    }
                }

                // Now that the body is clean, call the helper to build the new fixtures and get the new count.
                this._createFixturesFromPixels();
                
                this.needsShapeUpdate = false;
            }

            _createFixturesFromPixels() {
                this.fixtureCount = 0;
                // If there are no solid pixels left, mark the body for destruction
                if (!this.pixels.some(p => p !== MAT.EMPTY && p !== MAT.FIRE && p !== MAT.GAS)) {
                    this.isDestroyed = true;
                    return;
                }

                // Generate new, optimized fixtures (merging horizontal runs)
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const type = this.pixels[y * this.width + x];
                        if (type !== MAT.EMPTY && type !== MAT.FIRE && type !== MAT.GAS) {
                            let runEndX = x;
                            while (runEndX + 1 < this.width) {
                                const nextType = this.pixels[y * this.width + (runEndX + 1)];
                                if (nextType !== MAT.EMPTY && nextType !== MAT.FIRE && nextType !== MAT.GAS) {
                                    runEndX++;
                                } else {
                                    break;
                                }
                            }
                            
                            const runWidth = (runEndX - x) + 1;
                            const fixtureDef = new b2FixtureDef();
                            
                            const centerX = (x - this.width / 2) + runWidth / 2;
                            const centerY = y - this.height / 2 + 0.5;
                            
                            const shape = new b2PolygonShape();
                            shape.SetAsBox(
                                (runWidth / 2) / B2_SCALE,
                                0.5 / B2_SCALE,
                                new b2Vec2(centerX / B2_SCALE, centerY / B2_SCALE),
                                0
                            );

                            fixtureDef.set_shape(shape);
                            fixtureDef.set_density(0.5);
                            fixtureDef.set_friction(0.4);
                            fixtureDef.set_restitution(0.2);
                            //console.log("fixture created");
                            this.b2Body.CreateFixture(fixtureDef);

                            this.fixtureCount++;
                            
                            x = runEndX;
                        }
                    }
                }
                this.b2Body.ResetMassData();

                
            }

        }

        /**
         * Uses a flood-fill (BFS) algorithm to find all separate, contiguous "islands"
         * of solid pixels within a single rigid body's pixel grid.
         * @param {Uint8Array} pixels - The body's internal pixel array.
         * @param {number} width - The width of the body's grid.
         * @param {number} height - The height of the body's grid.
         * @returns {Array<Array<{x: number, y: number}>>} An array of islands, where each island is an array of its pixel coordinates.
         */
        function findPixelIslands(pixels, width, height) {
            const islands = [];
            const visited = new Uint8Array(width * height);
            const getIdx = (x, y) => (y * width + x);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = getIdx(x, y);

                    // If this pixel is solid and we haven't visited it yet, we've found a new island.
                    if (pixels[idx] !== MAT.EMPTY && !visited[idx]) {
                        const newIsland = [];
                        const queue = [{ x, y }];
                        visited[idx] = 1;

                        while (queue.length > 0) {
                            const current = queue.shift();
                            newIsland.push(current);

                            // Check neighbors (top, bottom, left, right)
                            const neighbors = [{ dx: 0, dy: 1 }, { dx: 0, dy: -1 }, { dx: 1, dy: 0 }, { dx: -1, dy: 0 }];
                            for (const n of neighbors) {
                                const nx = current.x + n.dx;
                                const ny = current.y + n.dy;

                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIdx = getIdx(nx, ny);
                                    if (pixels[nIdx] !== MAT.EMPTY && !visited[nIdx]) {
                                        visited[nIdx] = 1;
                                        queue.push({ x: nx, y: ny });
                                    }
                                }
                            }
                        }
                        islands.push(newIsland);
                    }
                }
            }
            return islands;
        }

        /**
         * Checks if a rigid body has split into multiple pieces. If it has, it
         * destroys the original body and creates new, separate rigid bodies for each piece.
         * @param {RigidBody} body - The body to check for splits.
         * @returns {Array<RigidBody>|null} An array of new bodies if a split occurred, otherwise null.
         */
        function checkForSplits(body) {
            const islands = findPixelIslands(body.pixels, body.width, body.height);

            // If there's only one island (or none), no split has occurred.
            if (islands.length <= 1) {
                return null;
            }

            // A split has been detected!
            body.isSplit = true; // Mark the original body for destruction.
            const newBodies = [];

            for (const island of islands) {
                if (island.length < MIN_ISLAND_PIXELS) {
                    continue; // Skip to the next island.
                }

                // 1. Find the bounding box of the new island.
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                let sumX = 0, sumY = 0;
                for (const p of island) {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                    sumX += p.x;
                    sumY += p.y;
                }

                const newWidth = maxX - minX + 1;
                const newHeight = maxY - minY + 1;

                // 2. Calculate the island's center point in the *original* body's local coordinates.
                const localCenterX = (sumX / island.length) - body.width / 2 + 0.5;
                const localCenterY = (sumY / island.length) - body.height / 2 + 0.5;

                // 3. Transform that local center point to a global world position.
                tempVec1.set_x(localCenterX / B2_SCALE);
                tempVec1.set_y(localCenterY / B2_SCALE);
                transformPoint(tempVec2, body.b2Body.GetTransform(), tempVec1);
                const worldX = tempVec2.get_x() * B2_SCALE;
                const worldY = tempVec2.get_y() * B2_SCALE;
                
                // 4. Create the new rigid body.
                const newBody = new RigidBody(worldX, worldY, newWidth, newHeight, body.materialType);
                newBody.pixels.fill(MAT.EMPTY); // Clear the default fill.

                // 5. Copy the pixels from the island into the new body's smaller grid.
                for (const p of island) {
                    const newX = p.x - minX;
                    const newY = p.y - minY;
                    const newIdx = newY * newWidth + newX;
                    const oldIdx = p.y * body.width + p.x;
                    newBody.pixels[newIdx] = body.pixels[oldIdx];
                }

                // Apply some of the old body's velocity to the new piece.
                newBody.b2Body.SetLinearVelocity(body.b2Body.GetLinearVelocity());
                newBody.b2Body.SetAngularVelocity(body.b2Body.GetAngularVelocity());
                
                newBodies.push(newBody);
            }

            return newBodies;
        }

        function createChunkGrid() {
            chunkWidth = Math.ceil(worldWidth / CHUNK_SIZE);
            chunkHeight = Math.ceil(worldHeight / CHUNK_SIZE);
            chunkGrid = new Array(chunkWidth * chunkHeight);

            for (let i = 0; i < chunkGrid.length; i++) {
                chunkGrid[i] = { 
                    index: i,
                    staticBody: null,
                    dirty: true,
                    lastRegenTime: 0 // NEW: Track when the body was last rebuilt
                }; 
            }
        }

        /**
         * Scans the fully generated world and activates any chunks containing
         * dynamic materials that need to be simulated from frame one.
         * This must be called AFTER all terrain is generated.
         */
        function activateInitialChunks() {
            for (let y = 0; y < worldHeight; y++) {
                for (let x = 0; x < worldWidth; x++) {
                    const type = grid[getIdx(x, y)];
                    if (type !== MAT.EMPTY && !STATIC_MATERIALS.has(type)) {
                        activateChunkAt(x, y);
                    }
                }
            }
        }

        /**
         * Scans ONLY the area currently visible to the player to find liquid surfaces.
         * This is a highly efficient way to ensure that any on-screen liquids
         * remain active and flowing, preventing them from looking frozen.
         */
        function findAndActivateVisibleLiquidSurfaces() {
            const surfaceChunks = new Set();

            // Define the boundaries of the scan, clamped to the world edges.
            const startX = Math.floor(Math.max(0, camera.x));
            const startY = Math.floor(Math.max(0, camera.y));
            const endX = Math.floor(Math.min(worldWidth, camera.x + viewWidth));
            const endY = Math.floor(Math.min(worldHeight, camera.y + viewHeight));

            // Scan only the pixels within the camera's view.
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = getIdx(x, y);
                    const type = grid[idx];

                    if (isLiquid(type)) {
                        const aboveIdx = getIdx(x, y - 1);
                        // Check if the pixel above is empty space.
                        if (aboveIdx !== -1 && grid[aboveIdx] === MAT.EMPTY) {
                            // This is a surface pixel. Find and add its chunk.
                            const chunkX = Math.floor(x / CHUNK_SIZE);
                            const chunkY = Math.floor(y / CHUNK_SIZE);
                            surfaceChunks.add(chunkGrid[chunkY * chunkWidth + chunkX]);
                        }
                    }
                }
            }

            // Add all the unique chunks we found in the player's view to the simulation list.
            for (const chunk of surfaceChunks) {
                nextActiveChunks.add(chunk);
            }
        }

        function setGrid(idx, type) {
            if (idx === -1) return;

            const oldType = grid[idx];
            if (type === oldType) return;

            // --- THE CRITICAL OPTIMIZATION ---
            // Only mark the chunk as dirty if the "solidness" of the pixel changes.
            // This prevents sand moving over empty space from triggering an expensive physics rebuild.
            const wasSolid = isSolidForPlayer(oldType);
            const isSolid = isSolidForPlayer(type);

            if (wasSolid !== isSolid) {
                const x = idx % worldWidth;
                const y = Math.floor(idx / worldWidth);
                const chunkX = Math.floor(x / CHUNK_SIZE);
                const chunkY = Math.floor(y / CHUNK_SIZE);
                const chunkIndex = chunkY * chunkWidth + chunkX;
                if (chunkGrid[chunkIndex]) {
                    chunkGrid[chunkIndex].dirty = true;
                }
            }
            // --- END OPTIMIZATION ---

            grid[idx] = type;
            activateChunkAt(idx % worldWidth, Math.floor(idx / worldWidth));
        }

        /**
         * Activates the chunk at the given world coordinates, as well as its 8 neighbors.
         * This ensures interactions across chunk borders are always simulated.
         */
        function activateChunkAt(worldX, worldY) {
            const chunkX = Math.floor(worldX / CHUNK_SIZE);
            const chunkY = Math.floor(worldY / CHUNK_SIZE);

            // Activate the 3x3 grid of chunks around the target
            for (let cy = chunkY - 1; cy <= chunkY + 1; cy++) {
                for (let cx = chunkX - 1; cx <= chunkX + 1; cx++) {
                    if (cx >= 0 && cx < chunkWidth && cy >= 0 && cy < chunkHeight) {
                        const chunkIndex = cy * chunkWidth + cx;
                        nextActiveChunks.add(chunkGrid[chunkIndex]);
                    }
                }
            }
        }

        /**
         * A self-contained Perlin Noise generator object.
         * Based on the original implementation by Ken Perlin.
         */
        const PerlinNoise = {
            p: [],
            seed: function(s) {
                // Use a seeded PRNG to ensure the permutation table is the same for a given seed.
                let random = (function() {
                    let seed = s;
                    return function() {
                        seed = (seed * 9301 + 49297) % 233280;
                        return seed / 233280;
                    };
                })();
                
                this.p = new Uint8Array(512);
                let permutation = [];
                for (let i = 0; i < 256; i++) {
                    permutation.push(i);
                }
                // Shuffle permutation table
                for (let i = permutation.length - 1; i > 0; i--) {
                    const j = Math.floor(random() * (i + 1));
                    [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
                }
                // Duplicate the permutation table to avoid buffer overflows
                for (let i = 0; i < 256; i++) {
                    this.p[i] = this.p[i + 256] = permutation[i];
                }
            },
            fade: function(t) { return t * t * t * (t * (t * 6 - 15) + 10); },
            lerp: function(t, a, b) { return a + t * (b - a); },
            grad: function(hash, x, y, z) {
                let h = hash & 15;
                let u = h < 8 ? x : y,
                    v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            },
            noise: function(x, y, z = 0) {
                let X = Math.floor(x) & 255,
                    Y = Math.floor(y) & 255,
                    Z = Math.floor(z) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                let u = this.fade(x),
                    v = this.fade(y),
                    w = this.fade(z);
                let A = this.p[X] + Y, AA = this.p[A] + Z, AB = this.p[A + 1] + Z,
                    B = this.p[X + 1] + Y, BA = this.p[B] + Z, BB = this.p[B + 1] + Z;

                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z),
                                                              this.grad(this.p[BA], x - 1, y, z)),
                                                      this.lerp(u, this.grad(this.p[AB], x, y - 1, z),
                                                              this.grad(this.p[BB], x - 1, y - 1, z))),
                                       this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
                                                              this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                                                      this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),
                                                              this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));
            }
        };

        /**
         * Generates a high-quality, themed, and pixelated multi-layered cave background.
         * This version uses smaller (mostly 2x2) pixel blocks for a finer, more detailed aesthetic.
         */
        function generateCaveBackground(width, height) {
            const img = ctx.createImageData(width, height);
            const d = img.data;
            const layerHeight = height / 5;
            const transitionSize = 40;

            PerlinNoise.seed(1337);

            const hash = (x, y, s = 0) => {
                let h = x * 374761393 + y * 668265263 + s * 1442695041;
                h = (h ^ (h >> 13)) * 1274126177;
                return (h ^ (h >> 16)) & 255;
            };
            const lerp = (a, b, t) => a + (b - a) * t;
            const lerpColor = (c1, c2, t) => [lerp(c1[0], c2[0], t), lerp(c1[1], c2[1], t), lerp(c1[2], c2[2], t)];

            // --- RE-TUNED: Finer Pixel-Art Layer Generators ---

            const getSandCaveColor = (x, y) => {
                const px = x >> 1; const py = y >> 1; // Use 2x2 pixel blocks
                const n = (PerlinNoise.noise(px * 0.04, py * 0.1) + 1) / 2;
                
                if (n > 0.6) return [60, 45, 30];
                if (n > 0.4) return [50, 38, 25];
                return [40, 30, 20];
            };

            const getCoalMineColor = (x, y) => {
                const px = x >> 1; const py = y >> 1; // Use 2x2 pixel blocks
                const rockNoise = (PerlinNoise.noise(px * 0.1, py * 0.1) + 1) / 2;
                const seamNoise = PerlinNoise.noise(px * 0.02, py * 0.15);
                
                if (Math.pow(seamNoise, 2) > 0.3) return [5, 3, 3];
                
                if (rockNoise > 0.6) return [28, 25, 25];
                if (rockNoise > 0.45) return [20, 18, 18];
                return [12, 10, 10];
            };

            const getVolcanicColor = (x, y) => {
                const px = x >> 1; const py = y >> 1; // Keep 2x2 blocks
                const crackle = Math.abs(PerlinNoise.noise(px * 0.06, py * 0.06) * 2.5);

                if (crackle > 0.98) return [255, 170, 0];
                if (crackle > 0.95) return [255, 90, 0];
                
                const rockNoise = hash(px >> 1, py >> 1) / 255;
                if (rockNoise > 0.5) return [25, 10, 10];
                return [15, 5, 5];
            };

            const getLabyrinthColor = (x, y) => {
                const px = x >> 2; const py = y >> 2; // Use smaller 4x4 pixel bricks
                const isMortarX = x % 4 < 1;
                const isMortarY = y % 4 < 1;
                if(isMortarX || isMortarY) return [20, 22, 25];
                
                return hash(px, py) > 128 ? [55, 60, 65] : [45, 50, 55];
            };

            const getMagicDungeonColor = (x, y) => {
                const px = x >> 1; const py = y >> 1; // Use 2x2 pixel blocks
                const energy = (PerlinNoise.noise(px * 0.03, py * 0.03) + 1) / 2;
                
                const crystal = Math.abs(PerlinNoise.noise(px * 0.16, py * 0.16));
                if (Math.pow(crystal, 3) > 0.2) return [180, 150, 255];
                if (Math.pow(crystal, 2) > 0.25) return [100, 80, 140];
                
                if(hash(x,y) > 254) return [200, 200, 255];
                if(energy > 0.55) return [40, 15, 60];
                return [20, 5, 40];
            };
            
            const layerFunctions = [getSandCaveColor, getCoalMineColor, getVolcanicColor, getLabyrinthColor, getMagicDungeonColor];

            // Main Pixel Loop (This part remains the same)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const layerIndex = Math.min(layerFunctions.length - 1, Math.floor(y / layerHeight));
                    const yInLayer = y % layerHeight;
                    let color;
                    if (layerIndex > 0 && yInLayer < transitionSize) {
                        const t = yInLayer / transitionSize;
                        const color1 = layerFunctions[layerIndex - 1](x, y);
                        const color2 = layerFunctions[layerIndex](x, y);
                        color = lerpColor(color1, color2, t * t);
                    } else {
                        color = layerFunctions[layerIndex](x, y);
                    }
                    const i = (y * width + x) * 4;
                    d[i] = color[0]; d[i + 1] = color[1]; d[i + 2] = color[2]; d[i + 3] = 255;
                }
            }
            return img;
        }

        // --- PLAYER AND CAMERA ---
        const player = {
            x: 30, y: 80, vx: 0, vy: 0,
            width: 8, height: 16, speed: 1, onGround: false,
            b2Body: null,
            canInteract: false,
            currentTrigger: null,
            maxHoverEnergy: 100,
            hoverEnergy: 100,
            hoverForce: 0.25,      // Upward force, must be > GRAVITY to ascend
            hoverDrainRate: 0.5,     // Energy used per frame of hovering
            hoverRechargeRate: 1, // Energy recovered per frame when not hovering
            maxHp: 100,
            hp: 100
        };
        const camera = { x: player.x - viewWidth / 2, y: 0 };
		const mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };
        
        // --- INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', (e) => {
            // If the UI is open, input is handled differently
            if (isAlchemyUIVisible) {
                if (e.code === 'Escape') {
                    isAlchemyUIVisible = false;
                }
                // Check if a number key was pressed
                if (e.code.startsWith('Digit')) {
                    const index = parseInt(e.code.replace('Digit', ''), 10) - 1;
                    const reactionKeys = Object.keys(ALCHEMY_REACTIONS);
                    if (index >= 0 && index < reactionKeys.length) {
                        const reactionKey = reactionKeys[index];
                        // Pass the station's geometry to the execute function
                        ALCHEMY_REACTIONS[reactionKey].execute(player.currentTrigger.associatedData.stationGeometry);
                        isAlchemyUIVisible = false; // Close UI after executing
                    }
                }
                return; // Stop further input processing
            }

            keys[e.code] = true;

            if (e.code === 'KeyQ') {
                activeContainer = activeContainer === 'pouch' ? 'flask' : 'pouch';
            }

            if (e.code === 'KeyE') {
                // Check if the player is currently in a trigger zone
                if (player.canInteract && player.currentTrigger) {
                    // Fire the specific trigger's onInteract function
                    player.currentTrigger.onInteract(player.currentTrigger);
                }
            }
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        /**
         * Creates a dynamic b2Body for the player with a composite shape
         * (box + circle) for better movement characteristics.
         */
        function createPlayerBody() {
            const bodyDef = new b2BodyDef();
            bodyDef.set_type(box2d.b2_dynamicBody);
            bodyDef.set_position(new b2Vec2(player.x / B2_SCALE, player.y / B2_SCALE));
            bodyDef.set_fixedRotation(true); // Prevents the player from tipping over
            bodyDef.set_linearDamping(0.5); // Adds a bit of air/ground resistance

            player.b2Body = box2dWorld.CreateBody(bodyDef);

            // 1. Create the main torso fixture (a rectangle)
            const torsoFixtureDef = new b2FixtureDef();
            const torsoShape = new b2PolygonShape();
            // Make the physics box slightly narrower than the graphics to avoid snagging
            torsoShape.SetAsBox(
                (player.width / 2 - 1) / B2_SCALE, 
                (player.height / 2 - 2) / B2_SCALE,
                // Center the torso higher up
                new b2Vec2(0, -2 / B2_SCALE), 
                0
            );
            torsoFixtureDef.set_shape(torsoShape);
            torsoFixtureDef.set_density(1.0);
            torsoFixtureDef.set_friction(0.3);
            player.b2Body.CreateFixture(torsoFixtureDef);

            // 2. Create the foot sensor fixture (a frictionless circle)
            const footFixtureDef = new b2FixtureDef();
            const footShape = new box2d.b2CircleShape(); // Use the global module for b2CircleShape
            footShape.set_m_radius( (player.width / 2 - 1) / B2_SCALE );
            // Position the circle at the player's feet
            footShape.set_m_p( new b2Vec2(0, (player.height / 2 - 2) / B2_SCALE) );
            footFixtureDef.set_shape(footShape);
            footFixtureDef.set_friction(0.05); // Very low friction for smooth sliding
            player.b2Body.CreateFixture(footFixtureDef);
        }

        function setMaterial(name) {
            const map = {
                sand: MAT.SAND, water: MAT.WATER, oil: MAT.OIL, coal: MAT.COAL,
                soil: MAT.SOIL, wall: MAT.ROCK_WALL, gas: MAT.GAS, wood: MAT.WOOD,
                fire: MAT.FIRE, gunpowder: MAT.GUNPOWDER, acid: MAT.ACID,
                glass: MAT.GLASS, 'glass-wall': MAT.GLASS_WALL, empty: MAT.EMPTY,
                adamantium: MAT.ADAMANTIUM, copper: MAT.COPPER, silver: MAT.SILVER,
                gold: MAT.GOLD, platinum: MAT.PLATINUM,
                'rune-wall': MAT.RUNE_WALL
            };

            if (map[name] === undefined) {
                console.warn('Unknown material:', name);
                return;
            }

            currentMaterial = map[name];

            document.querySelectorAll('.controls button')
                .forEach(btn => btn.classList.remove('active'));

            const btn = document.querySelector(`.btn-${name}`);
            if (btn) btn.classList.add('active');
        }

        function isFlammable(type) {
            return (
                type === MAT.WOOD ||
                type === MAT.GUNPOWDER ||
                type === MAT.OIL ||
                type === MAT.COAL
            );
        }

        const LIQUIDS = new Set([
            MAT.WATER,
            MAT.OIL,
            MAT.OIL_BURNING,
            MAT.ACID
        ]);

        function tryIgniteAt(x, y, probability = 1.0) {
            const idx = getIdx(x, y);
            if (idx === -1) return;

            const type = grid[idx];

            if (!isFlammable(type)) return;
            if (Math.random() > probability) return;

            switch (type) {
                case MAT.GUNPOWDER:
                    setGrid(idx, MAT.GUNPOWDER_IGNITED);
                    ignitionTimer[idx] = 3 + Math.floor(Math.random() * 5);
                    break;

                case MAT.OIL:
                    setGrid(idx, MAT.OIL_BURNING);
                    break;

                case MAT.COAL:
                    setGrid(idx, MAT.COAL_BURNING);
                    break;

                case MAT.WOOD:
                    setGrid(idx, MAT.FIRE);
                    break;
            }
        }


        const getMousePos = (evt) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = evt.clientX - rect.left;
            mouse.y = evt.clientY - rect.top;
        };

        function draw(x, y) {
            const brushSize = 10; // Scaled brush size
            const r = Math.floor(brushSize / 2);
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (dx*dx + dy*dy <= r*r) {
                        const px = x + dx; const py = y + dy;
                        const idx = getIdx(px, py);
                        if (idx !== -1) {
                            setGrid(idx, currentMaterial);
                            activateChunkAt(px, py);
                        }
                    }
                }
            }
        }
        canvas.addEventListener('mousemove', getMousePos);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { isPouring = true; } // Left-click to pour
            else if (e.button === 1) { isDrawing = true; draw(mouse.worldX, mouse.worldY); e.preventDefault(); } // Middle-click to draw
            else if (e.button === 2) { 
                isStoring = true; // Set storing state to true
                storeMaterial(mouse.worldX, mouse.worldY); // Store immediately on click
            } 
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) isPouring = false;
            if (e.button === 1) isDrawing = false;
            if (e.button === 2) isStoring = false; // Set storing state to false
        });

        canvas.addEventListener('mousemove', (e) => {
             if (isDrawing) draw(mouse.worldX, mouse.worldY);
        });

        // --- CORE PHYSICS ENGINE ---
        const getIdx = (x, y, w = worldWidth, h = worldHeight) => {
            x = Math.floor(x);
            y = Math.floor(y);
            if (x < 0 || x >= w || y < 0 || y >= h) return -1;
            return y * w + x;
        };

        const isSolidForPlayer = (type) => [
            MAT.ROCK_WALL, MAT.SANDSTONE_WALL, MAT.VOLCANIC_WALL, MAT.LABYRINTH_WALL, MAT.MAGIC_WALL, // All walls added
            MAT.SOIL, MAT.WOOD, MAT.SAND, 
            MAT.GUNPOWDER, MAT.COAL, MAT.COAL_BURNING, MAT.GLASS, 
            MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.COPPER, MAT.SILVER, 
            MAT.GOLD, MAT.PLATINUM, MAT.RUNE_WALL
        ].includes(type);

        function collidesAt(x, y) {
            for (let iy = 0; iy < player.height; iy++) {
                for (let ix = 0; ix < player.width; ix++) {
                    const idx = getIdx(Math.floor(x + ix), Math.floor(y + iy));
                    if (idx !== -1 && isSolidForPlayer(grid[idx])) {
                        return true;
                    }
                }
            }
            return false;
        }

        function collidesAtSides(x, y, dir) {
            const edgeX = dir > 0
                ? Math.floor(x + player.width - 1) // right edge
                : Math.floor(x);                   // left edge

            for (let iy = 0; iy < player.height - 1; iy++) { // ignore feet
                const idx = getIdx(edgeX, Math.floor(y + iy));
                if (idx !== -1 && isSolidForPlayer(grid[idx])) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Stamps a "no-go" zone onto the rigidBodyGrid for the terrain generator.
         * This zone includes the body's pixels AND a 1-pixel buffer around them,
         * creating a definitive "bubble" of empty space that prevents the static terrain
         * from ever touching or conflicting with a dynamic body.
         */
        function updateRigidBodyGrid() {
            // 1. Clear the grid from the previous frame
            rigidBodyGrid.fill(0);
            const buffer = 1; // The size of our safety buffer in pixels

            // 2. Iterate through all rigid bodies
            for (const body of rigidBodies) {
                if (body.isDestroyed) continue;

                const transform = body.b2Body.GetTransform();

                // 3. For each solid pixel within the body...
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        if (body.pixels[y * body.width + x] !== MAT.EMPTY) {
                            // Find its world position
                            tempVec1.set_x((x - body.width / 2 + 0.5) / B2_SCALE);
                            tempVec1.set_y((y - body.height / 2 + 0.5) / B2_SCALE);
                            transformPoint(tempVec2, transform, tempVec1);
                            const worldX = Math.floor(tempVec2.get_x() * B2_SCALE);
                            const worldY = Math.floor(tempVec2.get_y() * B2_SCALE);

                            // 4. Stamp not just the pixel, but a buffered area around it.
                            for (let dy = -buffer; dy <= buffer; dy++) {
                                for (let dx = -buffer; dx <= buffer; dx++) {
                                    const stampX = worldX + dx;
                                    const stampY = worldY + dy;
                                    const stampIdx = getIdx(stampX, stampY);

                                    if (stampIdx !== -1) {
                                        // Mark this spot as a "no-go" zone for terrain generation
                                        rigidBodyGrid[stampIdx] = 1;
                                        // Also displace any sand currently there
                                        // if (grid[stampIdx] !== MAT.EMPTY) {
                                        //     setGrid(stampIdx, MAT.EMPTY);
                                        // }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        

        function updatePlayer() {
            if (isAlchemyUIVisible) {
                player.b2Body.SetLinearVelocity(new b2Vec2(0, 0)); // Stop all movement
                return;
            }

            const currentVel = player.b2Body.GetLinearVelocity();
            let targetVelX = 0;

            // --- 1. Determine Target Velocity from Input ---
            if (keys['KeyA']) {
                targetVelX = -player.speed * 2.5; // Multiply speed to feel responsive in Box2D
                playerFacingRight = false;
            } else if (keys['KeyD']) {
                targetVelX = player.speed * 2.5;
                playerFacingRight = true;
            }
            
            // --- 2. Handle Ground State and Jumping/Hovering ---
            // A simple approximation for being on the ground: check if vertical velocity is near zero.
            // A more robust method (raycast or contact listener) can be added later.
            player.onGround = Math.abs(currentVel.get_y()) < 0.1;

            if (keys['KeyW'] && player.hoverEnergy > 0) {
                // Apply a consistent upward velocity for hovering
                currentVel.set_y(-MAX_HOVER_SPEED); 
                player.hoverEnergy = Math.max(0, player.hoverEnergy - player.hoverDrainRate);
                spawnLevitationParticles(2);
            }
            
            // --- 3. Recharge Energy ---
            if (player.onGround && !keys['KeyW']) {
                player.hoverEnergy = Math.min(player.maxHoverEnergy, player.hoverEnergy + player.hoverRechargeRate);
            }

            // --- 4. Apply the new velocity to the physics body ---
            player.b2Body.SetLinearVelocity(new b2Vec2(targetVelX, currentVel.get_y()));
        }

        /**
         * Reads the position from the player's b2Body and updates the
         * graphical player object to match.
         */
        function syncPlayerWithBody() {
            const pos = player.b2Body.GetPosition();
            // The position is the center of the body, so we offset by half size to get top-left
            player.x = (pos.get_x() * B2_SCALE) - (player.width / 2);
            player.y = (pos.get_y() * B2_SCALE) - (player.height / 2);
        }

        /**
         * Scans a 3x3 area in the world and teleports valid materials into the correct container.
         */
        function storeMaterial(worldX, worldY) {
            const storeRadius = 1; // Creates a 3x3 area
            for (let dy = -storeRadius; dy <= storeRadius; dy++) {
                for (let dx = -storeRadius; dx <= storeRadius; dx++) {
                    const wx = worldX + dx;
                    const wy = worldY + dy;
                    const worldIdx = getIdx(wx, wy, worldWidth, worldHeight);
                    if (worldIdx === -1) continue;

                    const type = grid[worldIdx];
                    let targetGrid, targetW, targetH;

                    if (STORABLE_SOLIDS.has(type)) {
                        targetGrid = pouchGrid; targetW = pouchWidth; targetH = pouchHeight;
                    } else if (STORABLE_LIQUIDS.has(type)) {
                        targetGrid = flaskGrid; targetW = flaskWidth; targetH = flaskHeight;
                    } else {
                        continue; // Can't store this type
                    }

                    // NEW: Scan from the top of the container downwards, across the full width, to find an empty spot.
                    let spotFound = false;
                    for (let y = 0; y < targetH; y++) {
                        // Start scanning at a random x-offset each time to prevent filling bias on one side.
                        const xOffset = Math.floor(Math.random() * targetW);
                        for (let i = 0; i < targetW; i++) {
                            const x = (i + xOffset) % targetW; // Loop through all x-coordinates
                            
                            const containerIdx = getIdx(x, y, targetW, targetH);
                            if (containerIdx !== -1 && targetGrid[containerIdx] === MAT.EMPTY) {
                                targetGrid[containerIdx] = type; // Place material
                                setGrid(worldIdx, MAT.EMPTY);      // Remove from world
                                spotFound = true;
                                break; // Exit inner x-loop
                            }
                        }
                        if (spotFound) {
                            break; // Exit outer y-loop
                        }
                    }
                }
            }
        }

        /**
         * Takes one particle from the bottom of the active container and adds it to the pouredParticles array.
         */
        function pourFromContainer() {
            const [containerGrid, containerW, containerH] = activeContainer === 'pouch'
                ? [pouchGrid, pouchWidth, pouchHeight]
                : [flaskGrid, flaskWidth, flaskHeight];

            // NEW: Variables to control how many particles are poured each frame
            const maxPourPerFrame = 3; 
            let pouredCount = 0;

            // Find particles at the bottom to pour
            for (let y = containerH - 1; y >= 0; y--) {
                for (let i = 0; i < containerW; i++) {
                    // Scan from the center outwards
                    const x = Math.floor(containerW / 2) + (i % 2 === 0 ? 1 : -1) * Math.floor(i / 2);
                    const idx = getIdx(x, y, containerW, containerH);
                    const type = containerGrid[idx];

                    if (type !== MAT.EMPTY && type !== MAT.GAS) { // Cannot pour gas
                        containerGrid[idx] = MAT.EMPTY; // Remove from container

                        // --- Start of Noita-style Variance Logic ---

                        // 1. Add variance to spawn position
                        const baseSpawnX = player.x + (playerFacingRight ? player.width : 0);
                        const baseSpawnY = player.y + 9;
                        const spawnOffsetX = (Math.random() - 0.5) * 2; 
                        const spawnOffsetY = (Math.random() - 0.5) * 2; 
                        const finalSpawnX = baseSpawnX + spawnOffsetX;
                        const finalSpawnY = baseSpawnY + spawnOffsetY;

                        // 2. Add variance to the angle (spread)
                        const baseAngle = Math.atan2(mouse.worldY - finalSpawnY, mouse.worldX - finalSpawnX);
                        const spread = 0.05; // CHANGED: Reduced from 0.25 to make the stream tighter
                        const finalAngle = baseAngle + (Math.random() - 0.5) * spread;

                        // 3. Add variance to the velocity
                        const baseVelocity = 4.0;
                        const velocityVariance = 0.5;
                        const finalVelocity = baseVelocity + (Math.random() - 0.5) * velocityVariance;

                        // --- End of Noita-style Variance Logic ---

                        pouredParticles.push({
                            x: finalSpawnX, 
                            y: finalSpawnY,
                            vx: Math.cos(finalAngle) * finalVelocity,
                            vy: Math.sin(finalAngle) * finalVelocity,
                            type: type
                        });
                        
                        pouredCount++;
                        if (pouredCount >= maxPourPerFrame) {
                           return; // Exit after pouring the max number of particles
                        }
                    }
                }
            }
        }

        /**
         * Updates the position and state of all particles currently being poured.
         */
        function updatePouredParticles() {
            pouredParticles = pouredParticles.filter(p => {
                // Apply gravity
                p.vy += GRAVITY * 0.5;

                // 1. Calculate the particle's potential next position
                const nextX = p.x + p.vx;
                const nextY = p.y + p.vy;
                const nextIX = Math.floor(nextX);
                const nextIY = Math.floor(nextY);

                const worldIdx = getIdx(nextIX, nextIY);
                
                // Check if the particle is about to go off-screen
                if (worldIdx === -1) {
                    return false; // Remove if it leaves the world
                }
                
                // 2. Check for an obstruction at that future position
                const isObstructed = grid[worldIdx] !== MAT.EMPTY && grid[worldIdx] !== MAT.GAS;
                const hasStopped = (p.vx * p.vx + p.vy * p.vy < 1.0);

                // 3. If a collision is predicted OR the particle has stopped, materialize it
                if (isObstructed || hasStopped) {
                    // THE FIX: Start the search from the particle's CURRENT, known-good position, not the invalid future one.
                    let placeX = Math.floor(p.x);
                    let placeY = Math.floor(p.y);
                    
                    // The upward search is still useful for stacking, but now starts from a safe location.
                    while (true) {
                        const checkIdx = getIdx(placeX, placeY);
                        
                        // Stop if we search off the top of the map
                        if (checkIdx === -1) {
                            break; 
                        }

                        // If we find an empty spot, place the material and we're done.
                        if (grid[checkIdx] === MAT.EMPTY || grid[checkIdx] === MAT.GAS) {
                            setGrid(checkIdx, p.type);
                            activateChunkAt(placeX, placeY);
                            break;
                        }
                        
                        // If the spot was taken, move up one pixel and try again.
                        placeY--;
                    }
                    
                    // The particle's journey is over. Remove it.
                    return false;
                } else {
                    // 4. If no collision is predicted, update the particle's position and keep it alive.
                    p.x = nextX;
                    p.y = nextY;
                    return true; 
                }
            });
        }

        function shootFire() {
            const projectileSpeed = 1.0; 
            
            // Calculate wand tip position in world coordinates for the larger sprite
            const wandTipX = player.x + (playerFacingRight ? player.width + 2 : -4);
            const wandTipY = player.y + 9; // Centered on the new wand vertically

            const angle = Math.atan2(mouse.worldY - wandTipY, mouse.worldX - wandTipX);
            projectiles.push({
                x: wandTipX, y: wandTipY,
                vx: Math.cos(angle) * projectileSpeed, vy: Math.sin(angle) * projectileSpeed
            });
        }
		
		function updateProjectiles() {
            projectiles = projectiles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                const idx = getIdx(p.x, p.y);
                if (idx === -1) return false; 
                if (grid[idx] !== MAT.EMPTY) {
                    setGrid(idx, MAT.FIRE); return false;
                }
                return true;
            });
        }

        const movedWorld = new Uint8Array(worldWidth * worldHeight);
        const movedPouch = new Uint8Array(pouchWidth * pouchHeight);
        const movedFlask = new Uint8Array(flaskWidth * flaskHeight);
        
        /**
         * Runs the simulation on the main world grid using the active chunk optimization.
         */
        function runWorldSimulationWithChunks(moved) {
            moved.fill(0);
            const localGetIdx = (x, y) => getIdx(x, y, worldWidth, worldHeight);
            const scanDir = (frameCount % 2 === 0);
            
            // For the main world, the "setter" is the original setGrid function.
            const setter = setGrid; 

            for (const chunk of activeChunks) {
                const chunkX = chunk.index % chunkWidth;
                const chunkY = Math.floor(chunk.index / chunkWidth);
                const startX = chunkX * CHUNK_SIZE;
                const startY = chunkY * CHUNK_SIZE;
                const endX = startX + CHUNK_SIZE;
                const endY = startY + CHUNK_SIZE;

                // PASS 1: solids, gas, fire
                for (let y = endY - 1; y >= startY; y--) {
                    for (let x = (scanDir ? startX : endX - 1); (scanDir ? x < endX : x >= startX); x += (scanDir ? 1 : -1)) {
                        stepNonLiquid(x, y, moved, grid, worldWidth, worldHeight, localGetIdx, setter);
                    }
                }

                // PASS 2: liquids
                for (let y = endY - 1; y >= startY; y--) {
                    for (let x = (scanDir ? startX : endX - 1); (scanDir ? x < endX : x >= startX); x += (scanDir ? 1 : -1)) {
                        stepLiquid(x, y, moved, grid, worldWidth, worldHeight, localGetIdx, setter);
                    }
                }
            }
        }

        function runSimulationOnSmallGrid(moved, currentGrid, gridWidth, gridHeight, setter) {
             moved.fill(0);
             const localGetIdx = (x, y) => getIdx(x, y, gridWidth, gridHeight);
             const scanDir = (frameCount % 2 === 0);

            // PASS 1: solids, gas, fire
            for (let y = gridHeight - 1; y >= 0; y--) {
                 for (let x = (scanDir ? 0 : gridWidth - 1); (scanDir ? x < gridWidth : x >= 0); x += (scanDir ? 1 : -1)) {
                    stepNonLiquid(x, y, moved, currentGrid, gridWidth, gridHeight, localGetIdx, setter);
                }
            }

            // PASS 2: liquids
            for (let y = gridHeight - 1; y >= 0; y--) {
                 for (let x = (scanDir ? 0 : gridWidth - 1); (scanDir ? x < gridWidth : x >= 0); x += (scanDir ? 1 : -1)) {
                    stepLiquid(x, y, moved, currentGrid, gridWidth, gridHeight, localGetIdx, setter);
                }
            }
        }

        function stepAll(x, y, moved) {
            const idx = getIdx(x, y);
            if (idx === -1 || moved[idx]) return;

            const type = grid[idx];
            if ([MAT.EMPTY, MAT.ROCK_WALL, MAT.WOOD].includes(type)) return;
            if (type === MAT.WATER) updateLiquid(x, y, idx, moved);
            if (type === MAT.FIRE) updateFire(x, y, idx, moved);
            else if ([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER].includes(type))
                updateSolid(x, y, idx, type, moved);
            else if (type === MAT.GAS) updateGas(x, y, idx, moved);
            else if (type >= 20) updateSource(x, y, idx, type);
        }

        function stepNonLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const idx = getIdx(x, y); 
            if (idx === -1 || moved[idx]) return;
            const type = grid[idx];
            if (WALL_TYPES.has(type) || [MAT.EMPTY, MAT.WOOD, MAT.GLASS_WALL, MAT.ADAMANTIUM, MAT.RUNE_WALL, MAT.RIGID_BODY_STUB].includes(type) || LIQUIDS.has(type)) return;

            if (type === MAT.FIRE) updateFire(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if ([MAT.SAND, MAT.SOIL, MAT.GUNPOWDER, MAT.COAL, MAT.COAL_BURNING, MAT.GLASS, MAT.COPPER, MAT.SILVER, MAT.GOLD, MAT.PLATINUM].includes(type)) updateSolid(x, y, idx, type, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.COAL_BURNING) updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.GAS) updateGas(x, y, idx, moved, grid, w, h, getIdx, setter);
            else if (type === MAT.GUNPOWDER_IGNITED) updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter);
        }

        function stepLiquid(x, y, moved, grid, w, h, getIdx, setter) {
            const idx = getIdx(x, y, w, h);
            if (idx === -1 || moved[idx]) return;
            if (![MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.ACID].includes(grid[idx])) return;

            updateLiquid(x, y, idx, moved, grid, w, h, getIdx, setter);
        }


        function updateCamera() {
            // Follow player on X-axis
            const targetCamX = player.x - viewWidth / 2;
            camera.x += (targetCamX - camera.x) * 0.1;

            // Follow player on Y-axis
            const targetCamY = player.y - viewHeight / 2;
            camera.y += (targetCamY - camera.y) * 0.1;

            // Clamp camera to world bounds
            if (camera.x < 0) camera.x = 0;
            if (camera.x > worldWidth - viewWidth) camera.x = worldWidth - viewWidth;
            if (camera.y < 0) camera.y = 0;
            if (camera.y > worldHeight - viewHeight) camera.y = worldHeight - viewHeight;
        }

        function updateIgnitedGunpowder(x, y, idx, moved, grid, w, h, getIdx, setter) {
            ignitionTimer[idx]--;

            for (let n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                const nIdx = getIdx(x + n.x, y + n.y);
                if (Math.random() < 0.35) {
                    if (nIdx !== -1 && grid[nIdx] === MAT.GUNPOWDER) {
                        setter(nIdx, MAT.GUNPOWDER_IGNITED);
                        ignitionTimer[nIdx] = 8 + Math.floor(Math.random() * 6);
                    }
                }
            }

            if (ignitionTimer[idx] <= 0) {
                setter(idx, MAT.EMPTY);
                // Explosions only happen in the main world, so we can still call setGrid here.
                if (setter === setGrid) triggerExplosion(x, y, 6);
            }
        }

        function triggerExplosion(centerX, centerY, radius) {
            const maxRadius = 100; // Scaled max radius
            if (radius > maxRadius) radius = maxRadius;
            const rSquared = radius * radius;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx*dx + dy*dy > rSquared) continue;
                    const ex = Math.floor(centerX + dx);
                    const ey = Math.floor(centerY + dy);
                    const idx = getIdx(ex, ey);
                    if (idx === -1 || ex === 0 || ex === worldWidth - 1 || ey === 0 || ey === worldHeight - 1) continue;
                    
                    if (!WALL_TYPES.has(grid[idx]) && grid[idx] !== MAT.ADAMANTIUM) {
                        const rand = Math.random();
                        if (rand < 0.3) setGrid(idx, MAT.FIRE);
                        else if (rand < 0.7) setGrid(idx, MAT.GAS); 
                        else setGrid(idx, MAT.EMPTY);
                    } else if (radius > 20 && Math.random() < 0.5) { // Scaled check
                        setGrid(idx, MAT.GAS);
                    }
                }
            }
        }

        function explodeCluster(startX, startY) {
            let queue = [{x: startX, y: startY}];
            let cluster = [{x: startX, y: startY}]; 
            let visited = new Set([`${startX},${startY}`]);
            setGrid(getIdx(startX, startY), MAT.EMPTY);
            let iterations = 0; const maxIterations = 3000;
            while (queue.length > 0 && iterations++ < maxIterations) {
                let current = queue.shift();
                for (let d of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                    const nx = current.x + d.x, ny = current.y + d.y;
                    const key = `${nx},${ny}`;
                    const nIdx = getIdx(nx, ny);
                    if (nIdx !== -1 && !visited.has(key) && grid[nIdx] === MAT.GUNPOWDER) {
                        visited.add(key); queue.push({x: nx, y: ny});
                        cluster.push({x: nx, y: ny}); setGrid(nIdx, MAT.EMPTY);
                    }
                }
            }
            let sumX = 0, sumY = 0;
            for (let p of cluster) { sumX += p.x; sumY += p.y; }
            triggerExplosion(sumX / cluster.length, sumY / cluster.length, 5 + Math.sqrt(cluster.length));
        }

        function updateFire(x, y, idx, moved, grid, w, h, getIdx, setter) {
            let nearbyFuel = false;
            for (let n of [{x:0,y:1},{x:0,y:1},{x:-1,y:0},{x:1,y:0},{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}]) {
                const nx = x + n.x, ny = y + n.y;
                const nIdx = getIdx(nx, ny);
                if (nIdx === -1) continue;
                const nType = grid[nIdx];

                if (nType === MAT.SAND && Math.random() < 0.05) setter(nIdx, MAT.GLASS);
                if (nType === MAT.GUNPOWDER && Math.random() < 0.5) {
                    setter(nIdx, MAT.GUNPOWDER_IGNITED);
                    ignitionTimer[nIdx] = 8 + Math.floor(Math.random() * 6);
                    return;
                }
                if (nType === MAT.OIL) { setter(nIdx, MAT.OIL_BURNING); return; }
                if (nType === MAT.COAL) { setter(nIdx, MAT.COAL_BURNING); return; }
                if (nType === MAT.WOOD) {
                    nearbyFuel = true;
                    if (Math.random() < 0.01) { setter(nIdx, MAT.FIRE); moved[nIdx] = 1; }
                }
                if (nType === MAT.WATER) { setter(nIdx, MAT.GAS); setter(idx, MAT.GAS); return; }
            }
            let targetIdx = idx;
            if (!nearbyFuel && y > 0) {
                let nextX = x, nextY = y - 1;
                if (Math.random() < 0.5) nextX += Math.random() < 0.5 ? -1 : 1;
                const nextIdx = getIdx(nextX, nextY);
                if (nextIdx !== -1 && (grid[nextIdx] === MAT.EMPTY || grid[nextIdx] === MAT.GAS)) {
                    setter(idx, grid[nextIdx]); setter(nextIdx, MAT.FIRE);
                    moved[nextIdx] = 1; targetIdx = nextIdx;
                }
            }
            if (Math.random() < (nearbyFuel ? 0.0 : 0.15)) setter(targetIdx, MAT.GAS);
        }

        function updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter) {
            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                const nx = x + n.x, ny = y + n.y;
                const nIdx = getIdx(nx, ny);
                if (nIdx === -1) continue;
                if (grid[nIdx] === MAT.SAND && Math.random() < 0.08) setter(nIdx, MAT.GLASS);
                // tryIgniteAt is world-only, so we check the setter
                if (setter === setGrid) tryIgniteAt(nx, ny, 0.02);
            }
            if (Math.random() < 0.02) {
                const aboveIdx = getIdx(x, y - 1);
                if (aboveIdx !== -1 && grid[aboveIdx] === MAT.EMPTY) setter(aboveIdx, MAT.FIRE);
            }
            if (Math.random() < 0.003) setter(idx, MAT.GAS);
            if (grid[idx] === MAT.COAL_BURNING && setter === setGrid) activateChunkAt(x, y);
        }
        
        function updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter) {
            for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0},{x:1,y:1},{x:-1,y:1},{x:1,y:-1},{x:-1,y:-1}]) {
                const nx = x + n.x, ny = y + n.y;
                const nIdx = getIdx(nx, ny);
                if (nIdx === -1) continue;
                if (grid[nIdx] === MAT.SAND && Math.random() < 0.1) setter(nIdx, MAT.GLASS);
                if (setter === setGrid) tryIgniteAt(nx, ny, 0.05);
            }
            if (Math.random() < 0.05) {
                const aboveIdx = getIdx(x, y - 1);
                if (aboveIdx !== -1 && grid[aboveIdx] === MAT.EMPTY) setter(aboveIdx, MAT.FIRE);
            }
            if (Math.random() < 0.008) setter(idx, MAT.GAS);
            if (grid[idx] === MAT.OIL_BURNING && setter === setGrid) activateChunkAt(x, y);
        }

        function updateSolid(x, y, idx, type, moved, grid, w, h, getIdx, setter) {
            const belowIdx = getIdx(x, y + 1);
            if (belowIdx === -1) return;

            // Handle special material interactions (like coal burning)
            if (type === MAT.COAL_BURNING) {updateBurningCoal(x, y, idx, moved, grid, w, h, getIdx, setter)}
            if (grid[belowIdx] === MAT.FIRE && type === MAT.COAL) {
                setter(idx, MAT.COAL_BURNING);
                return;
            }

            // --- THE CRITICAL COLLISION CHECK ---
            // First, check if the space directly below is occupied by a rigid body.
            if (rigidBodyGrid[belowIdx] !== 1) {
                // If NOT blocked by a body, then check the main grid for other materials.
                const belowType = grid[belowIdx];
                if ([MAT.EMPTY, MAT.GAS].includes(belowType) || isLiquid(belowType)) {
                    setter(idx, belowType); // Swap with whatever is below (liquid, gas, or empty)
                    setter(belowIdx, type);
                    moved[belowIdx] = 1;
                    return;
                }
            }

            // If directly below is blocked (by a body OR other solids), try moving diagonally.
            const dir = Math.random() < 0.5 ? -1 : 1;
            for (let dx of [dir, -dir]) {
                const dIdx = getIdx(x + dx, y + 1);
                // Check if the diagonal space is valid AND not occupied by a rigid body.
                if (dIdx !== -1 && rigidBodyGrid[dIdx] !== 1) {
                    const diagType = grid[dIdx];
                    if ([MAT.EMPTY, MAT.GAS].includes(diagType) || isLiquid(diagType)) {
                        setter(idx, diagType);
                        setter(dIdx, type);
                        moved[dIdx] = 1;
                        return;
                    }
                }
            }
        }

        function isLiquid (type) {
            return LIQUIDS.has(type);
        }

        function updateLiquid(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const type = grid[idx];

            // Acid logic remains the same
            if (type === MAT.ACID) {
                let consumed = false;
                for (const n of [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]) {
                    const nIdx = getIdx(x + n.x, y + n.y);
                    if (nIdx === -1) continue;
                    const nType = grid[nIdx];
                    const isImmune = [MAT.EMPTY, MAT.GLASS, MAT.GAS, MAT.GLASS_WALL, MAT.ADAMANTIUM].includes(nType);
                    if (!isImmune && !isLiquid(nType) && Math.random() < 0.25) {
                        setter(nIdx, MAT.EMPTY);
                        if (Math.random() < 0.1) { setter(idx, MAT.EMPTY); consumed = true; break; }
                    }
                }
                if (consumed) { moved[idx] = 1; return; }
            }

            const belowIdx = getIdx(x, y + 1);
            if (belowIdx === -1) return;

            // --- THE CRITICAL COLLISION CHECK ---
            // If the space below is occupied by a rigid body, stop falling and try to spread sideways.
            if (rigidBodyGrid[belowIdx] === 1) {
                tryMoveLiquidSide(x, y, idx, type, moved, Math.random() < 0.5 ? -1 : 1, 20, 1, grid, w, h, getIdx, setter);
                if (grid[idx] === MAT.OIL_BURNING) updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter);
                return; // Stop vertical movement and exit
            }

            // Burning logic remains the same
            if (grid[belowIdx] === MAT.FIRE) {
                if (grid[idx] === MAT.OIL) setter(idx, MAT.OIL_BURNING);
                else { setter(idx, MAT.GAS); setter(belowIdx, MAT.GAS); }
                return;
            }

            // Standard liquid movement logic
            const below = grid[belowIdx];
            if ([MAT.EMPTY, MAT.GAS].includes(below)) {
                setter(idx, below); setter(belowIdx, type); moved[belowIdx] = 1; return;
            }
            if (LIQUID_DENSITY[type] > LIQUID_DENSITY[below]) {
                setter(idx, below); setter(belowIdx, type); moved[belowIdx] = 1; return;
            }
            tryMoveLiquidSide(x, y, idx, type, moved, Math.random() < 0.5 ? -1 : 1, 20, 1, grid, w, h, getIdx, setter);
            if (grid[idx] === MAT.OIL_BURNING) updateBurningOil(x, y, idx, moved, grid, w, h, getIdx, setter);
        }

        function updateGas(x, y, idx, moved, grid, w, h, getIdx, setter) {
            const aboveIdx = getIdx(x, y - 1);
            if (y === 0) { setter(idx, MAT.EMPTY); return; }
            const above = grid[aboveIdx];
            if ([MAT.EMPTY, MAT.WATER, MAT.SAND, MAT.SOIL, MAT.GUNPOWDER].includes(above)) {
                setter(idx, above); setter(aboveIdx, MAT.GAS); moved[aboveIdx] = 1;
                return;
            }
            tryMoveLiquidSide(x, y, idx, MAT.GAS, moved, Math.random() < 0.5 ? -1 : 1, 4, -1, grid, w, h, getIdx, setter);
        }

        function tryMoveLiquidSide(x, y, currentIdx, type, moved, dir, limit, vDir, grid, w, h, getIdx, setter) {
            let targetX = x;
            const movableMaterials = [MAT.EMPTY, MAT.GAS, MAT.FIRE];
            const allMovableMaterials = [...LIQUIDS, ...movableMaterials];
            for (let i = 1; i <= limit; i++) {
                const nextX = x + (dir * i);
                const nextIdx = getIdx(nextX, y);
                if (nextIdx === -1 || rigidBodyGrid[nextIdx] === 1) break;
                const content = grid[nextIdx];
                const canMove = allMovableMaterials.includes(content) && type != content;
                if (canMove) {
                    targetX = nextX;
                    const vIdx = getIdx(nextX, y + vDir);
                    if (vIdx !== -1 && movableMaterials.includes(grid[vIdx])) break;
                } else break;
            }
            if (targetX !== x) {
                const tIdx = getIdx(targetX, y);
                setter(currentIdx, grid[tIdx]); setter(tIdx, type); moved[tIdx] = 1;
                return true;
            }
            return false;
        }

        function pushLiquidRowSideways(x, y, liquidType, grid, w, h, getIdx, maxPush = 10) {
            const dirs = Math.random() < 0.5 ? [-1, 1] : [1, -1];

            for (const dir of dirs) {
                // find empty space
                for (let i = 1; i <= maxPush; i++) {
                    const targetIdx = getIdx(x + dir * i, y);
                    if (targetIdx === -1) break;

                    if (grid[targetIdx] === MAT.EMPTY) {
                        // shift liquid toward empty space
                        for (let j = i; j > 0; j--) {
                            const fromIdx = getIdx(x + dir * (j - 1), y);
                            const toIdx   = getIdx(x + dir * j, y);

                            if (grid[fromIdx] !== liquidType) break;
                            setGrid(toIdx, grid[fromIdx]);
                            setGrid(fromIdx, MAT.EMPTY);
                            activateChunkAt(x + dir * (j - 1), y);
                            activateChunkAt(x + dir * j, y);
                        }
                        return true;
                    }

                    // stop if blocked by solid
                    if (![MAT.WATER, MAT.OIL, MAT.OIL_BURNING, MAT.ACID].includes(grid[targetIdx])) {
                        break;
                    }
                }
            }
            return false;
        }

        function findGroundBelow(x, startY) {
            for (let y = startY; y < worldHeight; y++) {
                const idx = getIdx(x, y);
                if (idx !== -1 && grid[idx] !== MAT.EMPTY) {
                    return y;
                }
            }
            return worldHeight - 1;
        }

        function createReservoir({
            x,
            y,
            width,
            height,
            fillType,
            wallType = MAT.WOOD
        }) {
            const groundY = findGroundBelow(x, y);
            const topY = Math.max(0, groundY - height);
            const leftX = Math.floor(x - width / 2);
            const rightX = Math.floor(x + width / 2);
            const wallWidth = 2;

            for (let iy = topY; iy <= groundY; iy++) {
                for (let ix = leftX; ix <= rightX; ix++) {
                    const idx = getIdx(ix, iy);
                    if (idx === -1) continue;

                    const isWall =
                        ix <= leftX + wallWidth ||
                        ix >= rightX - wallWidth ||
                        iy >= groundY - wallWidth;

                    setGrid(idx, isWall ? wallType : fillType);
                }
            }
        }

        function createCircle({
            x,
            y,
            radius,
            type
        }) {
            const r2 = radius * radius;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy > r2) continue;

                    const px = Math.floor(x + dx);
                    const py = Math.floor(y + dy);
                    const idx = getIdx(px, py);
                    if (idx === -1) continue;

                    setGrid(idx, type);
                }
            }
        }

        function createCircleOutline({ x, y, radius, thickness = 1, type }) {
            const r2 = radius * radius;
            const inner = (radius - thickness) ** 2;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const d2 = dx * dx + dy * dy;
                    if (d2 > r2 || d2 < inner) continue;

                    const idx = getIdx(x + dx, y + dy);
                    if (idx !== -1) setGrid(idx, type);
                }
            }
        }

        /**
         * Performs a fast, localized lighting update on a single chunk.
         * Crucially, it also detects if light has "spilled" over a border and returns
         * a Set of neighboring chunks that should now also be activated.
         * @param {object} chunk - The chunk object to process.
         * @returns {Set<object>} A set of neighboring chunk objects to activate next.
         */
        function updateLocalLightingAndFindNeighbors(chunk) {
            const neighborsToActivate = new Set();
            const chunkX_base = chunk.index % chunkWidth;
            const chunkY_base = Math.floor(chunk.index / chunkWidth);
            const startX = chunkX_base * CHUNK_SIZE;
            const startY = chunkY_base * CHUNK_SIZE;
            const endX = startX + CHUNK_SIZE;
            const endY = startY + CHUNK_SIZE;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = getIdx(x, y);
                    if (idx === -1) continue;

                    let maxNeighborLight = 0;
                    if (x > 0) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx - 1]);
                    if (x < worldWidth - 1) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx + 1]);
                    if (y > 0) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx - worldWidth]);
                    if (y < worldHeight - 1) maxNeighborLight = Math.max(maxNeighborLight, lightGrid[idx + worldWidth]);

                    const isWall = WALL_TYPES.has(grid[idx]);
                    const lightLoss = isWall ? 3 : 0;
                    const potentialLight = maxNeighborLight - lightLoss;
                    
                    let lightChanged = false;
                    if (potentialLight > lightGrid[idx]) {
                        lightGrid[idx] = potentialLight;
                        lightChanged = true;
                    }

                    if (grid[idx] === MAT.EMPTY && lightGrid[idx] < MAX_LIGHT_LEVEL) {
                        lightGrid[idx] = MAX_LIGHT_LEVEL;
                        lightChanged = true;
                    }

                    if (lightChanged) {
                        // Check neighbors if this pixel is on a chunk border
                        const dirs = [{dx:-1, dy:0}, {dx:1, dy:0}, {dx:0, dy:-1}, {dx:0, dy:1}];
                        for (const dir of dirs) {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;
                            
                            // Check if the neighbor is in a different chunk
                            if (Math.floor(nx / CHUNK_SIZE) !== chunkX_base || Math.floor(ny / CHUNK_SIZE) !== chunkY_base) {
                                const nIdx = getIdx(nx, ny);
                                // If the neighbor exists and isn't a wall, it can receive light.
                                if (nIdx !== -1 && !WALL_TYPES.has(grid[nIdx])) {
                                    const nChunkX = Math.floor(nx / CHUNK_SIZE);
                                    const nChunkY = Math.floor(ny / CHUNK_SIZE);
                                    if (nChunkX >= 0 && nChunkX < chunkWidth && nChunkY >= 0 && nChunkY < chunkHeight) {
                                        neighborsToActivate.add(chunkGrid[nChunkY * chunkWidth + nChunkX]);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return neighborsToActivate;
        }

        /**
         * Calculates light levels using a Breadth-First Search with material-dependent dampening.
         * Light originates from EMPTY cells, travels freely through non-ROCK_WALL materials,
         * and loses strength when penetrating WALLs.
         */
        function updateLighting() {
            lightGrid.fill(0);
            const queue = [];

            // 1. Seed the queue with all empty cells as the light sources.
            // const searchRadius = 25;
            // const startX = Math.max(0, Math.floor(camera.x) - searchRadius);
            // const endX = Math.min(worldWidth, Math.floor(camera.x) + viewWidth + searchRadius);
            // const startY = Math.max(0, Math.floor(camera.y) - searchRadius);
            // const endY = Math.min(worldHeight, Math.floor(camera.y) + viewHeight + searchRadius);

            const startX = 0;
            const endX = worldWidth;
            const startY = 0;
            const endY = worldHeight;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = getIdx(x, y);
                    if (idx !== -1 && grid[idx] === MAT.EMPTY) {
                        lightGrid[idx] = MAX_LIGHT_LEVEL;
                        queue.push(idx);
                    }
                }
            }

            // 2. Spread the light outwards layer by layer (BFS)
            let head = 0;
            const DIRS = [-1, 1, -worldWidth, worldWidth];

            while (head < queue.length) {
                const currentIdx = queue[head++];
                const currentLight = lightGrid[currentIdx];

                if (currentLight <= 1) continue;

                for (const dir of DIRS) {
                    const nextIdx = currentIdx + dir;

                    if (nextIdx < 0 || nextIdx >= grid.length || (dir === 1 && nextIdx % worldWidth === 0) || (dir === -1 && currentIdx % worldWidth === 0)) {
                        continue;
                    }
                    
                    // --- NEW LIGHTING LOGIC ---
                    // Determine the light loss based on the material we are *entering*.
                    const isNextMaterialWall = WALL_TYPES.has(grid[nextIdx]);
                    
                    // Light passing into a WALL is heavily dampened.
                    // Light passing into ANY OTHER material is not dampened at all.
                    const lightLoss = isNextMaterialWall ? 3 : 0;
                    
                    const nextLight = currentLight - lightLoss;

                    // If our calculated light is brighter than the neighbor's current light, update it.
                    if (nextLight > lightGrid[nextIdx]) {
                        lightGrid[nextIdx] = nextLight;
                        // Always add the neighbor to the queue to continue spreading light.
                        queue.push(nextIdx); 
                    }
                }
            }
        }

        // --- RENDERING ---
        function setPixel(x, y, r, g, b, a = 255) {
            const i = (y * renderWidth + x) * 4;
            pixels[i]     = r;
            pixels[i + 1] = g;
            pixels[i + 2] = b;
            pixels[i + 3] = a;
        }

        function render() {
            // --- WORLD ---
            firePixelsCoords = [];
            
            const bgPixels = skyImageData.data;
            const bgStartY = Math.floor(camera.y);

            for (let screenY = 0; screenY < renderHeight; screenY++) {
                const worldY = screenY + bgStartY; // The Y-coordinate in the giant background image

                for (let screenX = 0; screenX < renderWidth; screenX++) {
                    const destI = (screenY * renderWidth + screenX) * 4; // Index for the canvas
                    const sourceI = (worldY * worldWidth + screenX) * 4; 

                    // Safety check to prevent reading out of bounds
                    if (sourceI >= 0 && sourceI < bgPixels.length) {
                        pixels[destI]     = bgPixels[sourceI];
                        pixels[destI + 1] = bgPixels[sourceI + 1];
                        pixels[destI + 2] = bgPixels[sourceI + 2];
                        pixels[destI + 3] = 255;
                    }
                }
            }

            const time = frameCount * 0.04;

            // Get the top-left corner of the camera in world coordinates
            const startX = Math.floor(camera.x);
            const startY = Math.floor(camera.y); // THE CRITICAL MISSING PIECE

            // Loop over every pixel on the SCREEN
            for (let screenY = 0; screenY < viewHeight; screenY++) {
                const worldY = screenY + startY;
                for (let screenX = 0; screenX < viewWidth; screenX++) {
                    const worldX = screenX + startX;

                    const idx = getIdx(worldX, worldY);
                    if (idx === -1) continue;

                    const type = grid[idx];
                    
                    if (type === MAT.EMPTY || type === MAT.RIGID_BODY_STUB) continue; 

                    // --- NEW: Gradient Lighting Logic ---
                    const lightLevel = lightGrid[idx];

                    if (lightLevel === 0 && !ALWAYS_VISIBLE_MATERIALS.has(type)) {
                        setPixel(screenX, screenY, 0, 0, 0); // Completely dark
                        continue;
                    }

                    // 1. Calculate the base color for the material.
                    let [r, g, b] = COLORS[type];

                    if (type === MAT.FIRE) {
                        r = 255; g = 80 + Math.random() * 80; b = 0;
                        firePixelsCoords.push({ x: screenX, y: screenY });
                    } else if (type === MAT.OIL_BURNING || type === MAT.COAL_BURNING) {
                         firePixelsCoords.push({ x: screenX, y: screenY });
                         [r, g, b] = animateLiquidColor(r, g, b, worldX, worldY, type, time);
                    } else if (LIQUIDS.has(type)) {
                        [r, g, b] = animateLiquidColor(r, g, b, worldX, worldY, type, time);
                    } else {
                        [r, g, b] = varyColor(r, g, b, worldX, worldY, type, 16);
                    }

                    // 2. NEW: Apply shimmer effect if the material is a metal.
                    if (SHIMMERING_METALS.has(type)) {
                        // This hash creates a pseudo-random value based on position and time.
                        // Dividing frameCount makes the shimmer slower and less frantic.
                        const shimmerHash = hashCell(worldX, worldY, Math.floor(frameCount / 4));
                        
                        // Only apply a shimmer on rare occasions (when the hash is a high value).
                        if (shimmerHash > 254) {
                            const shimmerBrightness = 35; // How much brighter to make the pixel.
                            r = Math.min(255, r + shimmerBrightness);
                            g = Math.min(255, g + shimmerBrightness);
                            b = Math.min(255, b + shimmerBrightness);
                        }
                    }

                    // 3. Apply brightness based on light level
                    if (!ALWAYS_VISIBLE_MATERIALS.has(type)) {
                        const brightness = lightLevel / MAX_LIGHT_LEVEL;
                        r *= brightness;
                        g *= brightness;
                        b *= brightness;
                    }

                    setPixel(screenX, screenY, r, g, b);
                }
            }

            ctx.putImageData(imageData, 0, 0);

            renderBloom();

            // --- NEW: RENDER RIGID BODIES ---
            for (const body of rigidBodies) {
                const pos = body.b2Body.GetPosition();
                const angle = body.b2Body.GetAngle();

                ctx.save(); // Save the current canvas state
                
                // Move and rotate the canvas to match the Box2D body
                ctx.translate(pos.get_x() * B2_SCALE - camera.x, pos.get_y() * B2_SCALE - camera.y);
                ctx.rotate(angle);

                // Now, draw the body's pixels centered at (0,0)
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const type = body.pixels[y * body.width + x];
                        if (type !== MAT.EMPTY) {
                            const [r, g, b] = varyColor(...COLORS[type], x, y, type, 8);
                            ctx.fillStyle = `rgb(${r},${g},${b})`;
                            
                            // Draw the pixel, offsetting by half the width/height to center it
                            ctx.fillRect(x - body.width / 2, y - body.height / 2, 1, 1);
                        }
                    }
                }

                ctx.restore(); // Restore the canvas state for the next object
            }
            // --- END OF NEW BLOCK ---

            const aimDX = mouse.worldX - (player.x + player.width / 2);
            const aimDY = (player.y + 9) - mouse.worldY;
            const aimAngle = Math.atan2(aimDY, aimDX);
            const wandDir = angleToDir16(aimAngle);

            playerFacingRight = aimDX >= 0;

            // --- PLAYER (SNAPPED FOR SHARPNESS) ---
            const playerScreenX = Math.round(player.x - camera.x);
            const playerScreenY = Math.round(player.y - camera.y);

            // Noita-like sprite colors
            const cloakColor = '#4a2d5e';
            const faceColor = '#211e20';
            const handColor = '#9d81a2';
            let wandScreenX, wandScreenY;

            ctx.imageSmoothingEnabled = false; // Ensure sharp pixels

            // --- 2x SCALED SPRITE DRAWING ---
            if (playerFacingRight) {
                // --- Body & Cloak ---
                ctx.fillStyle = cloakColor;
                ctx.fillRect(playerScreenX + 2, playerScreenY, 6, 2);     // Hood top
                ctx.fillRect(playerScreenX, playerScreenY + 2, 8, 12);    // Main body
                ctx.fillRect(playerScreenX + 2, playerScreenY + 14, 4, 2);    // Feet area
                // --- Face ---
                ctx.fillStyle = faceColor;
                ctx.fillRect(playerScreenX + 4, playerScreenY + 2, 2, 4);
                // Set aim origin
                wandScreenX = playerScreenX + 11;
                wandScreenY = playerScreenY + 9;
            } else { // Facing Left
                // --- Body & Cloak ---
                ctx.fillStyle = cloakColor;
                ctx.fillRect(playerScreenX, playerScreenY, 6, 2);         // Hood top
                ctx.fillRect(playerScreenX, playerScreenY + 2, 8, 12);    // Main body
                ctx.fillRect(playerScreenX + 2, playerScreenY + 14, 4, 2);    // Feet area
                // --- Face ---
                ctx.fillStyle = faceColor;
                ctx.fillRect(playerScreenX + 2, playerScreenY + 2, 2, 4);
                // Set aim origin
                wandScreenX = playerScreenX - 3;
                wandScreenY = playerScreenY + 9;
            }

            // --- Wand ---
            const handX = playerFacingRight
                ? playerScreenX + 8
                : playerScreenX - 1;

            const handY = playerScreenY + 9;

            const wandLen = 3;

            const dx = wandDir.x;
            const dy = wandDir.y;
            const mag = Math.max(Math.abs(dx), Math.abs(dy));

            ctx.fillStyle = '#bfa76a';
            for (let i = 0; i < wandLen; i++) {
                ctx.fillRect(
                    handX + Math.round(dx * i / mag),
                    handY + Math.round(dy * i / mag),
                    1,
                    1
                );
            }

            // Tip
            ctx.fillStyle = '#ffcc66';
            ctx.fillRect(
                handX + Math.round(dx * wandLen / mag),
                handY + Math.round(dy * wandLen / mag),
                1,
                1
            );

            // --- RENDER POURED PARTICLES ---
            for (const p of pouredParticles) {
                const [r,g,b] = COLORS[p.type];
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1);
            }

            // --- RENDER MAGIC PARTICLES ---
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (p.active) {
                    ctx.fillStyle = `rgb(${p.color[0]}, ${p.color[1]}, ${p.color[2]})`;
                    ctx.fillRect(Math.round(p.x - camera.x), Math.round(p.y - camera.y), 1, 1);
                }
            }

            // --- RENDER INTERACT HINT ---
            // Check if the player can interact and that a trigger is currently active
            if (player.canInteract && player.currentTrigger) {
                // Get the currently active trigger
                const trigger = player.currentTrigger;

                // 1. Calculate the base position: center-top of the trigger zone
                const hintX = Math.round(trigger.x - camera.x + trigger.width / 2);
                const hintY = Math.round(trigger.y - camera.y - 15); // 15 pixels above the slab

                // 2. Add the hover animation using a sine wave
                const hoverAmplitude = 3; // How many pixels to move up and down
                const hoverSpeed = 0.05;  // How fast to hover
                const animatedY = hintY + Math.sin(frameCount * hoverSpeed) * hoverAmplitude;

                // Draw a simple background for visibility
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(hintX - 8, animatedY - 12, 16, 16);
                
                // Draw the 'E'
                ctx.font = 'bold 12px monospace';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle'; // Center text vertically for smoother animation
                ctx.fillText('E', hintX, animatedY);
            }

            // --- AIM LINE ---
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(wandScreenX, wandScreenY);
            ctx.lineTo(mouse.x / scale, mouse.y / scale);
            ctx.stroke();

            renderPlayerStatsUI();
            renderAlchemyUI();
        }

        function createWoodenBox(x, y, width = 16, height = 16) {
            const box = new RigidBody(x, y, width, height, MAT.WOOD);
            rigidBodies.push(box);
        }

        /**
         * Handles interactions between the world grid and rigid bodies.
         * This version is memory-safe and performant, reusing global temporary
         * vectors instead of allocating new ones in a loop, preventing crashes.
         */
        function updateRigidBodyInteractions() {
            for (const body of rigidBodies) {
                if (body.isDestroyed) continue;

                const transform = body.b2Body.GetTransform();
                let pixelsChanged = false;

                body_pixel_loop:
                for (let y = 0; y < body.height; y++) {
                    for (let x = 0; x < body.width; x++) {
                        const localIdx = y * body.width + x;
                        const type = body.pixels[localIdx];

                        if (type === MAT.EMPTY) continue;

                        // --- THE MEMORY FIX ---
                        // REUSE the global tempVec1 instead of creating a 'new b2Vec2'.
                        tempVec1.set_x((x - body.width / 2 + 0.5) / B2_SCALE);
                        tempVec1.set_y((y - body.height / 2 + 0.5) / B2_SCALE);

                        // REUSE the existing non-allocating transformPoint function.
                        // The result is safely stored in the global tempVec2.
                        transformPoint(tempVec2, transform, tempVec1);
                        const worldX = Math.floor(tempVec2.get_x() * B2_SCALE);
                        const worldY = Math.floor(tempVec2.get_y() * B2_SCALE);
                        // --- END OF FIX ---


                        // --- MUTUALLY EXCLUSIVE LOGIC (UNCHANGED) ---

                        // BEHAVIOR 1: If this pixel is ALREADY FIRE, its job is to emit fire outwards.
                        if (type === MAT.FIRE) {
                            if (Math.random() < 0.05) {
                                const neighbors = [{ dx: 0, dy: 1 }, { dx: 0, dy: -1 }, { dx: 1, dy: 0 }, { dx: -1, dy: 0 }];
                                for (const n of neighbors) {
                                    const checkIdx = getIdx(worldX + n.dx, worldY + n.dy);
                                    if (checkIdx !== -1 && (grid[checkIdx] === MAT.EMPTY || grid[checkIdx] === MAT.GAS)) {
                                        setGrid(checkIdx, MAT.FIRE);
                                        break;
                                    }
                                }
                            }
                        }
                        // BEHAVIOR 2: If this pixel is WOOD, its job is to look for external fire.
                        else if (type === MAT.WOOD) {
                            const searchRadius = 2;
                            for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                                for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                                    const checkIdx = getIdx(worldX + dx, worldY + dy);
                                    if (checkIdx !== -1) {
                                        const worldMaterial = grid[checkIdx];
                                        // A) Check for Acid
                                        if (worldMaterial === MAT.ACID) {
                                            body.pixels[localIdx] = MAT.EMPTY;
                                            setGrid(checkIdx, MAT.EMPTY);
                                            pixelsChanged = true;
                                            continue body_pixel_loop;
                                        }
                                        // B) Check for Fire Sources
                                        else if ([MAT.FIRE, MAT.OIL_BURNING, MAT.COAL_BURNING].includes(worldMaterial)) {
                                            body.pixels[localIdx] = MAT.FIRE;
                                            pixelsChanged = true;
                                            continue body_pixel_loop;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Run the body's internal simulation (fire spreading within the wood)
                const localSetter = (idx, type) => {
                    if (idx !== -1 && body.pixels[idx] !== type) {
                        body.pixels[idx] = type;
                        pixelsChanged = true;
                    }
                };
                runSimulationOnSmallGrid(body.moved, body.pixels, body.width, body.height, localSetter);

                if (pixelsChanged) {
                    body.needsShapeUpdate = true;
                }
            }
        }

        /**
         * Top-level function to draw both inventory containers on the screen.
         */
        function renderContainers() {
            const pouchX = renderWidth - pouchWidth - 12;
            const flaskX = pouchX - flaskWidth - 8;
            const commonY = 40;

            renderContainer(pouchGrid, pouchWidth, pouchHeight, pouchX, commonY, activeContainer === 'pouch');
            renderContainer(flaskGrid, flaskWidth, flaskHeight, flaskX, commonY, activeContainer === 'flask');
        }

        /**
         * Draws a single container's border and its contents.
         */
        function renderContainer(cGrid, cW, cH, screenX, screenY, isActive) {
            // Draw background and border
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(screenX - 2, screenY - 2, cW + 4, cH + 4);
            ctx.strokeStyle = isActive ? 'white' : '#888'; // Highlight if active
            ctx.lineWidth = 2;
            ctx.strokeRect(screenX - 2, screenY - 2, cW + 4, cH + 4);

            // Draw contents
            for (let y = 0; y < cH; y++) {
                for (let x = 0; x < cW; x++) {
                    const type = cGrid[getIdx(x, y, cW, cH)];
                    if (type !== MAT.EMPTY) {
                        const [r, g, b] = varyColor(...COLORS[type], x, y, type, 8);
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fillRect(screenX + x, screenY + y, 1, 1);
                    }
                }
            }
        }

        function renderBloom() {
            if (firePixelsCoords.length === 0) return;

            // --- Configuration ---
            const bloomRadius = 6; // How far the glow extends, in pixels
            const bloomIntensity = 0.01; // How bright the glow is (0.0 to 1.0)
            const bloomColor = [180, 100, 50]; // The color of the glow (R, G, B)
            
            // Get the current canvas content so we can blend with it
            const screenData = ctx.getImageData(0, 0, renderWidth, renderHeight);
            const screenPixels = screenData.data;
            
            const r2 = bloomRadius * bloomRadius;

            // Iterate ONLY through the fire pixels we found earlier
            for (const p of firePixelsCoords) {
                // For each fire pixel, draw a glow "stamp" around it
                for (let dy = -bloomRadius; dy <= bloomRadius; dy++) {
                    for (let dx = -bloomRadius; dx <= bloomRadius; dx++) {
                        const distSq = dx * dx + dy * dy;
                        if (distSq > r2) continue;

                        const px = p.x + dx;
                        const py = p.y + dy;

                        // Bounds check
                        if (px < 0 || px >= renderWidth || py < 0 || py >= renderHeight) continue;
                        
                        // Calculate falloff: glow is strongest at the center
                        const falloff = (1.0 - (distSq / r2)) * bloomIntensity;
                        if (falloff <= 0) continue;
                        
                        const i = (py * renderWidth + px) * 4;

                        // Additive blending
                        screenPixels[i]     = Math.min(255, screenPixels[i]     + bloomColor[0] * falloff);
                        screenPixels[i + 1] = Math.min(255, screenPixels[i + 1] + bloomColor[1] * falloff);
                        screenPixels[i + 2] = Math.min(255, screenPixels[i + 2] + bloomColor[2] * falloff);
                    }
                }
            }

            // Put the modified pixel data (with bloom) back onto the canvas
            ctx.putImageData(screenData, 0, 0);
        }

        function angleToDir16(a) {
            const step = Math.PI / 8;
            const i = Math.round(a / step) & 15;
            return WAND_DIRS_16[i];
        }


        const WAND_DIRS_16 = [
            { x: 1,  y: 0 },
            { x: 2,  y: -1 },
            { x: 1,  y: -1 },
            { x: 1,  y: -2 },
            { x: 0,  y: -1 },
            { x: -1, y: -2 },
            { x: -1, y: -1 },
            { x: -2, y: -1 },
            { x: -1, y: 0 },
            { x: -2, y: 1 },
            { x: -1, y: 1 },
            { x: -1, y: 2 },
            { x: 0,  y: 1 },
            { x: 1,  y: 2 },
            { x: 1,  y: 1 },
            { x: 2,  y: 1 },
        ];

        function animateLiquidColor(r, g, b, x, y, type, time) {
            // Static grain (same as solids)
            const baseNoise = (hashCell(x, y, type) / 255 - 0.5) * 12;

            // Animated wave
            const wave = liquidWave(x, y, time) * 10;

            const delta = baseNoise + wave;

            return [
                Math.max(0, Math.min(255, r + delta)),
                Math.max(0, Math.min(255, g + delta)),
                Math.max(0, Math.min(255, b + delta))
            ];
        }

        function liquidWave(x, y, t) {
            return Math.sin(x * 0.15 + t) * 0.5 +
                Math.sin(y * 0.1  + t * 1.3) * 0.5;
        }

        function hashCell(x, y, type) {
            // Fast, deterministic hash
            let h = x * 374761393 + y * 668265263 + type * 1442695041;
            h = (h ^ (h >> 13)) * 1274126177;
            return (h ^ (h >> 16)) & 0xff; // 0..255
        }

        function varyColor(r, g, b, x, y, type, strength = 18) {
            // strength = max brightness change (try 12–24)
            const n = hashCell(x, y, type) / 255; // 0..1
            const delta = (n - 0.5) * strength * 2;

            return [
                Math.max(0, Math.min(255, r + delta)),
                Math.max(0, Math.min(255, g + delta)),
                Math.max(0, Math.min(255, b + delta))
            ];
        }

        function updateHoverMaterial() {
            const idx = getIdx(mouse.worldX, mouse.worldY);
            if (idx === -1) {
                hudMaterial = '--';
            } else {
                const type = grid[idx];
                hudMaterial = MATERIAL_NAME[type] || 'Unknown';
            }
        }


        function findGroundSurfaceY(x) {
            for (let y = 0; y < worldHeight; y++) { if (grid[getIdx(x, y)] !== MAT.EMPTY) return y; }
            return worldHeight - 1;
        }
        function drawTree(baseX, baseY) {
            const trunkHeight = 40 + Math.floor(Math.random() * 12); // Scaled height
            for (let i = 0; i < trunkHeight; i++) {
                const y = baseY - i; if (y < 0) continue;
                setGrid(getIdx(baseX, y), MAT.WOOD);
                if(i < 30) { // Scaled thickness
					setGrid(getIdx(baseX - 1, y), MAT.WOOD);
					setGrid(getIdx(baseX + 1, y), MAT.WOOD);
				}
            }
        }


        /**
         * Generates a horizontal slab with a background, inscribed runes, and border lines.
         * @param {number} slabX - The top-left X coordinate of the slab.
         * @param {number} slabY - The top-left Y coordinate of the slab.
         * @param {number} slabWidth - The width of the slab.
         * @param {number} slabHeight - The height of the slab.
         * @param {material} backgroundMaterial - The material for the slab's base.
         * @param {material} runeMaterial - The material for the inscribed runes and borders.
         */
        function generateRunicSlab(slabX, slabY, slabWidth, slabHeight, backgroundMaterial, runeMaterial) {
            // 1. Fill the entire slab area with the background material.
            for (let y = slabY; y < slabY + slabHeight; y++) {
                for (let x = slabX; x < slabX + slabWidth; x++) {
                    const idx = getIdx(x, y);
                    if (idx !== -1) setGrid(idx, backgroundMaterial);
                }
            }

            // --- Calculate vertical positioning ---
            const verticalPadding = Math.floor((slabHeight - DWARVEN_RUNES.RUNE_HEIGHT) / 2);
            const runesTopY = slabY + verticalPadding;
            const runesBottomY = runesTopY + DWARVEN_RUNES.RUNE_HEIGHT - 1;

            // NEW: 2. Draw the horizontal border lines.
            const lineThickness = 1; // You can make this thicker if you like
            const linePadding = 3;   // Pixels of space between the line and the runes

            // Top line
            const topLineY = runesTopY - linePadding;
            for (let t = 0; t < lineThickness; t++) {
                for (let x = slabX; x < slabX + slabWidth; x++) {
                    const idx = getIdx(x, topLineY - t);
                    if (idx !== -1) setGrid(idx, runeMaterial);
                }
            }
            
            // Bottom line
            const bottomLineY = runesBottomY + linePadding;
            for (let t = 0; t < lineThickness; t++) {
                for (let x = slabX; x < slabX + slabWidth; x++) {
                    const idx = getIdx(x, bottomLineY + t);
                    if (idx !== -1) setGrid(idx, runeMaterial);
                }
            }
            
            // --- Inscribe the runes ---
            const runePadding = 5;
            let cursorX = slabX + runePadding;

            // 3. Loop and stamp the runes.
            while (cursorX + DWARVEN_RUNES.RUNE_WIDTH + runePadding < slabX + slabWidth) {
                // ... (The rest of the rune stamping logic is exactly the same) ...
                const pattern = DWARVEN_RUNES.PATTERNS[Math.floor(Math.random() * DWARVEN_RUNES.PATTERNS.length)];

                for (let y = 0; y < DWARVEN_RUNES.RUNE_HEIGHT; y++) {
                    for (let x = 0; x < DWARVEN_RUNES.RUNE_WIDTH; x++) {
                        if (pattern[y][x] === 1) {
                            const drawX = cursorX + x;
                            const drawY = runesTopY + y;
                            const idx = getIdx(drawX, drawY);
                            if (idx !== -1) {
                                setGrid(idx, runeMaterial);
                            }
                        }
                    }
                }

                cursorX += DWARVEN_RUNES.RUNE_WIDTH + runePadding;
            }
        }

        /**
         * Creates a persistent particle emitter that spawns particles over time.
         * Can spawn from an area or along a line.
         * @param {object} options - An object with configuration for the emitter.
         * @returns {number} The unique ID of the created emitter.
         */
        function createMagicEmitter(options) {
            const emitter = {
                id: nextEmitterId++,
                mainColor: options.mainColor || [255, 255, 255],
                spawnRate: options.spawnRate || 0.2,
                
                // --- NEW: Spawning type and coordinates ---
                spawnType: options.spawnType || 'area', // Can be 'area' or 'line'
                
                // Properties for 'area' type (the original behavior)
                x: options.x || 0,
                y: options.y || 0,
                spawnArea: options.spawnArea || { width: 10, height: 5 },
                
                // Properties for 'line' type
                x1: options.x1 || 0,
                y1: options.y1 || 0,
                x2: options.x2 || 0,
                y2: options.y2 || 0,

                // --- Particle-specific properties (remain the same) ---
                particleLifespan: options.particleLifespan || { min: 60, max: 150 },
                particleVelocity: options.particleVelocity || { 
                    vx: { min: -0.2, max: 0.2 },
                    vy: { min: -0.2, max: -0.6 }
                },
                colorVariance: options.colorVariance || 60
            };
            magicEmitters.push(emitter);
            return emitter.id;
        }

        /**
         * Removes a magic particle emitter by its unique ID.
         * @param {number} id - The ID of the emitter to remove.
         */
        function removeMagicEmitter(id) {
            magicEmitters = magicEmitters.filter(e => e.id !== id);
        }
        
        /**
         * Updates all active emitters, spawning new particles based on their configuration.
         * This function handles both 'area' and 'line' spawn types.
         */
        function updateMagicEmitters() {
            // Loop through every active emitter
            for (const emitter of magicEmitters) {
                // Use the spawnRate as a probability check for this frame
                if (Math.random() < emitter.spawnRate) {
                    
                    // Find an available (inactive) particle in the dedicated magic particle pool
                    for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                        const p = magicParticlePool[i];
                        if (!p.active) {
                            let spawnX, spawnY;

                            // --- Determine the particle's starting position based on emitter type ---
                            if (emitter.spawnType === 'line') {
                                // Pick a random point along the line using linear interpolation.
                                // A 't' value of 0 is the start of the line, 1 is the end.
                                const t = Math.random(); 
                                spawnX = emitter.x1 + t * (emitter.x2 - emitter.x1);
                                spawnY = emitter.y1 + t * (emitter.y2 - emitter.y1);
                            } else { // Default to 'area' if spawnType is not 'line'
                                spawnX = emitter.x + (Math.random() - 0.5) * emitter.spawnArea.width;
                                spawnY = emitter.y + (Math.random() - 0.5) * emitter.spawnArea.height;
                            }
                            
                            // --- Full Color Variance Logic ---
                            // Take the emitter's base color and add/subtract a random amount from each channel.
                            const r = Math.max(0, Math.min(255, emitter.mainColor[0] + (Math.random() - 0.5) * emitter.colorVariance));
                            const g = Math.max(0, Math.min(255, emitter.mainColor[1] + (Math.random() - 0.5) * emitter.colorVariance));
                            const b = Math.max(0, Math.min(255, emitter.mainColor[2] + (Math.random() - 0.5) * emitter.colorVariance));
                            
                            // --- Activate and configure the particle with all its properties ---
                            p.active = true;
                            p.x = spawnX;
                            p.y = spawnY;
                            p.vx = emitter.particleVelocity.vx.min + Math.random() * (emitter.particleVelocity.vx.max - emitter.particleVelocity.vx.min);
                            p.vy = emitter.particleVelocity.vy.min + Math.random() * (emitter.particleVelocity.vy.max - emitter.particleVelocity.vy.min);
                            p.lifespan = emitter.particleLifespan.min + Math.random() * (emitter.particleLifespan.max - emitter.particleLifespan.min);
                            p.color = [r, g, b];
                            
                            // We've successfully spawned a particle, so we can exit the inner loop.
                            break; 
                        }
                    }
                }
            }
        }

        /**
         * Spawns exhaust particles from the player's feet when levitating.
         * @param {number} count - The number of particles to attempt to spawn this frame.
         */
        function spawnLevitationParticles(count) {
            let spawnedCount = 0;
            // Base position is the center of the player's feet
            const baseX = player.x + player.width / 2;
            const baseY = player.y + player.height - 2; // Start the trail slightly inside the player model

            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) {
                    p.active = true;

                    // Position with slight horizontal randomness for a "cone" shape
                    p.x = baseX + (Math.random() - 0.5) * 4;
                    p.y = baseY + (Math.random() - 0.5) * 2;

                    // Velocity: Shoots downwards and spreads out.
                    // It's also slightly affected by the player's own upward speed to make it "lag behind".
                    p.vx = (Math.random() - 0.5) * 0.5;
                    p.vy = (Math.random() * 0.8) + 0.4 - (player.vy * 0.1);

                    // Color: A blueish-white "magic energy" color with some variance
                    const baseColor = [180, 200, 255];
                    const colorVariance = 40;
                    p.color = [
                        Math.max(0, Math.min(255, baseColor[0] + (Math.random() - 0.5) * colorVariance)),
                        Math.max(0, Math.min(255, baseColor[1] + (Math.random() - 0.5) * colorVariance)),
                        Math.max(0, Math.min(255, baseColor[2] + (Math.random() - 0.5) * colorVariance))
                    ];

                    // Lifespan: Particles last for less than a second
                    p.lifespan = 15 + Math.random() * 20;

                    spawnedCount++;
                    if (spawnedCount >= count) {
                        return; // We've spawned enough particles for this frame
                    }
                }
            }
        }

        /**
         * The main function to create a burst of magic particles at a specific location, using the object pool.
         * @param {number} count - The number of particles to create.
         * @param {number} x - The center X coordinate of the spawn area.
         * @param {number} y - The center Y coordinate of the spawn area.
         * @param {Array<number>} mainColor - The base color as an [R, G, B] array.
         */
        function spawnMagicParticles(count, x, y, mainColor) {
            let spawnedCount = 0;
            // Search the pool for an inactive particle to reuse
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) {
                    // --- Activate and configure the particle ---

                    p.active = true;

                    // 1. Create variance in the spawn position
                    p.x = x + (Math.random() - 0.5) * 20;
                    p.y = y + (Math.random() - 0.5) * 10;

                    // 2. Create the color with a random hue shift from the main color
                    const colorVariance = 60;
                    const r = Math.max(0, Math.min(255, mainColor[0] + (Math.random() - 0.5) * colorVariance));
                    const g = Math.max(0, Math.min(255, mainColor[1] + (Math.random() - 0.5) * colorVariance));
                    const b = Math.max(0, Math.min(255, mainColor[2] + (Math.random() - 0.5) * colorVariance));
                    p.color = [r, g, b];

                    // 3. Particles float upwards with a slight horizontal drift
                    p.vx = (Math.random() - 0.5) * 0.3;
                    p.vy = -0.2 + (Math.random() * -0.4);
                    
                    // 4. They last for about 1-2.5 seconds (at 60fps)
                    p.lifespan = 60 + Math.random() * 90;

                    spawnedCount++;
                    if (spawnedCount >= count) {
                        // We have spawned the requested number of particles, so we can stop searching.
                        return;
                    }
                }
            }
        }

        function updateMagicParticles() {
            for (let i = 0; i < MAX_MAGIC_PARTICLES; i++) {
                const p = magicParticlePool[i];
                if (!p.active) continue;

                p.x += p.vx;
                p.y += p.vy;
                p.lifespan--;

                if (p.lifespan <= 0) {
                    p.active = false;
                }
            }
        }

        /**
         * Helper function to find the most common storable material in a given area.
         * @returns {number|null} The material ID (e.g., MAT.SAND) or null if the area is empty.
         */
        function getDominantMaterialInArea(x, y, width, height) {
            const counts = {};
            let maxCount = 0;
            let dominantMaterial = null;

            for (let iy = y; iy < y + height; iy++) {
                for (let ix = x; ix < x + width; ix++) {
                    const idx = getIdx(ix, iy);
                    if (idx === -1) continue;
                    const type = grid[idx];
                    // Only count materials that can actually be stored/manipulated
                    if (STORABLE_SOLIDS.has(type) || STORABLE_LIQUIDS.has(type)) {
                        counts[type] = (counts[type] || 0) + 1;
                        if (counts[type] > maxCount) {
                            maxCount = counts[type];
                            dominantMaterial = type;
                        }
                    }
                }
            }
            return dominantMaterial;
        }

        /**
         * Manages alchemy jobs by teleporting materials from a manifest
         * to a location above the target cauldron.
         */
        function processAlchemyJobs() {
            if (alchemyJobs.length === 0) return;

            // How many particles to teleport per frame. Controls the stream's speed.
            const particlesToTeleportThisFrame = 5; 

            for (let i = alchemyJobs.length - 1; i >= 0; i--) {
                const job = alchemyJobs[i];

                for (let j = 0; j < particlesToTeleportThisFrame; j++) {
                    // If the manifest is empty, the job is complete.
                    if (job.manifest.length === 0) {
                        alchemyJobs.splice(i, 1);
                        break; 
                    }

                    // Pull one particle's info from the manifest.
                    const materialInfo = job.manifest.shift();

                    // --- THE FIX: The Teleportation ---
                    // 1. Define a spawn zone in the air above the target cauldron.
                    const spawnX = job.target.x + (job.target.w * 0.1) + (Math.random() * job.target.w * 0.5);
                    const spawnY = job.target.y - (5 + Math.random() * 10); // 5 to 15 pixels above the rim.

                    // 2. Find the grid index for this spawn point.
                    const spawnIdx = getIdx(spawnX, spawnY);

                    // 3. If the spot in the air is empty, place the material there.
                    if (spawnIdx !== -1 && grid[spawnIdx] === MAT.EMPTY) {
                        setGrid(spawnIdx, materialInfo.type);
                        
                        // 4. Activate the chunk to let the main physics engine take over.
                        activateChunkAt(spawnX, spawnY);
                    } else {
                        // If the air is somehow crowded, put the particle back in the job to try again next frame.
                        // This guarantees no material is ever lost.
                        job.manifest.unshift(materialInfo);
                    }
                }
            }
        }

        // --- THE ALCHEMY REACTION REGISTRY ---
        const ALCHEMY_REACTIONS = {
            'filter_material': {
                name: "Filter Material",
                description: "Moves materials from the left cauldron to the right, based on the sampler.",
                execute: function(station) {
                    console.log("Executing Filter Material reaction!");
                    
                    const filterMaterial = getDominantMaterialInArea(
                        station.sampler.x, station.sampler.y, station.sampler.w, station.sampler.h
                    );

                    if (filterMaterial === null) {
                        console.log("Sampler is empty. Nothing to filter.");
                        return;
                    }
                    console.log(`Filtering for: ${MATERIAL_NAME[filterMaterial]}`);

                    const source = station.cauldrons.left;
                    const target = station.cauldrons.right;
                    let translationManifest = [];

                    // 1. Create a simple manifest of the material to be moved.
                    for (let y = source.y; y < source.y + source.h; y++) {
                        for (let x = source.x; x < source.x + source.w; x++) {
                            const idx = getIdx(x, y);
                            if (idx !== -1 && grid[idx] === filterMaterial) {
                                // The manifest now only needs the type. The source location is irrelevant.
                                translationManifest.push({ type: grid[idx] });
                                setGrid(idx, MAT.EMPTY);
                                activateChunkAt(x, y);
                            }
                        }
                    }

                    if (translationManifest.length === 0) {
                        console.log("No matching materials found.");
                        return;
                    }

                    // 2. Create the job, providing the manifest and the target geometry.
                    alchemyJobs.push({
                        manifest: translationManifest,
                        target: target
                    });
                }
            },
            // --- START OF NEW CODE ---
            'heat_material': {
                name: "Heat Material",
                description: "Heats the material in the left cauldron, causing reactions.",
                execute: function(station) {
                    console.log("Executing Heat Material reaction!");
                    const source = station.cauldrons.left;

                    // Spawn some fire/heat particles for visual effect
                    spawnMagicParticles(50, source.x + source.w / 2, source.y + source.h / 2, [255, 100, 0]);

                    for (let y = source.y; y < source.y + source.h; y++) {
                        for (let x = source.x; x < source.x + source.w; x++) {
                            const idx = getIdx(x, y);
                            if (idx === -1) continue;

                            const type = grid[idx];
                            let changed = true;
                            switch (type) {
                                case MAT.SAND:
                                    setGrid(idx, MAT.GLASS);
                                    break;
                                case MAT.WOOD:
                                    setGrid(idx, MAT.FIRE);
                                    break;
                                case MAT.OIL:
                                    setGrid(idx, MAT.OIL_BURNING);
                                    break;
                                case MAT.COAL:
                                    setGrid(idx, MAT.COAL_BURNING);
                                    break;
                                case MAT.GUNPOWDER:
                                    setGrid(idx, MAT.GUNPOWDER_IGNITED);
                                    ignitionTimer[idx] = 8 + Math.floor(Math.random() * 6);
                                    break;
                                case MAT.WATER:
                                    setGrid(idx, MAT.GAS);
                                    break;
                                default:
                                    changed = false;
                                    break;
                            }
                            if (changed) {
                                activateChunkAt(x, y);
                            }
                        }
                    }
                }
            },
            'clear_cauldrons': {
                name: "Clear Cauldrons",
                description: "Clears all materials from both cauldrons and the sampler.",
                execute: function(station) {
                    console.log("Executing Clear Cauldrons reaction!");
                    const areasToClear = [
                        station.cauldrons.left,
                        station.cauldrons.right,
                        station.sampler
                    ];

                    for (const area of areasToClear) {
                        // Visual effect for clearing
                        spawnMagicParticles(30, area.x + area.w / 2, area.y, [200, 200, 255]);
                        for (let y = area.y; y < area.y + area.h; y++) {
                            for (let x = area.x; x < area.x + area.w; x++) {
                                const idx = getIdx(x, y);
                                if (idx !== -1 && grid[idx] !== MAT.ADAMANTIUM) {
                                    setGrid(idx, MAT.EMPTY);
                                    activateChunkAt(x, y);
                                }
                            }
                        }
                    }
                }
            }
            // ... more reactions can be added here ...
        };

        /**
         * Clears a large space and generates the fixed alchemy station with a solid floor.
         */
        function generateAlchemyStation() {
            const stationWidth = 600;
            const stationHeight = 200;
            const startX = 0; 
            const startY = 5;
            const floorY = startY + stationHeight - 20;

            // 1. Carve out a huge, clean room.
            for (let y = startY; y < startY + stationHeight; y++) {
                for (let x = startX; x < startX + stationWidth; x++) {
                    const idx = getIdx(x, y);
                    if (idx !== -1) setGrid(idx, MAT.EMPTY);
                }
            }
            
            // 2. Build the solid Adamantium floor.
            for (let y = floorY; y < startY + stationHeight; y++) {
                for (let x = startX; x < startX + stationWidth; x++) {
                    setGrid(getIdx(x, y), MAT.ADAMANTIUM);
                }
            }

            // NEW: 3. Generate the decorative Runic Slab backdrop.
            const slabHeight = 15;
            const slabWidth = 70;
            const slabY = floorY - slabHeight; // Place it right on top of the floor
            const slabX = startX + 130;
            // We use the Rune Wall material as the base and Adamantium for the inscription
            generateRunicSlab(slabX, slabY, slabWidth, slabHeight, MAT.ADAMANTIUM, MAT.RUNE_WALL);

            // 3. Define the positions for the cauldrons and sampler.
            const leftCauldronX = startX + 260;
            const rightCauldronX = startX + 390;
            const samplerX = startX + 325;
            
            // 4. Create the components.
            // The cauldron's rim will be a few pixels above the main floor, making it protrude.
            const rimHeightAboveFloor = 15;
            const cauldronRimY = floorY - rimHeightAboveFloor;

            // Use the new, correct function
            // Left Cauldron
            createCauldron(leftCauldronX, cauldronRimY, 32, 4, MAT.ADAMANTIUM);
            // Right Cauldron
            createCauldron(rightCauldronX, cauldronRimY, 32, 4, MAT.ADAMANTIUM);
            // Sampler in the middle
            createCauldron(samplerX, floorY - 5, 8, 2, MAT.ADAMANTIUM);

            const stationGeometry = {
                cauldrons: {
                    left: { x: leftCauldronX - 25, y: cauldronRimY, w: 64, h: 32 },
                    right: { x: rightCauldronX - 25, y: cauldronRimY, w: 64, h: 32 }
                },
                sampler: { x: samplerX - 8, y: floorY - 5, w: 16, h: 8 }
            };

            // Create the trigger with our custom onEnter and onLeave logic
            createTrigger({
                x: slabX,
                y: slabY,
                width: slabWidth,
                height: slabHeight,
                onEnter: function(trigger) {
                    // This function is called when the player steps ON the slab.
                    console.log("Player entered the sampler zone.");
                    
                    // Create a special gold-colored emitter on the slab
                    const emitterId = createMagicEmitter({
                        spawnType: 'line',
                        x1: slabX, y1: slabY,
                        x2: slabX + slabWidth, y2: slabY,
                        mainColor: [255, 230, 100], // Gold
                        spawnRate: 0.5 // Spawn a particle every 2 frames on average
                    });
                    
                    // IMPORTANT: Store the ID of the emitter we just created inside the trigger.
                    trigger.associatedData.emitterId = emitterId;
                },
                onLeave: function(trigger) {
                    // This function is called when the player steps OFF the slab.
                    console.log("Player left the sampler zone.");
                    
                    // Use the stored ID to find and remove the correct emitter.
                    if (trigger.associatedData.emitterId != null) {
                        removeMagicEmitter(trigger.associatedData.emitterId);
                        trigger.associatedData.emitterId = null; // Clear the stored ID
                    }
                },
                onInteract: function(trigger) {
                    // This function is called when the player presses "E" inside the zone.
                    console.log("Player INTERACTED with the sampler! Time for alchemy!");
                    isAlchemyUIVisible = true;
                },
                associatedData: {
                    stationGeometry: stationGeometry
                }
            });
        }

        /**
         * Creates a hollow, downward-facing cauldron bowl, set into a surface.
         * It draws a solid depression first, then carves the empty space inside.
         * @param {number} cx - The center X coordinate of the cauldron.
         * @param {number} rimY - The Y coordinate for the cauldron's rim (the surface level).
         * @param {number} radius - The outer radius of the cauldron.
         * @param {number} thickness - The thickness of the cauldron's wall and floor.
         * @param {material} material - The material to build the cauldron from.
         */
        function createCauldron(cx, rimY, radius, thickness, material) {
            const outerRadiusSq = radius * radius;
            const innerRadius = radius - thickness;
            const innerRadiusSq = innerRadius * innerRadius;

            // 1. Draw the SOLID outer shape of the cauldron's bowl, facing DOWN.
            // This carves a solid half-sphere depression into the floor.
            for (let dy = 0; dy <= radius; dy++) { // CHANGED: Loop from 0 to +radius
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy <= outerRadiusSq) {
                        const idx = getIdx(cx + dx, rimY + dy);
                        if (idx !== -1) {
                            setGrid(idx, material);
                        }
                    }
                }
            }

            // 2. Carve the EMPTY hollow interior, leaving the walls and bottom intact.
            for (let dy = 0; dy < innerRadius; dy++) { // CHANGED: Loop from 0 to +innerRadius
                for (let dx = -innerRadius; dx <= innerRadius; dx++) {
                     if (dx * dx + dy * dy <= innerRadiusSq) {
                        const idx = getIdx(cx + dx, rimY + dy);
                        if (idx !== -1) {
                            setGrid(idx, MAT.EMPTY);
                        }
                    }
                }
            }
        }

        /**
         * Generates caves with Perlin noise, including four thick, unbroken, noisy
         * horizontal bands that separate the world's five layers. Each band uses the
         * wall material of the layer below it.
         */
        function generateCavesWithPerlinNoise(width, height, grid) {
            const scale = 150;
            const depthBiasStrength = 0.1;
            const layerHeight = height / 5;

            const layerWallMaterials = [
                MAT.SANDSTONE_WALL, // Layer 1 (index 0)
                MAT.ROCK_WALL,      // Layer 2 (index 1)
                MAT.VOLCANIC_WALL,  // Layer 3 (index 2)
                MAT.LABYRINTH_WALL, // Layer 4 (index 3)
                MAT.MAGIC_WALL      // Layer 5 (index 4)
            ];
            const GENERATION_TIERS = [
                { material: MAT.COPPER,   threshold: 0.70 },
                { material: MAT.SILVER,   threshold: 0.75 },
                { material: MAT.GOLD,     threshold: 0.85 },
                { material: MAT.PLATINUM, threshold: 0.99 }
            ];
            const octaves = 4;
            const persistence = 0.5;
            const lacunarity = 2;

            // --- Band Configuration ---
            const bandCentersY = [
                layerHeight,      // Between layer 1 and 2
                layerHeight * 2,  // Between layer 2 and 3
                layerHeight * 3,  // Between layer 3 and 4
                layerHeight * 4   // Between layer 4 and 5
            ];
            const bandHalfHeight = 50;
            const bandNoiseFrequency = 0.004;
            const bandNoiseAmplitude = 60;
            // We no longer use a single band material.

            PerlinNoise.seed(12345 * Math.random() + 10000);

            for (let y = 0; y < height; y++) {
                const depthFactor = y / height;
                const currentDepthBias = depthFactor * depthBiasStrength;
                
                const layerIndex = Math.min(layerWallMaterials.length - 1, Math.floor(y / layerHeight));
                const baseWallType = layerWallMaterials[layerIndex];

                for (let x = 0; x < width; x++) {
                    
                    // --- Modified Band Generation Logic ---
                    let isInBand = false;
                    // Use an indexed loop to determine the correct material
                    for (let i = 0; i < bandCentersY.length; i++) {
                        const centerY = bandCentersY[i];
                        // The band material is the wall type of the layer *below* it.
                        // The first band (i=0) uses the wall from layer 2 (index 1).
                        const bandMaterial = layerWallMaterials[i + 1];

                        const noiseOffset = PerlinNoise.noise(x * bandNoiseFrequency, centerY) * bandNoiseAmplitude;
                        const noisyCenterY = centerY + noiseOffset;

                        if (y >= noisyCenterY - bandHalfHeight && y <= noisyCenterY + bandHalfHeight) {
                            setGrid(getIdx(x, y), bandMaterial);
                            isInBand = true;
                            break;
                        }
                    }

                    if (isInBand) {
                        continue;
                    }

                    // --- Existing Cave & Ore Generation Logic ---
                    let totalNoise = 0;
                    let frequency = 1;
                    let amplitude = 1;
                    let maxAmplitude = 0;
                    for (let i = 0; i < octaves; i++) {
                        const noiseValue = (PerlinNoise.noise(x*frequency/scale, y*frequency/scale)+1)/2;
                        totalNoise += noiseValue * amplitude;
                        maxAmplitude += amplitude;
                        amplitude *= persistence;
                        frequency *= lacunarity;
                    }
                    const finalNoise = totalNoise / maxAmplitude;

                    let materialToPlace = MAT.EMPTY;
                    if (finalNoise >= 0.52 - currentDepthBias) {
                        materialToPlace = baseWallType;
                    }
                    for (const tier of GENERATION_TIERS) {
                        if (finalNoise >= tier.threshold - currentDepthBias) {
                            materialToPlace = tier.material;
                        }
                    }
                    if (materialToPlace !== MAT.EMPTY) {
                        setGrid(getIdx(x, y), materialToPlace);
                    }
                }
            }
        }

        /**
         * Takes all potentially active chunks, sorts them by priority (on-screen, then distance to player),
         * and limits the number of off-screen chunks to be processed in a single frame.
         * @returns {void} - This function directly modifies the global activeChunks and pendingActiveChunks variables.
         */
        function prioritizeAndLimitActiveChunks() {
            // 1. Combine newly activated chunks with any that were deferred from the last frame.
            const allChunksToConsider = new Set([...pendingActiveChunks, ...nextActiveChunks]);
            nextActiveChunks.clear(); // Clear for the next simulation step.

            // 2. Separate chunks into on-screen (high priority) and off-screen (lower priority).
            const priorityChunks = new Set();
            const otherChunks = [];
            const camChunkX1 = Math.floor(camera.x / CHUNK_SIZE);
            const camChunkX2 = Math.floor((camera.x + viewWidth) / CHUNK_SIZE);
            const camChunkY1 = Math.floor(camera.y / CHUNK_SIZE);
            const camChunkY2 = Math.floor((camera.y + viewHeight) / CHUNK_SIZE);

            for (const chunk of allChunksToConsider) {
                const cx = chunk.index % chunkWidth;
                const cy = Math.floor(chunk.index / chunkWidth);
                if (cx >= camChunkX1 && cx <= camChunkX2 && cy >= camChunkY1 && cy <= camChunkY2) {
                    priorityChunks.add(chunk);
                } else {
                    otherChunks.push(chunk);
                }
            }

            // 3. Sort the off-screen chunks by their distance to the player (closest first).
            const playerChunkX = Math.floor(player.x / CHUNK_SIZE);
            const playerChunkY = Math.floor(player.y / CHUNK_SIZE);
            otherChunks.sort((a, b) => {
                const aX = a.index % chunkWidth;
                const aY = Math.floor(a.index / chunkWidth);
                const bX = b.index % chunkWidth;
                const bY = Math.floor(b.index / chunkWidth);
                const distA = (aX - playerChunkX)**2 + (aY - playerChunkY)**2;
                const distB = (bX - playerChunkX)**2 + (bY - playerChunkY)**2;
                return distA - distB;
            });
            
            // 4. Create the final processing list for this frame.
            const processingOrder = [...priorityChunks, ...otherChunks];

            // 5. Apply the limit and update the global variables for the simulation.
            const chunksToProcess = processingOrder.slice(0, priorityChunks.size + MAX_CHUNKS_PER_FRAME);
            pendingActiveChunks = processingOrder.slice(priorityChunks.size + MAX_CHUNKS_PER_FRAME);
            activeChunks = new Set(chunksToProcess);
        }

        // --- GAME LOOP ---
        function gameLoop(now = performance.now()) {
            frameCount++;
            framesThisSecond++;
            if (now - lastFpsTime >= 1000) {
                hudFPS = framesThisSecond;
                framesThisSecond = 0;
                lastFpsTime = now;
            }

            for (const body of bodiesToDestroy) {
                if (body) box2dWorld.DestroyBody(body);
            }
            bodiesToDestroy = [];

            if (frameCount % VISIBLE_LIQUID_SCAN_INTERVAL === 0) {
                findAndActivateVisibleLiquidSurfaces();
            }
            prioritizeAndLimitActiveChunks();

            // --- UPDATE LOGIC ---
            updatePlayer();
            updateRigidBodyInteractions();
            updateRigidBodies(now);
            syncPlayerWithBody();

            updateRigidBodyGrid();

            const newBodiesFromSplits = [];

            // Use a reverse loop because we might be marking bodies for removal.
            for (let i = rigidBodies.length - 1; i >= 0; i--) {
                const body = rigidBodies[i];
                if (body.needsShapeUpdate && (now - body.lastRebuildTime > REBUILD_COOLDOWN)) {
                    
                    // First, check if the damage caused a split.
                    const newPieces = checkForSplits(body);

                    if (newPieces) {
                        // If it split, add the new pieces to a temporary list.
                        newBodiesFromSplits.push(...newPieces);
                    } else {
                        // If it didn't split, just rebuild its fixtures as normal.
                        body.rebuildFixtures();
                        body.lastRebuildTime = now;
                    }
                }
            }

            // Add any newly created bodies to the main simulation list.
            if (newBodiesFromSplits.length > 0) {
                rigidBodies.push(...newBodiesFromSplits);
            }
            
            cleanupDestroyedBodies(); // Safely remove bodies that have burned away

            updatePouredParticles();
            processAlchemyJobs();
            updateMagicParticles();
            updateMagicEmitters(); 
            updateTriggers();

            // --- NEW PROPAGATING LOCAL LIGHTING ---
            // This BFS will process the initial active chunks and any others connected by visible materials.
            const lightingQueue = [...activeChunks];     // Seed the queue with physics-active chunks
            const processedChunks = new Set(activeChunks); // Keep track of what's been processed this frame

            let head = 0;
            while (head < lightingQueue.length) {
                const chunkToUpdate = lightingQueue[head++];
                const newlyActivatedNeighbors = updateLocalLightingAndFindNeighbors(chunkToUpdate);

                for (const neighbor of newlyActivatedNeighbors) {
                    if (!processedChunks.has(neighbor)) {
                        processedChunks.add(neighbor);
                        lightingQueue.push(neighbor);
                    }
                }
            }

            // if (frameCount % LIGHTING_UPDATE_INTERVAL === 0) {
            //     updateLighting();
            // }

            if (isPouring) {
                pourFromContainer();
            }

            // Add this block to continuously store
            if (isStoring) {
                storeMaterial(mouse.worldX, mouse.worldY);
            }

            // Activate the chunk the mouse is currently interacting with
            if (isDrawing || isPouring || isStoring) {
                activateChunkAt(mouse.worldX, mouse.worldY);
            }

            // --- SIMULATIONS ---
            for (let i = 0; i < SIMULATION_STEPS_PER_FRAME; i++) {
                runWorldSimulationWithChunks(movedWorld);
                if (i === 0) {
                   // These two lines are now only for the player's inventory
                   const pouchSetter = (idx, type) => { if (idx !== -1) pouchGrid[idx] = type; };
                   runSimulationOnSmallGrid(movedPouch, pouchGrid, pouchWidth, pouchHeight, pouchSetter);
                   
                   const flaskSetter = (idx, type) => { if (idx !== -1) flaskGrid[idx] = type; };
                   runSimulationOnSmallGrid(movedFlask, flaskGrid, flaskWidth, flaskHeight, flaskSetter);
                }
            }
            
            updateCamera();
            mouse.worldX = Math.floor(camera.x + mouse.x / scale);
            mouse.worldY = Math.floor(camera.y + mouse.y / scale);

            // --- RENDER LOGIC ---
            render();
            renderContainers();
            drawHUD();
            
            if ((frameCount % 2) === 0) { // Update hover material at 30fps
                updateHoverMaterial();
            }

            requestAnimationFrame(gameLoop);
        }

        function cleanupDestroyedBodies() {
            rigidBodies = rigidBodies.filter(body => {
                if (body.isDestroyed || body.isSplit) {
                    // "Collect" the b2Body for destruction later.
                    bodiesToDestroy.push(body.b2Body);
                    // Remove the wrapper object from our game's array.
                    return false; 
                }
                return true;
            });
        }

        function updateUI()
        {
            if ((hudTimer++ & 1) === 0) { // ~30 Hz
                updateHoverMaterial();
            }
            hudFPS = fps;

        }

        function drawHUD() {
            const padding = 6;
            const x = renderWidth - 6;
            const y = 6;

            ctx.imageSmoothingEnabled = false;
            ctx.font = '12px monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(
                renderWidth - 150,
                4,
                146,
                34
            );

            // Text
            ctx.fillStyle = '#00ff90';
            ctx.fillText(`FPS: ${hudFPS}`, x, y);

            ctx.fillStyle = '#ffd966';
            ctx.fillText(`MAT: ${hudMaterial}`, x, y + 14);
        }

        /**
         * Creates a new trigger zone and adds it to the world.
         * @param {object} options - Configuration for the trigger.
         * @returns {number} The unique ID of the trigger.
         */
        function createTrigger(options) {
            const trigger = {
                id: nextTriggerId++,
                x: options.x,
                y: options.y,
                width: options.width,
                height: options.height,
                onEnter: options.onEnter || function() {}, // What to do when player enters
                onLeave: options.onLeave || function() {}, // What to do when player leaves
                onInteract: options.onInteract || function() {},
                isActive: false, // Tracks if the player is currently inside
                // A generic object to store any data this trigger needs to remember, like an emitter ID.
                associatedData: options.associatedData 
            };
            triggers.push(trigger);
            return trigger.id;
        }

        /**
         * Checks the player's position against all triggers and manages interaction state.
         * Now includes a vertical leeway to work correctly with the Box2D physics engine.
         */
        function updateTriggers() {
            const playerCheckX = player.x + player.width / 2;
            const playerCheckY = player.y + player.height;
            
            // NEW: A small tolerance to detect "standing on" a trigger in a physics world.
            const verticalLeeway = 2; // 2 pixels

            let canCurrentlyInteract = false;
            let activeTrigger = null;

            for (const trigger of triggers) {
                const isPlayerInside = (
                    playerCheckX >= trigger.x &&
                    playerCheckX <= trigger.x + trigger.width &&
                    // CORRECTED CHECK: Allow player's feet to be slightly *above* the trigger's top edge.
                    playerCheckY >= trigger.y - verticalLeeway && 
                    playerCheckY <= trigger.y + trigger.height
                );

                if (isPlayerInside) {
                    canCurrentlyInteract = true;
                    activeTrigger = trigger;

                    if (!trigger.isActive) {
                        trigger.isActive = true;
                        trigger.onEnter(trigger);
                    }
                } else {
                    if (trigger.isActive) {
                        trigger.isActive = false;
                        trigger.onLeave(trigger);
                    }
                }
            }

            player.canInteract = canCurrentlyInteract;
            player.currentTrigger = activeTrigger;
        }

        /**
         * Renders the alchemy reaction selection UI when it's active.
         */
        function renderAlchemyUI() {
            if (!isAlchemyUIVisible) return;

            // Draw a semi-transparent background to dim the game
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, renderWidth, renderHeight);

            // Draw the main UI box
            const boxWidth = 300;
            const boxHeight = 150;
            const boxX = (renderWidth - boxWidth) / 2;
            const boxY = (renderHeight - boxHeight) / 2;
            ctx.fillStyle = '#222';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeStyle = '#888';
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

            // Draw text
            ctx.fillStyle = 'white';
            ctx.font = '16px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText("Select a Reaction:", boxX + 10, boxY + 10);

            // List all available reactions from our registry
            let yOffset = 40;
            let reactionIndex = 1;
            for (const key in ALCHEMY_REACTIONS) {
                const reaction = ALCHEMY_REACTIONS[key];
                ctx.fillText(`[${reactionIndex}] ${reaction.name}`, boxX + 20, boxY + yOffset);
                yOffset += 20;
                reactionIndex++;
            }

            ctx.fillStyle = '#aaa';
            ctx.fillText("Press [ESC] to close.", boxX + 10, boxY + boxHeight - 25);
        }

        /**
         * Updates the text content of the loading screen overlay.
         * @param {string} message - The message to display.
         */
        function updateLoadingStatus(message) {
            document.getElementById('loading-status').innerText = message;
        }

        async function mainLoader() {
            const loadingOverlay = document.getElementById('loading-overlay');
            const yieldToBrowser = () => new Promise(resolve => setTimeout(resolve, 20));

            updateLoadingStatus('Structuring World...');
            await yieldToBrowser();
            createChunkGrid();

            updateLoadingStatus('Carving Background Strata...');
            await yieldToBrowser();
            skyImageData = generateCaveBackground(worldWidth, worldHeight);

            updateLoadingStatus('Generating Perlin Caves...');
            await yieldToBrowser();
            generateCavesWithPerlinNoise(worldWidth, worldHeight, grid);

            updateLoadingStatus('Constructing Ancient Structures...');
            await yieldToBrowser();
            generateAlchemyStation();

            updateLoadingStatus('Securing World Borders...');
            await yieldToBrowser();
            for (let y = 0; y < worldHeight; y++) {
                setGrid(getIdx(0, y), MAT.ADAMANTIUM);
                setGrid(getIdx(1, y), MAT.ADAMANTIUM);
                setGrid(getIdx(worldWidth - 1, y), MAT.ADAMANTIUM);
                setGrid(getIdx(worldWidth - 2, y), MAT.ADAMANTIUM);
            }
             for (let x = 0; x < worldWidth; x++) {
                setGrid(getIdx(x, 0), MAT.ADAMANTIUM);
                setGrid(getIdx(x, 1), MAT.ADAMANTIUM);
                setGrid(getIdx(x, worldHeight - 1), MAT.ADAMANTIUM);
                setGrid(getIdx(x, worldHeight - 2), MAT.ADAMANTIUM);
            }

            updateLoadingStatus('Activating Dynamic Matter...');
            await yieldToBrowser();
            activateInitialChunks();

            updateLoadingStatus('Igniting the First Light...');
            await yieldToBrowser();
            updateLighting(true);

            createPlayerBody(); 
            createWoodenBox(500, 150, 128, 16);
            createWoodenBox(500, 120, 96, 16);
            createWoodenBox(500, 90, 64, 16);
            createWoodenBox(500, 60, 32, 16);

            updateLoadingStatus('Done!');
            await new Promise(resolve => setTimeout(resolve, 100));

            loadingOverlay.style.transition = 'opacity 0.5s';
            loadingOverlay.style.opacity = '0';
            await new Promise(resolve => setTimeout(() => {
                loadingOverlay.style.display = 'none';
                resolve();
            }, 500));
            
            // The game loop will now be started from the new entry point.
            gameLoop();
        }

        /**
         * Renders the player's HP and Hover Energy bars in the top-left corner of the canvas.
         */
        function renderPlayerStatsUI() {
            const barWidth = 150;
            const barHeight = 10;
            const x = 15;
            let y = 15; // Starting Y position

            ctx.imageSmoothingEnabled = false;

            // --- HP Bar ---
            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Fill
            const hpPercent = player.hp / player.maxHp;
            ctx.fillStyle = '#d14242'; // Red for health
            ctx.fillRect(x, y, barWidth * hpPercent, barHeight);

            // Text Label
            ctx.fillStyle = 'white';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${player.hp}/${player.maxHp}`, x + barWidth / 2, y + barHeight / 2);

            // --- Hover Energy Bar ---
            y += barHeight + 5; // Move down for the next bar

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barWidth, barHeight);

            // Fill
            const energyPercent = player.hoverEnergy / player.maxHoverEnergy;
            ctx.fillStyle = '#DDED64';
            ctx.fillRect(x, y, barWidth * energyPercent, barHeight);
            
            // Text Label
            ctx.fillStyle = 'white';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${Math.round(player.hoverEnergy)}/${player.maxHoverEnergy}`, x + barWidth / 2, y + barHeight / 2);
        }

        /**
         * Generates a single static b2Body for a chunk by merging horizontal runs of solid pixels.
         * This version respects the pre-calculated "no-go" zone in the rigidBodyGrid,
         * refusing to create static fixtures where a dynamic body is currently located.
         * This prevents physics conflicts and jitter.
         * @param {object} chunk - The chunk to process.
         * @returns {b2Body} The newly created static body for the chunk.
         */
        function generateStaticBodyForChunk(chunk) {
            const bodyDef = new b2BodyDef();
            bodyDef.set_type(box2d.b2_staticBody);
            const body = box2dWorld.CreateBody(bodyDef);

            const startX = (chunk.index % chunkWidth) * CHUNK_SIZE;
            const startY = Math.floor(chunk.index / chunkWidth) * CHUNK_SIZE;

            for (let y = startY; y < startY + CHUNK_SIZE; y++) {
                for (let x = startX; x < startX + CHUNK_SIZE; x++) {
                    const idx = getIdx(x, y);

                    // If this pixel is a solid material...
                    if (isSolidForPlayer(grid[idx])) {

                        // ...and it's NOT inside the buffered "no-go" zone around a dynamic body...
                        if (rigidBodyGrid[idx] === 1) {
                            continue; // ...then skip it. Do not create a fixture here.
                        }

                        // Find the end of the horizontal run of valid, non-buffered solid pixels
                        let runEndX = x;
                        while (
                            runEndX + 1 < startX + CHUNK_SIZE &&
                            isSolidForPlayer(grid[getIdx(runEndX + 1, y)]) &&
                            rigidBodyGrid[getIdx(runEndX + 1, y)] !== 1 // Ensure the next pixel is also safe
                        ) {
                            runEndX++;
                        }
                        
                        // Create a single rectangular fixture for the entire run
                        const runWidth = (runEndX - x) + 1;
                        const fixtureDef = new b2FixtureDef();
                        const shape = new b2PolygonShape();
                        
                        const centerX = x + runWidth / 2;
                        const centerY = y + 0.5;
                        shape.SetAsBox(
                            (runWidth / 2) / B2_SCALE, 
                            0.5 / B2_SCALE, 
                            new b2Vec2(centerX / B2_SCALE, centerY / B2_SCALE), 
                            0
                        );
                        fixtureDef.set_shape(shape);
                        body.CreateFixture(fixtureDef);

                        // Skip the pixels we've already merged into this fixture
                        x = runEndX;
                    }
                }
            }
            body.SetActive(false); // Start inactive by default
            return body;
        }

        /**
         * The final, high-performance collider update. It activates/deactivates chunk bodies
         * and intelligently throttles expensive mesh regeneration to prevent memory crashes.
         * @param {number} now - The current time from performance.now().
         */
        function updateWorldColliders(now) {
            const neededChunks = new Set();
            const lookahead = 1; 

            const allDynamicBodies = [...rigidBodies, player];

            // 1. Determine which terrain chunks are needed.
            for (const bodyObject of allDynamicBodies) {
                if (!bodyObject.b2Body) continue;
                const fixture = bodyObject.b2Body.GetFixtureList();
                if (!fixture) continue;
                const aabb = fixture.GetAABB(0);
                
                const minChunkX = Math.floor(aabb.get_lowerBound().get_x() * B2_SCALE / CHUNK_SIZE) - lookahead;
                const maxChunkX = Math.ceil(aabb.get_upperBound().get_x() * B2_SCALE / CHUNK_SIZE) + lookahead;
                const minChunkY = Math.floor(aabb.get_lowerBound().get_y() * B2_SCALE / CHUNK_SIZE) - lookahead;
                const maxChunkY = Math.ceil(aabb.get_upperBound().get_y() * B2_SCALE / CHUNK_SIZE) + lookahead;

                for (let cy = minChunkY; cy <= maxChunkY; cy++) {
                    for (let cx = minChunkX; cx <= maxChunkX; cx++) {
                        if (cx >= 0 && cx < chunkWidth && cy >= 0 && cy < chunkHeight) {
                            neededChunks.add(chunkGrid[cy * chunkWidth + cx]);
                        }
                    }
                }
            }

            // 2. Deactivate chunks that are no longer needed.
            for (const chunk of activeStaticChunks) {
                if (!neededChunks.has(chunk) && chunk.staticBody) {
                    chunk.staticBody.SetActive(false);
                }
            }

            // 3. Activate/Regenerate newly needed chunks.
            for (const chunk of neededChunks) {
                // --- THE CRITICAL THROTTLING LOGIC ---
                // If a chunk is dirty and has an existing body, check the cooldown.
                if (chunk.dirty && chunk.staticBody) {
                    // Only destroy the body if enough time has passed since the last regen.
                    if (now - chunk.lastRegenTime > REGEN_COOLDOWN) {
                        box2dWorld.DestroyBody(chunk.staticBody);
                        chunk.staticBody = null;
                    } else {
                        // Cooldown is active, so we don't regenerate yet, but we keep it dirty.
                    }
                }

                // If the chunk needs a body (either new or just regenerated), create it.
                if (!chunk.staticBody) {
                    chunk.staticBody = generateStaticBodyForChunk(chunk);
                    chunk.dirty = false; // It's clean now.
                    chunk.lastRegenTime = now; // Stamp the time of this regeneration.
                }
                
                chunk.staticBody.SetActive(true);
            }

            activeStaticChunks = neededChunks;
        }

        function updateRigidBodies(now) {
            // First, update the terrain colliders based on the current state of the world
            updateWorldColliders(now);

            // Tell Box2D to step forward in time. 60fps, standard iterations.
            box2dWorld.Step(1 / 60, 10, 10);
            box2dWorld.ClearForces();
        }

        /**
         * Custom implementation to transform a local point to a world point.
         * This version is non-allocating; it writes the result into the 'out' vector.
         * @param {b2Vec2} out - The vector to store the result in.
         * @param {b2Transform} transform - The world transform of the body.
         * @param {b2Vec2} localPoint - The point in the body's local coordinates.
         */
        function transformPoint(out, transform, localPoint) {
            const p = transform.get_p();
            const q = transform.get_q();

            const localX = localPoint.get_x();
            const localY = localPoint.get_y();

            const rotatedX = localX * q.get_c() - localY * q.get_s();
            const rotatedY = localX * q.get_s() + localY * q.get_c();

            out.set_x(rotatedX + p.get_x());
            out.set_y(rotatedY + p.get_y());
        }

        //mainLoader();

        // --- NEW, CORRECT GAME ENTRY POINT ---

        // This ensures the page is loaded before we try to run anything.
        window.onload = function() {
            const loadingStatus = document.getElementById('loading-status');
            loadingStatus.innerText = 'Loading Physics Engine...';

            // Call the Box2D function and wait for its promise to resolve.
            Box2D().then(function(Box2DModule) {
                // SUCCESS! The physics engine is ready.
                // The 'Box2DModule' argument contains all the constructors.

                loadingStatus.innerText = 'Initializing Physics...';
                
                // Assign our global aliases from the resolved module.
                box2d = Box2DModule;
                b2Vec2 = box2d.b2Vec2;
                b2BodyDef = box2d.b2BodyDef;
                b2Body = box2d.b2Body;
                b2FixtureDef = box2d.b2FixtureDef;
                b2World = box2d.b2World;
                b2PolygonShape = box2d.b2PolygonShape;

                // NEW: Initialize our global temp vectors
                tempVec1 = new b2Vec2(0, 0);
                tempVec2 = new b2Vec2(0, 0);

                // Now it is safe to create the world.
                box2dWorld = new b2World(new b2Vec2(0, 9.8), true);

                // With physics ready, proceed to load the rest of the game.
                mainLoader();

            });
        };
    </script>
</body>
</html>